From 7b46ed5b0b6226397161cc7a699918c2dbd936a4 Mon Sep 17 00:00:00 2001
From: Ronan Abhamon <ronan.abhamon@vates.fr>
Date: Wed, 16 Aug 2023 12:04:01 +0200
Subject: [PATCH 124/170] fix(LinstorSR): always use lock.acquire() during
 attach/detach

We can't use a retry range on the lock because we can trigger a bad situation
in the detach step... When the GC has a lock on the SR and we try to acquire
the same lock in a detach call, and if we can't get this lock after 20 seconds,
the consequences are very bad:
- Many tapdisk instances of the same VDI can be created on two hosts
- The VDI info are not updated correctly
- And this issue is not immediately visible

Signed-off-by: Ronan Abhamon <ronan.abhamon@vates.fr>
---
 drivers/LinstorSR.py | 12 ++----------
 1 file changed, 2 insertions(+), 10 deletions(-)

diff --git a/drivers/LinstorSR.py b/drivers/LinstorSR.py
index 0bccc16..98919a4 100755
--- a/drivers/LinstorSR.py
+++ b/drivers/LinstorSR.py
@@ -142,14 +142,6 @@ def compute_volume_size(virtual_size, image_type):
     return LinstorVolumeManager.round_up_volume_size(virtual_size)
 
 
-def try_lock(lock):
-    for i in range(20):
-        if lock.acquireNoblock():
-            return
-        time.sleep(1)
-    raise util.SRBusyException()
-
-
 def attach_thin(session, journaler, linstor, sr_uuid, vdi_uuid):
     volume_metadata = linstor.get_volume_metadata(vdi_uuid)
     image_type = volume_metadata.get(VDI_TYPE_TAG)
@@ -158,7 +150,7 @@ def attach_thin(session, journaler, linstor, sr_uuid, vdi_uuid):
 
     lock = Lock(vhdutil.LOCK_TYPE_SR, sr_uuid)
     try:
-        try_lock(lock)
+        lock.acquire()
 
         device_path = linstor.get_device_path(vdi_uuid)
 
@@ -191,7 +183,7 @@ def detach_thin(session, linstor, sr_uuid, vdi_uuid):
 
     lock = Lock(vhdutil.LOCK_TYPE_SR, sr_uuid)
     try:
-        try_lock(lock)
+        lock.acquire()
 
         vdi_ref = session.xenapi.VDI.get_by_uuid(vdi_uuid)
         vbds = session.xenapi.VBD.get_all_records_where(
-- 
2.44.0

