From b870540473df318ec74fc8b7a2f916177cdece25 Mon Sep 17 00:00:00 2001
From: Ronan Abhamon <ronan.abhamon@vates.fr>
Date: Tue, 6 Feb 2024 00:10:32 +0100
Subject: [PATCH 162/175] fix(LinstorSR): create DRBD diskless if necessary for
 each VHD parent

It's necessary to have all parents during snapshot to create a new VHD child.

Signed-off-by: Ronan Abhamon <ronan.abhamon@vates.fr>
---
 drivers/LinstorSR.py | 60 ++++++++++++++++++++++++--------------------
 1 file changed, 33 insertions(+), 27 deletions(-)

diff --git a/drivers/LinstorSR.py b/drivers/LinstorSR.py
index 1e09e9b..53afbef 100755
--- a/drivers/LinstorSR.py
+++ b/drivers/LinstorSR.py
@@ -1827,32 +1827,7 @@ class LinstorVDI(VDI.VDI):
             return self._attach_using_http_nbd()
 
         # Ensure we have a path...
-        while vdi_uuid:
-            path = self._linstor.get_device_path(vdi_uuid)
-            if not util.pathexists(path):
-                raise xs_errors.XenError(
-                    'VDIUnavailable', opterr='Could not find: {}'.format(path)
-                )
-
-            # Diskless path can be created on the fly, ensure we can open it.
-            def check_volume_usable():
-                while True:
-                    try:
-                        with open(path, 'r+'):
-                            pass
-                    except IOError as e:
-                        if e.errno == errno.ENODATA:
-                            time.sleep(2)
-                            continue
-                        if e.errno == errno.EROFS:
-                            util.SMlog('Volume not attachable because RO. Openers: {}'.format(
-                                self.sr._linstor.get_volume_openers(vdi_uuid)
-                            ))
-                        raise
-                    break
-            util.retry(check_volume_usable, 15, 2)
-
-            vdi_uuid = self.sr._vhdutil.get_vhd_info(vdi_uuid).parentUuid
+        self._create_chain_paths(self.uuid)
 
         self.attached = True
         return VDI.VDI.attach(self, self.sr.uuid, self.uuid)
@@ -2379,7 +2354,7 @@ class LinstorVDI(VDI.VDI):
             raise xs_errors.XenError('SnapshotChainTooLong')
 
         # Ensure we have a valid path if we don't have a local diskful.
-        self.sr._linstor.get_device_path(self.uuid)
+        self._create_chain_paths(self.uuid)
 
         volume_path = self.path
         if not util.pathexists(volume_path):
@@ -2842,6 +2817,37 @@ class LinstorVDI(VDI.VDI):
         self._kill_persistent_nbd_server(volume_name)
         self._kill_persistent_http_server(volume_name)
 
+    def _create_chain_paths(self, vdi_uuid):
+        # OPTIMIZE: Add a limit_to_first_allocated_block param to limit vhdutil calls.
+        # Useful for the snapshot code algorithm.
+
+        while vdi_uuid:
+            path = self._linstor.get_device_path(vdi_uuid)
+            if not util.pathexists(path):
+                raise xs_errors.XenError(
+                    'VDIUnavailable', opterr='Could not find: {}'.format(path)
+                )
+
+            # Diskless path can be created on the fly, ensure we can open it.
+            def check_volume_usable():
+                while True:
+                    try:
+                        with open(path, 'r+'):
+                            pass
+                    except IOError as e:
+                        if e.errno == errno.ENODATA:
+                            time.sleep(2)
+                            continue
+                        if e.errno == errno.EROFS:
+                            util.SMlog('Volume not attachable because RO. Openers: {}'.format(
+                                self.sr._linstor.get_volume_openers(vdi_uuid)
+                            ))
+                        raise
+                    break
+            util.retry(check_volume_usable, 15, 2)
+
+            vdi_uuid = self.sr._vhdutil.get_vhd_info(vdi_uuid).parentUuid
+
 # ------------------------------------------------------------------------------
 
 
-- 
2.45.2

