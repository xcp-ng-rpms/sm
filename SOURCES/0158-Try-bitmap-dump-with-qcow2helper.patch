From 6f7735b9c15e187ebe10193d5b5ddaef81a1649d Mon Sep 17 00:00:00 2001
From: Damien Thenot <damien.thenot@vates.tech>
Date: Mon, 18 Aug 2025 17:17:13 +0200
Subject: [PATCH] Try bitmap dump with qcow2helper

Signed-off-by: Damien Thenot <damien.thenot@vates.tech>
---
 drivers/qcow2util.py |   7 ++-
 qcow2/qcow2_helper.c | 131 +++++++++++++++++++++++++++++++++----------
 2 files changed, 106 insertions(+), 32 deletions(-)

diff --git a/drivers/qcow2util.py b/drivers/qcow2util.py
index a929e2e2..759157c9 100644
--- a/drivers/qcow2util.py
+++ b/drivers/qcow2util.py
@@ -663,7 +663,7 @@ class QCowUtil(CowUtil):
 
     @override
     def getAllocatedSize(self, path: str) -> int:
-        cmd = [QCOW2_HELPER, path]
+        cmd = [QCOW2_HELPER, "allocated", path]
         return int(self._ioretry(cmd))
 
     @override
@@ -703,8 +703,9 @@ class QCowUtil(CowUtil):
 
     @override
     def getBlockBitmap(self, path: str) -> bytes:
-        self._read_qcow2(path, read_clusters=True) #TODO: Add read L2 info here, we want to use an external application to do this eventually
-        return zlib.compress(self._create_bitmap())
+        cmd = [QCOW2_HELPER, "bitmap", path]
+        text = cast(bytes, self._ioretry(cmd, text=False))
+        return zlib.compress(text)
 
     def _getTapdisk(self, path: str) -> Tuple[int, int]:
         """
diff --git a/qcow2/qcow2_helper.c b/qcow2/qcow2_helper.c
index 62ac5c36..b4590703 100644
--- a/qcow2/qcow2_helper.c
+++ b/qcow2/qcow2_helper.c
@@ -103,18 +103,103 @@ uint64_t get_cluster_to_byte(uint64_t allocated_clusters, uint64_t cluster_size)
     return allocated_clusters * cluster_size;
 }
 
+void mark_l1_unallocated(char* bitmap, int i){}
+
+void mark_l2_unallocated(char* bitmap, int i, int j){}
+
+void set_bit(char* m, int bit, int val){
+    *m |= (val << bit);
+}
+
+void dump_bitmap(struct qcow2_header* header, int fd, uint64_t *l1_table){
+    int i, n;
+    char* bitmap = NULL;
+    uint64_t cluster_size = (1 << header->cluster_bits); //cluster size in bytes
+    uint64_t total_blocks, bitmap_size;
+    uint64_t nb_l2_entries = (cluster_size / sizeof(uint64_t)); //Number of L2 in a L1 entry
+
+	total_blocks = header->size / cluster_size;
+    bitmap_size = total_blocks >> 3; // This transform our number of bits in a number of bytes for allocation
+    //Does VHD use sectors of 512 for the bitmap it dumps? Nope, it uses 2MiB. Do we want to use 2MiB to reduce QCOW2 size allocation? We would need a way to transform x 64KiB blocks in a 2MiB block.
+    bitmap = malloc(bitmap_size);
+    memset(bitmap, 0, bitmap_size);
+    uint64_t nb_byte_for_l1 = nb_l2_entries / 8; //Number of byte in the bitmap for a full L1
+
+    #pragma omp parallel for num_threads(4)
+    for(i = 0; i < header->l1_size; i++){
+        int j;
+        uint64_t *l2_table = NULL;
+        uint64_t l1_entry = l1_table[i];
+        if(l1_entry != 0){
+            l2_table = get_l2_table(header, fd, l1_entry); if(l2_table == NULL) { fprintf(stderr, "Couldn't get L2 entry\n"); exit(EXIT_FAILURE); }
+            char* base_l1_bitmap = bitmap + (i * nb_byte_for_l1);
+            for(j = 0; j < nb_l2_entries; j++){
+                if(is_l2_allocated(l2_table[j])){
+                    //Mark L2 entry allocated
+
+                    int mementry = j/8;
+                    int bit = j%8;
+                    set_bit(&(base_l1_bitmap[mementry]), bit, 1);
+                }
+                else {
+                    // Mark L2 entry as not allocated
+                    mark_l2_unallocated(bitmap, i, j); // The bytes are already zeroed, we don't need to do anything
+                }
+            }
+            free(l2_table);
+        }
+        else{
+            //Mark L1 (and subsequent L2) non allocated
+            mark_l1_unallocated(bitmap, i); // The bytes are already zeroed, we don't need to do anything
+            // memset(base_l1_bitmap, 0, nb_byte_for_l1); //Mark the whole L1 as being unused
+        }
+    }
+
+    n = write(STDOUT_FILENO, bitmap, bitmap_size);
+    if (n < 0){
+        fprintf(stderr, "Error writing bitmap to stdout");
+    }
+    free(bitmap);
+}
+
+int get_allocated_blocks(struct qcow2_header* header, int fd, uint64_t *l1_table){
+    uint64_t allocated_clusters = 0;
+    int i, cluster_size = (1 << header->cluster_bits), nb_l2_entries = cluster_size / (sizeof(uint64_t));
+
+
+    #pragma omp parallel for num_threads(4) reduction (+:allocated_clusters)
+    for(i = 0; i < header->l1_size; i++){
+        int j;
+        uint64_t *l2_table = NULL;
+        uint64_t l1_entry = l1_table[i];
+        if(l1_entry != 0){
+            l2_table = get_l2_table(header, fd, l1_entry);
+            if(l2_table == NULL){
+                fprintf(stderr, "Couldn't get L2 Table");
+            }
+            for(j = 0; j < nb_l2_entries; j++){
+                if(is_l2_allocated(l2_table[j])){
+                    allocated_clusters += 1;
+                }
+            }
+            free(l2_table);
+        }
+    }
+    return allocated_clusters;
+}
+
 int main(int argc, char* argv[]){
     struct qcow2_header* header = NULL;
-    char * filename = NULL, * backing_file_name = NULL;
-    int fd, nb_l2_entries = 0, err = 0, i = 0, ret = EXIT_SUCCESS;
-    uint64_t *l1_table = NULL, cluster_size = 0, allocated_clusters = 0, allocated = 0;
+    char * command, * filename = NULL, * backing_file_name = NULL;
+    int fd, err = 0, ret = EXIT_SUCCESS;
+    uint64_t *l1_table = NULL, cluster_size = 0, allocated_clusters = 0, allocated_byte = 0;
 
-    if(argc < 2){
+    if(argc != 3){
         fprintf(stderr, "Need an argument\n");
         exit(EXIT_FAILURE);
     }
-
-    filename = argv[1];
+    command = argv[1];
+    filename = argv[2];
     fd = open(filename, O_RDONLY);
     if(fd < 0){
         fprintf(stderr, "Opening file %s failed with error %s (%d)\n", filename, strerror(errno), errno);
@@ -158,30 +243,18 @@ int main(int argc, char* argv[]){
         goto free_backing;
     }
 
-    nb_l2_entries = cluster_size / (sizeof(uint64_t));
-
-    #pragma omp parallel for num_threads(4) reduction (+:allocated_clusters)
-    for(i = 0; i < header->l1_size; i++){
-        int j;
-        uint64_t *l2_table = NULL;
-        uint64_t l1_entry = l1_table[i];
-        if(l1_entry != 0){
-            l2_table = get_l2_table(header, fd, l1_entry);
-            if(l2_table == NULL){
-                fprintf(stderr, "Couldn't get L2 Table");
-            }
-            for(j = 0; j < nb_l2_entries; j++){
-                if(is_l2_allocated(l2_table[j])){
-                    allocated_clusters += 1;
-                }
-            }
-            free(l2_table);
-        }
+    if(!strcmp("bitmap", command)){
+        dump_bitmap(header, fd, l1_table);
+    }
+    else if(!strcmp("allocated", command)){
+        allocated_clusters = get_allocated_blocks(header, fd, l1_table);
+        allocated_byte = get_cluster_to_byte(allocated_clusters, cluster_size);
+        printf("%lu\n", allocated_byte);
+    }
+    else{
+        fprintf(stderr, "Command %s is unknown.\n", command);
+        ret = EXIT_FAILURE;
     }
-
-    allocated = get_cluster_to_byte(allocated_clusters, cluster_size);
-    // printf("Allocated: %lu\n", allocated);
-    printf("%lu\n", allocated);
 
     if(l1_table != NULL){
         free(l1_table);
