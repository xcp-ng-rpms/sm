From 5e65353dbf934d7fbadc9576c3ca2875f944f6f5 Mon Sep 17 00:00:00 2001
From: Damien Thenot <damien.thenot@vates.tech>
Date: Wed, 25 Jun 2025 17:00:22 +0200
Subject: [PATCH] Add qcow2helper to compute allocated blocks

Signed-off-by: Damien Thenot <damien.thenot@vates.tech>
---
 Makefile             |   2 +
 drivers/qcow2util.py |  44 ++++----
 qcow2/Makefile       |  24 +++++
 qcow2/qcow2_helper.c | 250 +++++++++++++++++++++++++++++++++++++++++++
 4 files changed, 298 insertions(+), 22 deletions(-)
 create mode 100644 qcow2/Makefile
 create mode 100644 qcow2/qcow2_helper.c

diff --git a/Makefile b/Makefile
index 2c1e7d30..b092d2d2 100755
--- a/Makefile
+++ b/Makefile
@@ -108,6 +108,7 @@ SM_PY_FILES = $(foreach LIB, $(SM_LIBS), drivers/$(LIB).py) $(foreach DRIVER, $(
 build:
 	make -C dcopy
 	make -C linstor
+	make -C qcow2
 
 .PHONY: precommit
 precommit: build
@@ -235,6 +236,7 @@ install: build
 	mkdir -p $(SM_STAGING)/etc/xapi.d/xapi-pre-shutdown/
 	install -m 755 scripts/stop_all_gc $(SM_STAGING)/etc/xapi.d/xapi-pre-shutdown/
 	$(MAKE) -C dcopy install DESTDIR=$(SM_STAGING)
+	$(MAKE) -C qcow2 install DESTDIR=$(SM_STAGING)
 	$(MAKE) -C linstor install DESTDIR=$(SM_STAGING)
 	$(MAKE) -C sm_typing install DESTDIR=$(SM_STAGING)
 	ln -sf $(SM_DEST)blktap2.py $(SM_STAGING)$(BIN_DEST)/blktap2
diff --git a/drivers/qcow2util.py b/drivers/qcow2util.py
index 7f097765..0a2e302c 100644
--- a/drivers/qcow2util.py
+++ b/drivers/qcow2util.py
@@ -24,6 +24,7 @@ MIN_QCOW_SIZE: Final = QCOW_CLUSTER_SIZE
 MAX_QCOW_SIZE: Final = 16 * 1024 * 1024 * 1024 * 1024
 
 QEMU_IMG: Final = "/usr/bin/qemu-img"
+QCOW2_HELPER = "/opt/xensource/libexec/qcow2_helper"
 
 QCOW2_TYPE: Final = "qcow2"
 RAW_TYPE: Final = "raw"
@@ -51,26 +52,27 @@ class QCowUtil(CowUtil):
     def __init__(self):
         self.qcow_read = False
 
-    def _read_qcow2(self, path: str):
+    def _read_qcow2(self, path: str, read_clusters: bool = False):
         phys_disk_size = self.getSizePhys(path)
         with open(path, "rb") as qcow2_file:
             self.filename = path  # Keep the filename if clean is called
             self.header = self._read_qcow2_header(qcow2_file)
-            self.l1 = self._get_l1_entries(qcow2_file)
-            # The l1_to_l2 allows to get L2 entries for a given L1. If L1 entry
-            # is not allocated we store an empty list.
-            self.l1_to_l2: Dict[int, List[int]] = {}
-
-            for l1_entry in self.l1:
-                l2_offset = l1_entry & self.L2_OFFSET_MASK
-                if l2_offset == 0:
-                    self.l1_to_l2[l1_entry] = []
-                elif l2_offset > phys_disk_size:
-                    raise xs_errors.XenError("VDISize", "L2 Offset is bigger than physical disk {}".format(path))
-                else:
-                    self.l1_to_l2[l1_entry] = self._get_l2_entries(
-                        qcow2_file, l2_offset
-                    )
+            if read_clusters:
+                self.l1 = self._get_l1_entries(qcow2_file)
+                # The l1_to_l2 allows to get L2 entries for a given L1. If L1 entry
+                # is not allocated we store an empty list.
+                self.l1_to_l2: Dict[int, List[int]] = {}
+
+                for l1_entry in self.l1:
+                    l2_offset = l1_entry & self.L2_OFFSET_MASK
+                    if l2_offset == 0:
+                        self.l1_to_l2[l1_entry] = []
+                    elif l2_offset > phys_disk_size: #TODO: This sometime happen for a correct VDI (while coalescing online?)
+                        raise xs_errors.XenError("VDISize", "L2 Offset is bigger than physical disk {}".format(path))
+                    else:
+                        self.l1_to_l2[l1_entry] = self._get_l2_entries(
+                            qcow2_file, l2_offset
+                        )
         self.qcow_read = True
 
     def _get_l1_entries(self, file: BinaryIO) -> List[int]:
@@ -466,7 +468,7 @@ class QCowUtil(CowUtil):
         cowinfo.sizeVirt = self.header["virtual_disk_size"]
         cowinfo.sizePhys = self.getSizePhys(path)
         cowinfo.hidden = self.getHidden(path)
-        cowinfo.sizeAllocated = self._get_cluster_to_byte(self._get_number_of_allocated_clusters(), self.header["cluster_bits"])
+        cowinfo.sizeAllocated = self.getAllocatedSize(path)
         if includeParent:
             parent_path = self.header["parent"]
             if parent_path != "":
@@ -671,10 +673,8 @@ class QCowUtil(CowUtil):
 
     @override
     def getAllocatedSize(self, path: str) -> int:
-        self._read_qcow2(path)
-        clusters = self._get_number_of_allocated_clusters()
-        cluster_bits =  self.header["cluster_bits"]
-        return self._get_cluster_to_byte(clusters, cluster_bits)
+        cmd = [QCOW2_HELPER, path]
+        return int(self._ioretry(cmd))
 
     @override
     def getResizeJournalSize(self) -> int:
@@ -713,7 +713,7 @@ class QCowUtil(CowUtil):
 
     @override
     def getBlockBitmap(self, path: str) -> bytes:
-        self._read_qcow2(path)
+        self._read_qcow2(path, read_clusters=True) #TODO: Add read L2 info here, we want to use an external application to do this eventually
         return zlib.compress(self._create_bitmap())
 
     def _getTapdisk(self, path: str) -> Tuple[int, int]:
diff --git a/qcow2/Makefile b/qcow2/Makefile
new file mode 100644
index 00000000..2342f084
--- /dev/null
+++ b/qcow2/Makefile
@@ -0,0 +1,24 @@
+PREFIX ?= /opt/xensource/libexec
+DESTDIR ?= 
+DEBUGDIR ?= /opt/xensource/debug
+
+
+OPTS := -D _GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE64_SOURCE -g -Wall
+
+SRC := qcow2_helper.c
+
+BIN := qcow2_helper
+
+all: qcow2_helper
+
+qcow2_helper: qcow2_helper.c
+	$(CC) $(OPTS) $(SRC) -o $(BIN)
+
+install: install_qcow2_helper
+
+install_qcow2_helper: qcow2_helper
+	mkdir -p $(DESTDIR)$(PREFIX)
+	install -m 755 $^ $(DESTDIR)$(PREFIX)
+
+clean:
+	rm -f qcow2_helper
diff --git a/qcow2/qcow2_helper.c b/qcow2/qcow2_helper.c
new file mode 100644
index 00000000..2149b69f
--- /dev/null
+++ b/qcow2/qcow2_helper.c
@@ -0,0 +1,250 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <errno.h>
+
+#define QCOW2_HEADER_SIZE 104
+#define QCOW2_MAGIC 0x514649FB
+
+#define L2_OFFSET_MASK 0x00FFFFFFFFFFFF00
+#define STANDARD_CLUSTER_OFFSET_MASK 0x00FFFFFFFFFFFF00 /* Bits 9-55 are offset of standard cluster */
+#define CLUSTER_TYPE_BIT (1UL << 62) /* 0 for standard, 1 for compressed cluster */
+#define ALLOCATED_ENTRY_BIT (1UL << 63) /* Bit 63 is the allocated bit for standard cluster */
+
+
+struct qcow2_header {
+    uint32_t magic;
+    uint32_t version;
+    uint64_t backing_file_offset;
+    uint32_t backing_file_size;
+    uint32_t cluster_bits;
+    uint64_t size; /* in bytes */
+    uint32_t crypt_method;
+    uint32_t l1_size; /* XXX: save number of clusters instead ? */
+    uint64_t l1_table_offset;
+    uint64_t refcount_table_offset;
+    uint32_t refcount_table_clusters;
+    uint32_t nb_snapshots;
+    uint64_t snapshots_offset;
+
+    /* The following fields are only valid for version >= 3 */
+    uint64_t incompatible_features;
+    uint64_t compatible_features;
+    uint64_t autoclear_features;
+
+    uint32_t refcount_order;
+    uint32_t header_length;
+
+    /* Additional fields */
+    uint8_t compression_type;
+
+    /* header must be a multiple of 8 */
+    uint8_t padding[7];
+} __attribute__((packed));
+
+#define SWAP_BE_LE(size, x) \
+    header->x = __builtin_bswap ##size(header->x)
+
+void transform_header_be_to_le(struct qcow2_header* header){
+    SWAP_BE_LE(32, magic);
+    SWAP_BE_LE(32, version);
+    SWAP_BE_LE(64, backing_file_offset);
+    SWAP_BE_LE(32, backing_file_size);
+    SWAP_BE_LE(32, cluster_bits);
+    SWAP_BE_LE(64, size);
+    SWAP_BE_LE(32, crypt_method);
+    SWAP_BE_LE(32, l1_size);
+    SWAP_BE_LE(64, l1_table_offset);
+    SWAP_BE_LE(64, refcount_table_offset);
+    SWAP_BE_LE(32, refcount_table_clusters);
+    SWAP_BE_LE(32, nb_snapshots);
+    SWAP_BE_LE(64, snapshots_offset);
+    SWAP_BE_LE(64, incompatible_features);
+    SWAP_BE_LE(64, compatible_features);
+    SWAP_BE_LE(64, autoclear_features);
+    SWAP_BE_LE(32, refcount_order);
+    SWAP_BE_LE(32, header_length);
+}
+
+char* qcow2_get_backing_file(struct qcow2_header* header, int fd){
+    int err, backing_file_name_size;
+    char* backing_file_name;
+
+    if(header->backing_file_offset != 0){
+        backing_file_name_size = header->backing_file_size+1;
+        backing_file_name = malloc(backing_file_name_size);
+        if(backing_file_name == NULL){
+            fprintf(stderr, "Failed to allocate for backing file name");
+            exit(EXIT_FAILURE);
+        }
+        lseek(fd, header->backing_file_offset, SEEK_SET);
+        err = read(fd, backing_file_name, header->backing_file_size);
+        if(err < 0){
+            fprintf(stderr, "Couldn't read backing file: %s (%d)\n", strerror(errno), errno);
+            exit(EXIT_FAILURE);
+        }
+        backing_file_name[backing_file_name_size-1] = '\0';
+        return backing_file_name;
+    }
+    return NULL;
+}
+
+uint64_t* get_l1_offset(struct qcow2_header* header, int fd){
+    int i, err = 0;
+    uint64_t* raw_l1 = NULL;
+    uint64_t l1_offset = header->l1_table_offset;
+    uint32_t l1_table_size = sizeof(uint64_t) * header->l1_size;
+
+    raw_l1 = malloc(l1_table_size);
+    if(raw_l1 == NULL){
+        fprintf(stderr, "Couldn't allocate %d byte for L1 table\n", l1_table_size);
+        return NULL;
+    }
+
+    lseek(fd, l1_offset, SEEK_SET);
+    err = read(fd, raw_l1, l1_table_size);
+    if(err < 0){
+        fprintf(stderr, "Couldn't read L1 table\n");
+        free(raw_l1);
+        return NULL;
+    }
+
+    for(i = 0; i < header->l1_size; i++){
+        raw_l1[i] = (__builtin_bswap64(raw_l1[i]) & L2_OFFSET_MASK);
+    }
+
+    return raw_l1;
+}
+
+uint64_t* get_l2_table(struct qcow2_header* header, int fd, uint64_t offset){
+    int i;
+    uint64_t* raw_l2 = NULL;
+    uint64_t cluster_size = (1 << header->cluster_bits);
+    uint64_t nb_l2_entries = (cluster_size / sizeof(uint64_t));
+
+    raw_l2 = malloc(cluster_size);
+    if(raw_l2 == NULL){
+        fprintf(stderr, "Couldn't allocate %d byte for L1 table\n", cluster_size);
+        return NULL;
+    }
+
+    lseek(fd, offset, SEEK_SET);
+    read(fd, raw_l2, cluster_size);
+
+    for(i = 0; i < nb_l2_entries; i++){
+        raw_l2[i] = __builtin_bswap64(raw_l2[i]);
+    }
+
+    return raw_l2;
+}
+
+int is_l2_allocated(uint64_t l2_entry){
+    if((l2_entry & CLUSTER_TYPE_BIT) != 0){
+        fprintf(stderr, "Cluster is compressed\n");
+        exit(EXIT_FAILURE); //TODO: Read compressed clusters
+    }
+    return ((l2_entry & ALLOCATED_ENTRY_BIT) != 0) || ((l2_entry & STANDARD_CLUSTER_OFFSET_MASK) != 0);
+}
+
+uint64_t get_cluster_to_byte(uint64_t allocated_clusters, uint64_t cluster_size){
+    return allocated_clusters * cluster_size;
+}
+
+int main(int argc, char* argv[]){
+    struct qcow2_header* header = NULL;
+    char * filename = NULL, * backing_file_name = NULL;
+    int fd, filename_len = 0, nb_l2_entries = 0, err = 0, i = 0, j = 0, ret = EXIT_SUCCESS;
+    uint64_t *l1_table = NULL, *l2_table = NULL, cluster_size = 0, allocated_clusters = 0, allocated = 0;
+
+    if(argc < 2){
+        fprintf(stderr, "Need an argument\n");
+        exit(EXIT_FAILURE);
+    }
+
+    filename_len = strlen(argv[1]);
+    filename = malloc(filename_len);
+    if(filename == NULL){
+        fprintf(stderr, "Failed allocating filename\n");
+        exit(EXIT_FAILURE);
+    }
+    strcpy(filename, argv[1]);
+    fd = open(filename, O_RDONLY);
+    if(fd < 0){
+        fprintf(stderr, "Opening file failed with error %s (%d)\n", filename, strerror(errno), errno);
+        ret = EXIT_FAILURE;
+        goto exit_filename;
+    }
+    lseek(fd, 0, SEEK_SET);
+
+    // printf("Reading header from %s\n", filename);
+
+    header = malloc(QCOW2_HEADER_SIZE);
+    if(header == NULL){
+        fprintf(stderr, "Couldn't allocate header\n");
+        ret = EXIT_FAILURE;
+        goto close_and_exit;
+    }
+
+    err = read(fd, header, QCOW2_HEADER_SIZE);
+    if(err < 0){
+        fprintf(stderr, "Failed reading file\n");
+        ret = EXIT_FAILURE;
+        goto close;
+    }
+
+    transform_header_be_to_le(header);
+
+    if(header->magic != QCOW2_MAGIC){
+        fprintf(stderr, "MAGIC is wrong\n");
+        goto close;
+    }
+
+    cluster_size = (1 << header->cluster_bits);
+
+    // printf("Version: %d\n", header->version);
+    // backing_file_name = qcow2_get_backing_file(header, fd);
+    // printf("Backing file: %s\n", backing_file_name);
+
+    l1_table = get_l1_offset(header, fd);
+    if(l1_table == NULL){
+        fprintf(stderr, "Couldn't read L1 Table\n");
+        ret = EXIT_FAILURE;
+        goto free_backing;
+    }
+
+    nb_l2_entries = cluster_size / (sizeof(uint64_t));
+
+    for(i = 0; i < header->l1_size; i++){
+        if(l1_table[i] != 0){;
+            l2_table = get_l2_table(header, fd, l1_table[i]);
+            for(j = 0; j < nb_l2_entries; j++){
+                if(is_l2_allocated(l2_table[j])){
+                    allocated_clusters += 1;
+                }
+            }
+            free(l2_table);
+        }
+    }
+
+    allocated = get_cluster_to_byte(allocated_clusters, cluster_size);
+    // printf("Allocated: %lu\n", allocated);
+    printf("%lu\n", allocated);
+
+    if(l1_table != NULL){
+        free(l1_table);
+    }
+
+free_backing:
+    if(backing_file_name != NULL)
+        free(backing_file_name);
+close:
+    free(header);
+close_and_exit:
+    close(fd);
+exit_filename:
+    free(filename);
+    exit(ret);
+}
