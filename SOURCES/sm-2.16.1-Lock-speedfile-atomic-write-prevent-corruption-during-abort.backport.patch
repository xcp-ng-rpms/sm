From 67f0eef4919be2b83e83d8088dcb79637db34236 Mon Sep 17 00:00:00 2001
From: ben sims <ben.sims@citrix.com>
Date: Thu, 12 Dec 2019 11:21:39 +0000
Subject: [PATCH] CA-332806 - Lock speedfile and use atomic write to prevent
 corruption during abort.

Signed-off-by: ben sims <ben.sims@citrix.com>
---
 drivers/cleanup.py    |  27 +++++----
 drivers/util.py       |  31 ++++++++++
 tests/test_cleanup.py | 129 ++++++++++++++++++++++--------------------
 tests/test_utils.py   |  57 +++++++++++++++++++
 4 files changed, 174 insertions(+), 70 deletions(-)

diff --git a/drivers/cleanup.py b/drivers/cleanup.py
index a1d71d74..12f15305 100755
--- a/drivers/cleanup.py
+++ b/drivers/cleanup.py
@@ -75,7 +75,9 @@
 
 COALESCE_LAST_ERR_TAG = 'last-coalesce-error'
 COALESCE_ERR_RATE_TAG = 'coalesce-error-rate'
-SPEED_LOG_ROOT = "/var/run/{uuid}.speed_log"
+VAR_RUN = "/var/run/"
+SPEED_LOG_ROOT = VAR_RUN + "{uuid}.speed_log"
+
 N_RUNNING_AVERAGE = 10
 
 class AbortException(util.SMException):
@@ -189,8 +191,9 @@ def runAbortable(func, ret, ns, abortTest, pollInterval, timeOut):
                 else:
                     resultFlag.set("failure")
             except Exception, e:
-                resultFlag.set("failure")
                 Util.log("Child process failed with : (%s)" % e)
+                resultFlag.set("failure")
+                Util.logException("This exception has occured")
             os._exit(0)
     runAbortable = staticmethod(runAbortable)
 
@@ -1914,24 +1917,26 @@ def writeSpeedToFile(self, speed):
         content = []
         speedFile = None
         path = SPEED_LOG_ROOT.format(uuid=self.uuid)
+        self.lock()
         try:
+            Util.log("Writing to file: {myfile}".format(myfile=path))
+            lines = ""
             if not os.path.isfile(path):
-                # First time open
-                speedFile = open(path, "w")
-                # Set perms -rwx------
-                os.chmod(path, stat.S_IRWXU)
-                speedFile.write(str(speed)+"\n")
+                lines = str(speed)+"\n"
             else:
                 speedFile = open(path, "r+")
                 content = speedFile.readlines()
                 content.append(str(speed) + "\n")
                 if len(content) > N_RUNNING_AVERAGE:
                     del content[0]
-                speedFile.seek(0)
-                speedFile.writelines(content)
+                lines = "".join(content)
+
+            util.atomicFileWrite(path, VAR_RUN, lines)
         finally:
-            if not (speedFile is None):
+            if speedFile is not None:
                 speedFile.close()
+            Util.log("Closing file: {myfile}".format(myfile=path))
+            self.unlock()
 
     def recordStorageSpeed(self, startTime, endTime, vhdSize):
         speed = self.calcStorageSpeed(startTime, endTime, vhdSize)
@@ -1943,6 +1948,7 @@ def recordStorageSpeed(self, startTime, endTime, vhdSize):
     def getStorageSpeed(self):
         speedFile = None
         path = SPEED_LOG_ROOT.format(uuid=self.uuid)
+        self.lock()
         try:
             speed = None
             if os.path.isfile(path):
@@ -1972,6 +1978,7 @@ def getStorageSpeed(self):
         finally:
             if not (speedFile is None):
                 speedFile.close()
+            self.unlock()
 
     def _snapshotCoalesce(self, vdi):
         # Note that because we are not holding any locks here, concurrent SM 
diff --git a/drivers/util.py b/drivers/util.py
index c257ec76..4b874388 100755
--- a/drivers/util.py
+++ b/drivers/util.py
@@ -34,6 +34,7 @@
 import traceback
 import glob
 import copy
+import tempfile
 
 NO_LOGGING_STAMPFILE='/etc/xensource/no_sm_log'
 
@@ -191,6 +192,36 @@ def pread(cmdlist, close_stdin=False, scramble=None, expect_rc=0,
         SMlog("  pread SUCCESS")
     return stdout
 
+
+# POSIX guaranteed atomic within the same file system.
+# Supply directory to ensure tempfile is created
+# in the same directory.
+def atomicFileWrite(targetFile, directory, text):
+
+    file = None
+    try:
+        # Create file only current pid can write/read to
+        # our responsibility to clean it up.
+        _, tempPath = tempfile.mkstemp(dir=directory)
+        file = open(tempPath, 'w')
+        file.write(text)
+
+        # Ensure flushed to disk.
+        file.flush()
+        os.fsync(file.fileno())
+        file.close()
+
+        os.rename(tempPath, targetFile)
+    except OSError:
+        SMlog("FAILED to atomic write to %s" % (targetFile))
+
+    finally:
+        if (file is not None) and (not file.closed):
+            file.close()
+
+        if os.path.isfile(tempPath):
+            os.remove(tempPath)
+
 #Read STDOUT from cmdlist and discard STDERR output
 def pread2(cmdlist, quiet = False):
     return pread(cmdlist, quiet = quiet)
diff --git a/tests/test_cleanup.py b/tests/test_cleanup.py
index d4182ca1..753733d0 100644
--- a/tests/test_cleanup.py
+++ b/tests/test_cleanup.py
@@ -932,9 +932,12 @@ def makeFakeFile(self):
         FakeFile.seek = mock.MagicMock()
         return FakeFile
 
-    def getStorageSpeed(self, mock_isFile, sr, fakeFile, isFile, expectedRes,
-                        closeCount, lines=None):
+    def getStorageSpeed(self, mock_lock, mock_unlock,  mock_isFile, sr,
+                        fakeFile, isFile, expectedRes, closeCount,
+                        lines=None):
         fakeFile.close.call_count = 0
+        mock_lock.reset_mock()
+        mock_unlock.reset_mock()
         mock_isFile.return_value = isFile
         if lines:
             FakeFile.readlines.return_value = lines
@@ -942,34 +945,44 @@ def getStorageSpeed(self, mock_isFile, sr, fakeFile, isFile, expectedRes,
         self.assertEqual(res, expectedRes)
 
         self.assertEqual(fakeFile.close.call_count, closeCount)
+        self.assertEqual(mock_lock.call_count, 1)
+        self.assertEqual(mock_unlock.call_count, 1)
 
     @mock.patch("__builtin__.open", autospec=True)
     @mock.patch("os.path.isfile", autospec=True)
     @mock.patch("os.chmod", autospec=True)
-    def test_getStorageSpeed(self, mock_chmod, mock_isFile, mock_open):
+    @mock.patch("cleanup.SR.lock", autospec=True)
+    @mock.patch("cleanup.SR.unlock", autospec=True)
+    def test_getStorageSpeed(self, mock_unlock, mock_lock, mock_chmod,
+                             mock_isFile, mock_open):
         sr_uuid = uuid4()
         sr = create_cleanup_sr(uuid=str(sr_uuid))
         fakeFile = self.makeFakeFile()
         mock_open.return_value = FakeFile
 
         # File does not exist
-        self.getStorageSpeed(mock_isFile, sr, fakeFile, False, None, 0)
+        self.getStorageSpeed(mock_lock, mock_unlock, mock_isFile, sr, fakeFile,
+                             False, None, 0)
 
         # File exists but empty (should be impossible)
-        self.getStorageSpeed(mock_isFile, sr, fakeFile, True, None, 1,
-                             lines=[])
+        self.getStorageSpeed(mock_lock, mock_unlock, mock_isFile, sr, fakeFile,
+                             True, None, 1, lines=[])
 
         # File exists one value
-        self.getStorageSpeed(mock_isFile, sr, fakeFile, True, 2.0, 1,
-                             lines=[2.0])
+        self.getStorageSpeed(mock_lock, mock_unlock, mock_isFile, sr, fakeFile,
+                             True, 2.0, 1, lines=["2.0"])
 
         # File exists 3 values
-        self.getStorageSpeed(mock_isFile, sr, fakeFile, True, 3.0, 1,
-                             lines=[1.0, 2.0, 6.0])
+        self.getStorageSpeed(mock_lock, mock_unlock, mock_isFile, sr, fakeFile,
+                             True, 3.0, 1, lines=["1.0", "2.0", "6.0"])
 
         # File exists contains, a string
-        self.getStorageSpeed(mock_isFile, sr, fakeFile, True, None, 1,
-                             lines=[1.0, 2.0, "Hello"])
+        self.getStorageSpeed(mock_lock, mock_unlock, mock_isFile, sr, fakeFile,
+                             True, None, 1, lines=["1.0", "2.0", "Hello"])
+
+        # File exists contains, a string
+        self.getStorageSpeed(mock_lock, mock_unlock, mock_isFile, sr, fakeFile,
+                             True, None, 1, lines=[1.0, 2.0, "Hello"])
 
     def speedFileSetup(self, sr, FakeFile, mock_isFile, isFile):
         expectedPath = cleanup.SPEED_LOG_ROOT.format(uuid=sr.uuid)
@@ -981,58 +994,71 @@ def speedFileSetup(self, sr, FakeFile, mock_isFile, isFile):
         FakeFile.seek.reset_mock()
         return expectedPath
 
-    def writeSpeedFile(self, sr, speed, mock_isFile, isFile, mock_open,
-                       mock_chmod, write=None, writeLines=None, readLines=None,
-                       openOp="r+"):
+    def writeSpeedFile(self, mock_lock, mock_unlock, sr, speed, mock_isFile,
+                       isFile, mock_open, mock_atomicWrite, write=None,
+                       readLines=None, openOp="r+"):
         mock_open.reset_mock()
-        mock_chmod.reset_mock()
+        mock_atomicWrite.reset_mock()
+        mock_lock.reset_mock()
+        mock_unlock.reset_mock()
         expectedPath = self.speedFileSetup(sr, FakeFile, mock_isFile, isFile)
         FakeFile.readlines.return_value = readLines
         sr.writeSpeedToFile(speed)
-        mock_open.assert_called_with(expectedPath, openOp)
-        if openOp == "w":
-            mock_chmod.assert_called_with(expectedPath, stat.S_IRWXU)
-        if write:
-            FakeFile.write.assert_called_with(write)
-        if writeLines:
-            FakeFile.seek.assert_called_with(0)
-            FakeFile.writelines.assert_called_with(writeLines)
-        self.assertEqual(FakeFile.close.call_count, 1)
+
+        if isFile:
+            mock_open.assert_called_with(expectedPath, openOp)
+            self.assertEqual(FakeFile.close.call_count, 1)
+
+        mock_atomicWrite.assert_called_with(expectedPath, cleanup.VAR_RUN,
+                                            write)
+
+        self.assertEqual(mock_lock.call_count, 1)
+        self.assertEqual(mock_unlock.call_count, 1)
 
     @mock.patch("__builtin__.open",
                 autospec=True)
     @mock.patch("os.path.isfile", autospec=True)
-    @mock.patch("os.chmod", autospec=True)
-    def test_writeSpeedToFile(self, mock_chmod, mock_isFile, mock_open):
+    @mock.patch("util.atomicFileWrite", autospec=True)
+    @mock.patch("cleanup.SR.lock", autospec=True)
+    @mock.patch("cleanup.SR.unlock", autospec=True)
+    def test_writeSpeedToFile(self, mock_lock, mock_unlock, mock_atomicWrite,
+                              mock_isFile, mock_open):
         sr_uuid = uuid4()
         sr = create_cleanup_sr(uuid=str(sr_uuid))
         FakeFile = self.makeFakeFile()
         mock_open.return_value = FakeFile
 
         # File does not exist
-        self.writeSpeedFile(sr, 1.8, mock_isFile, False, mock_open, mock_chmod,
+        self.writeSpeedFile(mock_lock, mock_unlock, sr, 1.8, mock_isFile,
+                            False, mock_open, mock_atomicWrite,
                             write="1.8\n", openOp="w")
 
         # File does exist but empty (Should not happen)
         readLines = []
-        writeLines = ["1.8\n"]
-        self.writeSpeedFile(sr, 1.8, mock_isFile, True, mock_open, mock_chmod,
-                            readLines=readLines, writeLines=writeLines)
+        write = "1.8\n"
+        self.writeSpeedFile(mock_lock, mock_unlock, sr, 1.8, mock_isFile, True,
+                            mock_open, mock_atomicWrite, readLines=readLines,
+                            write=write)
 
         # File does exist, exception fired, make sure close fd.
+        mock_lock.reset_mock()
+        mock_unlock.reset_mock()
         expectedPath = self.speedFileSetup(sr, FakeFile, mock_isFile, True)
         FakeFile.readlines.side_effect = Exception
         with self.assertRaises(Exception):
             sr.writeSpeedToFile(1.8)
         mock_open.assert_called_with(expectedPath, 'r+')
         self.assertEqual(FakeFile.close.call_count, 1)
+        self.assertEqual(mock_lock.call_count, 1)
+        self.assertEqual(mock_unlock.call_count, 1)
         FakeFile.readlines.side_effect = None
 
         # File does exist
         readLines = ["1.9\n", "2.1\n", "3\n"]
-        writeLines = ["1.9\n", "2.1\n", "3\n", "1.8\n"]
-        self.writeSpeedFile(sr, 1.8, mock_isFile, True, mock_open, mock_chmod,
-                            readLines=readLines, writeLines=writeLines)
+        write = "1.9\n2.1\n3\n1.8\n"
+        self.writeSpeedFile(mock_lock, mock_unlock, sr, 1.8, mock_isFile, True,
+                            mock_open, mock_atomicWrite, readLines=readLines,
+                            write=write)
 
         # File does exist and almost full
         readLines = ["2.0\n",
@@ -1045,19 +1071,11 @@ def test_writeSpeedToFile(self, mock_chmod, mock_isFile, mock_open):
                      "2.7\n",
                      "2.8\n"]
 
-        writeLines = ["2.0\n",
-                      "2.1\n",
-                      "2.2\n",
-                      "2.3\n",
-                      "2.4\n",
-                      "2.5\n",
-                      "2.6\n",
-                      "2.7\n",
-                      "2.8\n",
-                      "1.8\n"]
+        write = "2.0\n2.1\n2.2\n2.3\n2.4\n2.5\n2.6\n2.7\n2.8\n1.8\n"
 
-        self.writeSpeedFile(sr, 1.8, mock_isFile, True, mock_open, mock_chmod,
-                            readLines=readLines, writeLines=writeLines)
+        self.writeSpeedFile(mock_lock, mock_unlock, sr, 1.8, mock_isFile, True,
+                            mock_open, mock_atomicWrite, readLines=readLines,
+                            write=write)
 
         # File does exist and full
         readLines = ["2.0\n",
@@ -1072,20 +1090,11 @@ def test_writeSpeedToFile(self, mock_chmod, mock_isFile, mock_open):
                      "1.9\n",
                      "1.9\n"]
 
-        writeLines = ["1.9\n",
-                      "1.9\n",
-                      "1.9\n",
-                      "1.9\n",
-                      "1.9\n",
-                      "1.9\n",
-                      "1.9\n",
-                      "1.9\n",
-                      "1.9\n",
-                      "1.9\n",
-                      "1.8\n"]
-
-        self.writeSpeedFile(sr, 1.8, mock_isFile, True, mock_open, mock_chmod,
-                            readLines=readLines, writeLines=writeLines)
+        write = "1.9\n1.9\n1.9\n1.9\n1.9\n1.9\n1.9\n1.9\n1.9\n1.9\n1.8\n"
+
+        self.writeSpeedFile(mock_lock, mock_unlock, sr, 1.8, mock_isFile, True,
+                            mock_open, mock_atomicWrite, readLines=readLines,
+                            write=write)
 
     def canLiveCoalesce(self, vdi, size, config, speed, expectedRes):
         vdi.getSizeVHD = mock.MagicMock(return_value=size)
diff --git a/tests/test_utils.py b/tests/test_utils.py
index dd03ad4b..f2ff13f2 100644
--- a/tests/test_utils.py
+++ b/tests/test_utils.py
@@ -5,6 +5,8 @@
 import os
 import util
 import subprocess
+import tempfile
+import errno
 
 
 class fake_proc:
@@ -35,3 +37,58 @@ def test_env_concatenated(self, popen):
                                      close_fds=True, stdin=-1, stderr=-1,
                                      env={'hello': 'world', 'NewVar2': 'blah',
                                           'NewVar1': 'yadayada'}, stdout=-1)
+
+    @mock.patch("os.fsync", autospec=True)
+    @mock.patch("os.rename", autospec=True)
+    @mock.patch("os.path.isfile", autospec=True)
+    @mock.patch("os.remove", autospec=True)
+    @mock.patch("tempfile.mkstemp", autospec=True)
+    @mock.patch("util.SMlog", autospec=True)
+    def test_atomicFileWrite_normal(self, mock_log, mock_mtemp, mock_remove,
+                                    mock_isfile, mock_rename, mock_fsync):
+        opener_mock = mock.mock_open()
+
+        mock_isfile.return_value = False
+        mock_mtemp.return_value = ("im_ignored",
+                                   "/var/run/random_temp.txt")
+        with mock.patch('__builtin__.open', opener_mock, create=True) as m:
+
+            m.return_value.fileno.return_value = 123
+            util.atomicFileWrite("/var/run/test.txt", "var/run", "blah blah")
+
+            self.assertEqual(mock_mtemp.call_count, 1)
+            m.assert_called_with("/var/run/random_temp.txt", 'w')
+            m.return_value.write.assert_called_with("blah blah")
+            self.assertEqual(m.return_value.flush.call_count, 1)
+            mock_fsync.assert_called_with(123)
+            self.assertEqual(m.return_value.close.call_count, 1)
+            mock_rename.assert_called_with("/var/run/random_temp.txt",
+                                           "/var/run/test.txt")
+            mock_isfile.assert_called_with("/var/run/random_temp.txt")
+            self.assertEqual(mock_remove.call_count, 0)
+
+    @mock.patch("os.fsync", autospec=True)
+    @mock.patch("os.rename", autospec=True)
+    @mock.patch("os.path.isfile", autospec=True)
+    @mock.patch("os.remove", autospec=True)
+    @mock.patch("tempfile.mkstemp", autospec=True)
+    @mock.patch("util.SMlog", autospec=True)
+    def test_atomicFileWrite_exception(self, mock_log, mock_mtemp, mock_remove,
+                                       mock_isfile, mock_rename, mock_fsync):
+
+        opener_mock = mock.mock_open()
+
+        mock_isfile.return_value = True
+        mock_mtemp.return_value = ("im_ignored",
+                                   "/var/run/random_temp.txt")
+        with mock.patch('__builtin__.open', opener_mock, create=True) as m:
+            m.return_value.write.side_effect = OSError((errno.EPERM),
+                                                       'Not Allowed')
+            m.return_value.closed = False
+            # Assert is swallowed
+            util.atomicFileWrite("/var/run/test.txt", "var/run",
+                                 "blah blah")
+            expectedMsg = "FAILED to atomic write to /var/run/test.txt"
+            mock_log.assert_called_with(expectedMsg)
+            mock_remove.assert_called_with("/var/run/random_temp.txt")
+            self.assertEqual(opener_mock.return_value.close.call_count, 1)
