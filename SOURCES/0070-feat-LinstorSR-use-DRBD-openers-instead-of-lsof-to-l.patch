From 18ac9ddc0672f43c3139baa13a4f761b7876589c Mon Sep 17 00:00:00 2001
From: Ronan Abhamon <ronan.abhamon@vates.fr>
Date: Tue, 9 Aug 2022 11:07:57 +0200
Subject: [PATCH 070/178] feat(LinstorSR): use DRBD openers instead of lsof to
 log in blktap2

Signed-off-by: Ronan Abhamon <ronan.abhamon@vates.fr>
---
 drivers/blktap2.py              |   4 +-
 drivers/linstor-manager         |  48 +--------
 drivers/linstorvolumemanager.py | 176 +++++++++++++++++---------------
 3 files changed, 100 insertions(+), 128 deletions(-)

diff --git a/drivers/blktap2.py b/drivers/blktap2.py
index 14c564e..370f7fb 100755
--- a/drivers/blktap2.py
+++ b/drivers/blktap2.py
@@ -36,7 +36,7 @@ import json
 import xs_errors
 import XenAPI
 import scsiutil
-from linstorvolumemanager import log_lsof_drbd
+from linstorvolumemanager import log_drbd_openers
 from syslog import openlog, syslog
 from stat import * # S_ISBLK(), ...
 import nfs
@@ -833,7 +833,7 @@ class Tapdisk(object):
                                     time.sleep(1)
                                     continue
                                 if err == errno.EROFS:
-                                    log_lsof_drbd(path)
+                                    log_drbd_openers(path)
                             raise
                     try:
                         tapdisk = cls.__from_blktap(blktap)
diff --git a/drivers/linstor-manager b/drivers/linstor-manager
index 9022499..4d0ba29 100755
--- a/drivers/linstor-manager
+++ b/drivers/linstor-manager
@@ -27,7 +27,7 @@ import XenAPI
 import XenAPIPlugin
 
 from linstorjournaler import LinstorJournaler
-from linstorvolumemanager import get_controller_uri, LinstorVolumeManager
+from linstorvolumemanager import get_controller_uri, get_local_volume_openers, LinstorVolumeManager
 from lock import Lock
 import json
 import LinstorSR
@@ -445,22 +445,6 @@ def lock_vdi(session, args):
     return str(False)
 
 
-def lsof_resource(session, args):
-    try:
-        drbd_path = args['drbdPath']
-        (ret, stdout, stderr) = util.doexec(['lsof', '-V', drbd_path])
-        if ret == 0:
-            return 'DRBD resource `{}` is open: {}'.format(
-                drbd_path, stdout.rstrip()
-            )
-        return '`lsof` on DRBD resource `{}` returned {}: {}'.format(
-            drbd_path, ret, stdout.rstrip()
-        )
-    except Exception as e:
-        util.SMlog('linstor-manager:lsof_drbd error: {}'.format(e))
-        raise
-
-
 def has_controller_running(session, args):
     (ret, stdout, stderr) = util.doexec([
         'systemctl', 'is-active', '--quiet', 'linstor-controller'
@@ -827,34 +811,7 @@ def get_drbd_openers(session, args):
     try:
         resource_name = args.get('resourceName')
         volume = args.get('volume')
-        if not resource_name or volume is None:
-            raise Exception('Cannot get DRBD openers without resource name and/or volume.')
-
-        path = '/sys/kernel/debug/drbd/resources/{}/volumes/{}/openers'.format(
-            resource_name, volume
-        )
-
-        with open(path, 'r') as openers:
-            # Not a big cost, so read all lines directly.
-            lines = openers.readlines()
-
-        result = {}
-
-        opener_re = re.compile('(.*)\\s+([0-9]+)\\s+([0-9]+)')
-        for line in lines:
-            match = opener_re.match(line)
-            assert match
-
-            groups = match.groups()
-            process_name = groups[0]
-            pid = groups[1]
-            open_duration_ms = groups[2]
-            result[pid] = {
-                'process-name': process_name,
-                'open-duration': open_duration_ms
-            }
-
-        return json.dumps(result)
+        return get_local_volume_openers(resource_name, volume)
     except Exception as e:
         util.SMlog('linstor-manager:get_drbd_openers error: {}'.format(e))
         raise
@@ -886,7 +843,6 @@ if __name__ == '__main__':
         'getBlockBitmap': get_block_bitmap,
 
         'lockVdi': lock_vdi,
-        'lsofResource': lsof_resource,
         'hasControllerRunning': has_controller_running,
         'addHost': add_host,
         'removeHost': remove_host,
diff --git a/drivers/linstorvolumemanager.py b/drivers/linstorvolumemanager.py
index 3806cc9..6f4c590 100755
--- a/drivers/linstorvolumemanager.py
+++ b/drivers/linstorvolumemanager.py
@@ -45,81 +45,56 @@ DRBD_BY_RES_PATH = '/dev/drbd/by-res/'
 PLUGIN = 'linstor-manager'
 
 
-# Check if a path is a DRBD resource and log the process name/pid
-# that opened it.
-def log_lsof_drbd(path):
-    PLUGIN_CMD = 'lsofResource'
+# ==============================================================================
 
-    # Ignore if it's not a symlink to DRBD resource.
-    if not path.startswith(DRBD_BY_RES_PATH):
-        return
+def get_local_volume_openers(resource_name, volume):
+    if not resource_name or volume is None:
+        raise Exception('Cannot get DRBD openers without resource name and/or volume.')
 
-    # Compute resource name.
-    res_name_end = path.find('/', len(DRBD_BY_RES_PATH))
-    if res_name_end == -1:
-        return
-    res_name = path[len(DRBD_BY_RES_PATH):res_name_end]
+    path = '/sys/kernel/debug/drbd/resources/{}/volumes/{}/openers'.format(
+        resource_name, volume
+    )
 
-    try:
-        # Ensure path is a DRBD.
-        drbd_path = os.path.realpath(path)
-        stats = os.stat(drbd_path)
-        if not stat.S_ISBLK(stats.st_mode) or os.major(stats.st_rdev) != 147:
-            return
+    with open(path, 'r') as openers:
+        # Not a big cost, so read all lines directly.
+        lines = openers.readlines()
 
-        # Find where the device is open.
-        (ret, stdout, stderr) = util.doexec(['drbdadm', 'status', res_name])
-        if ret != 0:
-            util.SMlog('Failed to execute `drbdadm status` on `{}`: {}'.format(
-                res_name, stderr
-            ))
-            return
+    result = {}
 
-        # Is it a local device?
-        if stdout.startswith('{} role:Primary'.format(res_name)):
-            (ret, stdout, stderr) = util.doexec(['lsof', drbd_path])
-            if ret == 0:
-                util.SMlog(
-                    'DRBD resource `{}` is open on local host: {}'
-                    .format(path, stdout)
-                )
-            else:
-                util.SMlog(
-                    '`lsof` on local DRBD resource `{}` returned {}: {}'
-                    .format(path, ret, stderr)
-                )
-            return
+    opener_re = re.compile('(.*)\\s+([0-9]+)\\s+([0-9]+)')
+    for line in lines:
+        match = opener_re.match(line)
+        assert match
 
-        # Is it a remote device?
-        res = REG_DRBDADM_PRIMARY.search(stdout)
-        if not res:
-            util.SMlog(
-                'Cannot find where is open DRBD resource `{}`'
-                .format(path)
-            )
-            return
-        node_name = res.groups()[0]
+        groups = match.groups()
+        process_name = groups[0]
+        pid = groups[1]
+        open_duration_ms = groups[2]
+        result[pid] = {
+            'process-name': process_name,
+            'open-duration': open_duration_ms
+        }
 
-        session = util.get_localAPI_session()
-        hosts = session.xenapi.host.get_all_records()
-        for host_ref, host_record in hosts.items():
-            if node_name != host_record['hostname']:
-                continue
+    return json.dumps(result)
 
-            ret = session.xenapi.host.call_plugin(
-                host_ref, PLUGIN, PLUGIN_CMD, {'drbdPath': drbd_path},
-            )
-            util.SMlog('DRBD resource `{}` status on host `{}`: {}'.format(
-                path, host_ref, ret
-            ))
-            return
-        util.SMlog('Cannot find primary host of DRBD resource {}'.format(path))
-    except Exception as e:
-        util.SMlog(
-            'Got exception while trying to determine where DRBD resource ' +
-            '`{}` is open: {}'.format(path, e)
+def get_all_volume_openers(resource_name, volume):
+    PLUGIN_CMD = 'getDrbdOpeners'
+
+    volume = str(volume)
+    openers = {}
+
+    session = util.get_localAPI_session()
+    hosts = session.xenapi.host.get_all_records()
+    for host_ref, host_record in hosts.items():
+        openers[host_record['hostname']] = json.loads(
+            session.xenapi.host.call_plugin(host_ref, PLUGIN, PLUGIN_CMD, {
+                'resourceName': resource_name,
+                'volume': volume
+            })
         )
 
+    return openers
+
 
 # ==============================================================================
 
@@ -1042,22 +1017,8 @@ class LinstorVolumeManager(object):
         :return: A dictionnary that contains openers.
         :rtype: dict(str, obj)
         """
+        return get_all_volume_openers(self.get_volume_name(volume_uuid), '0')
 
-        PLUGIN_CMD = 'getDrbdOpeners'
-
-        openers = {}
-
-        session = util.get_localAPI_session()
-        hosts = session.xenapi.host.get_all_records()
-        for host_ref, host_record in hosts.items():
-            openers[host_record['hostname']] = json.loads(
-                session.xenapi.host.call_plugin(host_ref, PLUGIN, PLUGIN_CMD, {
-                    'resourceName': self.get_volume_name(volume_uuid),
-                    'volume': '0'
-                })
-            )
-
-        return openers
 
     def get_volumes_with_name(self):
         """
@@ -2755,3 +2716,58 @@ class LinstorVolumeManager(object):
                     'Failed to umount volume {} on {}: {}'
                     .format(volume_path, mountpoint, e)
                 )
+
+
+# ==============================================================================
+
+# Check if a path is a DRBD resource and log the process name/pid
+# that opened it.
+def log_drbd_openers(path):
+    # Ignore if it's not a symlink to DRBD resource.
+    if not path.startswith(DRBD_BY_RES_PATH):
+        return
+
+    # Compute resource name.
+    res_name_end = path.find('/', len(DRBD_BY_RES_PATH))
+    if res_name_end == -1:
+        return
+    res_name = path[len(DRBD_BY_RES_PATH):res_name_end]
+
+    volume_end = path.rfind('/')
+    if volume_end == res_name_end:
+        return
+    volume = path[volume_end + 1:]
+
+    try:
+        # Ensure path is a DRBD.
+        drbd_path = os.path.realpath(path)
+        stats = os.stat(drbd_path)
+        if not stat.S_ISBLK(stats.st_mode) or os.major(stats.st_rdev) != 147:
+            return
+
+        # Find where the device is open.
+        (ret, stdout, stderr) = util.doexec(['drbdadm', 'status', res_name])
+        if ret != 0:
+            util.SMlog('Failed to execute `drbdadm status` on `{}`: {}'.format(
+                res_name, stderr
+            ))
+            return
+
+        # Is it a local device?
+        if stdout.startswith('{} role:Primary'.format(res_name)):
+            util.SMlog(
+                'DRBD resource `{}` is open on local host: {}'
+                .format(path, get_local_volume_openers(res_name, volume))
+            )
+            return
+
+        # Is it a remote device?
+        util.SMlog(
+            'DRBD resource `{}` is open on hosts: {}'
+            .format(path, get_all_volume_openers(res_name, volume))
+        )
+    except Exception as e:
+        util.SMlog(
+            'Got exception while trying to determine where DRBD resource ' +
+            '`{}` is open: {}'.format(path, e)
+        )
-- 
2.45.2

