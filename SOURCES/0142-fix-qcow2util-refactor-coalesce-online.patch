From 31be6a78b01bceeeabc160827075f4f5ec35841b Mon Sep 17 00:00:00 2001
From: Damien Thenot <damien.thenot@vates.tech>
Date: Mon, 30 Jun 2025 16:34:51 +0200
Subject: [PATCH] fix(qcow2util): refactor coalesce online

Use a unique function to obtain Tapdisk PID and minor for both
coalesceOnline and cancelCoalesceOnline

Signed-off-by: Damien Thenot <damien.thenot@vates.tech>
---
 drivers/qcow2util.py | 80 +++++++++++++++++++++++---------------------
 1 file changed, 42 insertions(+), 38 deletions(-)

diff --git a/drivers/qcow2util.py b/drivers/qcow2util.py
index 09e349fc..7f097765 100644
--- a/drivers/qcow2util.py
+++ b/drivers/qcow2util.py
@@ -1,4 +1,4 @@
-from sm_typing import Any, Callable, cast, Dict, Final, List, Optional, override
+from sm_typing import Any, Callable, Dict, Final, List, Optional, Tuple, cast, override
 from typing import BinaryIO
 
 import errno
@@ -716,51 +716,55 @@ class QCowUtil(CowUtil):
         self._read_qcow2(path)
         return zlib.compress(self._create_bitmap())
 
-    @override
-    def coalesceOnline(self, path: str) -> int:
-        pid_openers = util.get_openers_pid(path) # TODO: need to check other hosts and call tap-ctl on the host where it runs
+    def _getTapdisk(self, path: str) -> Tuple[int, int]:
+        """
+        Return a tuple of (PID, Minor) for the given path
+        """
+        pid_openers = util.get_openers_pid(path)
         if pid_openers:
             if len(pid_openers) > 1:
-                raise xs_errors.XenError("Multiple openers for {}".format(path)) # TODO: There might be multiple PID? Yes, we can have the chain enabled for multiple leaf (i.e. after a clone)
+                raise xs_errors.XenError("Multiple openers for {}".format(path)) # TODO: There might be multiple PID? Yes, we can have the chain enabled for multiple leaf (i.e. after a clone), taken into account in cleanup.py
             pid = pid_openers[0]
-            l = TapCtl.list(pid=pid)
-            if len(l) > 1: #TODO: There might more than one minor for this blktap?
+            tapdiskList = TapCtl.list(pid=pid)
+            if len(tapdiskList) > 1: #TODO: There might more than one minor for this blktap?
                 raise xs_errors.XenError("TapdiskAlreadyRunning", "There is multiple minor for this tapdisk process")
-            minor = l[0]["minor"]
-            TapCtl.commit(pid, minor, QCOW2_TYPE, path) #TODO: Handle commit call failing, it's needed if the tapdisk hasn't started yet or crashed
-            #We need to wait for query to return concluded
-            #TODO: We are technically ininterruptible since being interrupted will only stop checking if the job is done
-            # We should call `tap-ctl cancel` if we are interrupted
-            try:
+            minor = tapdiskList[0]["minor"]
+            return (pid, minor)
+        raise xs_errors.XenError("TapdiskFailed", "No tapdisk process found for {}".format(path))
+
+    @override
+    def coalesceOnline(self, path: str) -> int:
+        pid, minor = self._getTapdisk(path)
+
+        try:
+            TapCtl.commit(pid, minor, QCOW2_TYPE, path)
+            # We need to wait for query to return concluded
+            # We are technically ininterruptible since being interrupted will only stop checking if the job is done.
+            # We need to call `tap-ctl cancel` if we are interrupted, it is done in cleanup.py code.
+
+            status, nb, _ = TapCtl.query(pid, minor)
+            if status == "undefined":
+                util.SMlog("Tapdisk {} (m: {}) coalesce status undefined for {}".format(pid, minor, path))
+                return 0
+
+            while status !=  "concluded":
+                time.sleep(1)
                 status, nb, _ = TapCtl.query(pid, minor)
-                if status == "undefined":
-                    util.SMlog("Tapdisk {} (m: {}) coalesce status undefined for {}".format(pid, minor, path))
-                    return 0
-                while status !=  "concluded":
-                    time.sleep(1)
-                    status, nb, _ = TapCtl.query(pid, minor)
-                    util.SMlog("Got status {} for tapdisk {} (m: {})".format(status, pid, minor))
-                return nb
-            except TapCtl.CommandFailure as e:
-                util.SMlog("Query command failed on tapdisk instance {}. Raising...".format(pid))
-                raise
+                util.SMlog("Got status {} for tapdisk {} (m: {})".format(status, pid, minor))#TODO: this log and the one from the call to query are spamming SMlog
+            return nb
+        except TapCtl.CommandFailure:
+            util.SMlog("Query command failed on tapdisk instance {}. Raising...".format(pid))
+            raise
 
     @override
     def cancelCoalesceOnline(self, path: str) -> None:
-        pid_openers = util.get_openers_pid(path) # TODO: need to check other hosts and call tap-ctl on the host where it runs
-        if pid_openers:
-            if len(pid_openers) > 1:
-                raise xs_errors.XenError("Multiple openers for {}".format(path)) # TODO: There might be multiple PID? Yes, we can have the chain enabled for multiple leaf (i.e. after a clone)
-            pid = pid_openers[0]
-            l = TapCtl.list(pid=pid)
-            if len(l) > 1: #TODO: There might more than one minor for this blktap?
-                raise xs_errors.XenError("TapdiskAlreadyRunning", "There is multiple minor for this tapdisk process")
-            minor = l[0]["minor"]
-            try:
-                TapCtl.cancel_commit(pid, minor)
-            except TapCtl.CommandFailure as e:
-                util.SMlog("Cancel command failed on tapdisk instance {}. Raising...".format(pid))
-                raise
+        pid, minor = self._getTapdisk(path)
+
+        try:
+            TapCtl.cancel_commit(pid, minor)
+        except TapCtl.CommandFailure:
+            util.SMlog("Cancel command failed on tapdisk instance {}. Raising...".format(pid))
+            raise
 
     @override
     def coalesce(self, path: str) -> int:
