From e7ab23d5d93347949cad128e4a800aee278ceb5d Mon Sep 17 00:00:00 2001
From: Damien Thenot <damien.thenot@vates.tech>
Date: Mon, 11 Aug 2025 13:56:46 +0200
Subject: [PATCH] fix(cleanup): remove running file before relink

Sometime, the VDI activation code in blktap2.py would wait on coalesce
being stopped while the GC code would be waiting for the activation
being done to continue with the relink, causing a deadlock.
We remove the coalesce running file before the relink so that it
continue as before, the activation will proceed then the relink will
run and refresh the tapdisk with the new parent.
We let the relink run everytime, it should be almost a noop if tapdisk
has made the parent change itself.

Signed-off-by: Damien Thenot <damien.thenot@vates.tech>
---
 drivers/cleanup.py | 33 +++++++++++++--------------------
 1 file changed, 13 insertions(+), 20 deletions(-)

diff --git a/drivers/cleanup.py b/drivers/cleanup.py
index 1970ad7a..1f29d693 100755
--- a/drivers/cleanup.py
+++ b/drivers/cleanup.py
@@ -2480,7 +2480,6 @@ class SR(object):
         os.unlink(self._gc_running_file(vdi))
 
     def _coalesce(self, vdi: VDI):
-        skipRelink = False
         if self.journaler.get(vdi.JRN_RELINK, vdi.uuid):
             # this means we had done the actual coalescing already and just
             # need to finish relinking and/or refreshing the children
@@ -2508,7 +2507,6 @@ class SR(object):
                     #Leaf opened on another host, we need to call online coalesce
                     util.SMlog("Remote coalesce for {}".format(vdi.path))
                     vdi._doCoalesceOnHost(list(host_refs)[0])
-                    skipRelink = True
                 else:
                     util.SMlog("Offline coalesce for {}".format(vdi.path))
                     vdi._doCoalesce()
@@ -2516,11 +2514,9 @@ class SR(object):
                 util.SMlog("EXCEPTION while coalescing: {}".format(e))
                 self._delete_running_file(vdi)
                 raise
-            """
-            vdi._doCoalesce will call vdi._coalesceCowImage (after doing other things).
-            It will then call VDI._doCoalesceCowImage in a runAbortable context
-            """
+
             self.journaler.remove(vdi.JRN_COALESCE, vdi.uuid)
+            self._delete_running_file(vdi)
 
             util.fistpoint.activate("LVHDRT_before_create_relink_journal", self.uuid)
 
@@ -2528,22 +2524,19 @@ class SR(object):
             # like SM.clone from manipulating the VDIs we'll be relinking and
             # rescan the SR first in case the children changed since the last
             # scan
-            if not skipRelink:
-                self.journaler.create(vdi.JRN_RELINK, vdi.uuid, "1")
+            self.journaler.create(vdi.JRN_RELINK, vdi.uuid, "1")
 
-        if not skipRelink: #TODO: we might want to let relink happen for VDI not currently in use
-            self.lock()
-            try:
-                vdi.parent._tagChildrenForRelink()
-                self.scan()
-                vdi._relinkSkip()
-            finally:
-                self.unlock()
-                # Reload the children to leave things consistent
-                vdi.parent._reloadChildren(vdi)
-            self.journaler.remove(vdi.JRN_RELINK, vdi.uuid)
+        self.lock()
+        try:
+            vdi.parent._tagChildrenForRelink()
+            self.scan()
+            vdi._relinkSkip() #TODO: We could check if the parent is already the right one before doing the relink, or we could do the relink a second time, it doesn't seem to cause issues
+        finally:
+            self.unlock()
+            # Reload the children to leave things consistent
+            vdi.parent._reloadChildren(vdi)
+        self.journaler.remove(vdi.JRN_RELINK, vdi.uuid)
 
-        self._delete_running_file(vdi)
         self.deleteVDI(vdi)
 
     class CoalesceTracker:
