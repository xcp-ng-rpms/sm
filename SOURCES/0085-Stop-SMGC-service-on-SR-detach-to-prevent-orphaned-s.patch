From aa95fd6b618971113757544d1b31e6b4c0023484 Mon Sep 17 00:00:00 2001
From: Millefeuille <mathieu.labourier@vates.tech>
Date: Mon, 6 Oct 2025 10:12:31 +0200
Subject: [PATCH] Stop SMGC service on SR detach to prevent orphaned systemd
 units (#92)

This is not done on every and each implementation of SR but only on ones that calls cleanup.start_gc_service (like FileSR)
and on the classes that inherits from them and don't call super on detach.

This is to prevent useless errors logs like Failed to stop xxx.service: Unit xxx.service not loaded.

Signed-off-by: Mathieu Labourier <mathieu.labourier@vates.tech>
---
 drivers/cleanup.py    | 30 ++++++++++++++++++++++++------
 tests/test_cleanup.py |  3 +--
 2 files changed, 25 insertions(+), 8 deletions(-)

diff --git a/drivers/cleanup.py b/drivers/cleanup.py
index 51d51e8d..0f9095f4 100755
--- a/drivers/cleanup.py
+++ b/drivers/cleanup.py
@@ -3967,6 +3967,7 @@ def abort(srUuid, soft=False):
     """Abort GC/coalesce if we are currently GC'ing or coalescing a VDI pair.
     """
     if _abort(srUuid, soft):
+        stop_gc_service(srUuid)
         Util.log("abort: releasing the process lock")
         lockGCActive.release()
         return True
@@ -4047,6 +4048,18 @@ def start_gc(session, sr_uuid):
     subprocess.run([__file__, '-b', '-u', sr_uuid, '-g'],
                    stdout=subprocess.PIPE, stderr=subprocess.PIPE, close_fds=True)
 
+def _gc_service_cmd(sr_uuid, action, extra_args=None):
+    """
+    Build and run the systemctl command for the GC service using util.doexec.
+    """
+    sr_uuid_esc = sr_uuid.replace("-", "\\x2d")
+    cmd=["/usr/bin/systemctl", "--quiet"]
+    if extra_args:
+        cmd.extend(extra_args)
+    cmd += [action, f"SMGC@{sr_uuid_esc}"]
+    return util.doexec(cmd)
+
+
 def start_gc_service(sr_uuid, wait=False):
     """
     This starts the templated systemd service which runs GC on the given SR UUID.
@@ -4057,13 +4070,18 @@ def start_gc_service(sr_uuid, wait=False):
     run has finished. This is used to force a run of the GC instead of just kicking it
     in the background.
     """
-    sr_uuid_esc = sr_uuid.replace("-", "\\x2d")
     util.SMlog(f"Kicking SMGC@{sr_uuid}...")
-    cmd=[ "/usr/bin/systemctl", "--quiet" ]
-    if not wait:
-        cmd.append("--no-block")
-    cmd += ["start", f"SMGC@{sr_uuid_esc}"]
-    subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, close_fds=True)
+    _gc_service_cmd(sr_uuid, "start", extra_args=None if wait else ["--no-block"])
+
+
+def stop_gc_service(sr_uuid):
+    """
+    Stops the templated systemd service which runs GC on the given SR UUID.
+    """
+    util.SMlog(f"Stopping SMGC@{sr_uuid}...")
+    (rc, _stdout, stderr) = _gc_service_cmd(sr_uuid, "stop")
+    if rc != 0:
+        util.SMlog(f"Failed to stop gc service `SMGC@{sr_uuid}`: `{stderr}`")
 
 
 def wait_for_completion(sr_uuid):
diff --git a/tests/test_cleanup.py b/tests/test_cleanup.py
index c9749e78..2b702eab 100644
--- a/tests/test_cleanup.py
+++ b/tests/test_cleanup.py
@@ -409,8 +409,7 @@ class TestSR(unittest.TestCase):
         cleanup.lockGCActive = TestRelease()
         cleanup.lockGCActive.release = mock.Mock(return_value=None)
 
-        ret = cleanup.abort(mock_sr, False)
-
+        ret = cleanup.abort(str(mock_sr.uuid), False)
         # Pass on the return from _abort.
         self.assertEqual(True, ret)
 
