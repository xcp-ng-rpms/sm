From f54ac1cef57268f0f7494af54fd4008a9aa67481 Mon Sep 17 00:00:00 2001
From: Ronan Abhamon <ronan.abhamon@vates.fr>
Date: Fri, 26 Mar 2021 16:13:20 +0100
Subject: [PATCH 041/179] feat(LinstorSR): add a helper `log_drbd_erofs` to
 trace EROFS errno code with DRBD resources + check EROFS error

Signed-off-by: Ronan Abhamon <ronan.abhamon@vates.fr>
---
 drivers/blktap2.py              | 19 +++++++-
 drivers/linstor-manager         | 19 +++++++-
 drivers/linstorvolumemanager.py | 83 ++++++++++++++++++++++++++++++++-
 drivers/vhdutil.py              |  2 +-
 4 files changed, 119 insertions(+), 4 deletions(-)

diff --git a/drivers/blktap2.py b/drivers/blktap2.py
index e9305ce..14c564e 100755
--- a/drivers/blktap2.py
+++ b/drivers/blktap2.py
@@ -36,6 +36,7 @@ import json
 import xs_errors
 import XenAPI
 import scsiutil
+from linstorvolumemanager import log_lsof_drbd
 from syslog import openlog, syslog
 from stat import * # S_ISBLK(), ...
 import nfs
@@ -817,7 +818,23 @@ class Tapdisk(object):
                 TapCtl.attach(pid, minor)
 
                 try:
-                    TapCtl.open(pid, minor, _type, path, options)
+                    retry_open = 0
+                    while True:
+                        try:
+                            TapCtl.open(pid, minor, _type, path, options)
+                            break
+                        except TapCtl.CommandFailure as e:
+                            err = (
+                                'status' in e.info and e.info['status']
+                            ) or None
+                            if err in (errno.EIO, errno.EROFS, errno.EAGAIN):
+                                if retry_open < 5:
+                                    retry_open += 1
+                                    time.sleep(1)
+                                    continue
+                                if err == errno.EROFS:
+                                    log_lsof_drbd(path)
+                            raise
                     try:
                         tapdisk = cls.__from_blktap(blktap)
                         node = '/sys/dev/block/%d:%d' % (tapdisk.major(), tapdisk.minor)
diff --git a/drivers/linstor-manager b/drivers/linstor-manager
index f82b73f..a06ed20 100755
--- a/drivers/linstor-manager
+++ b/drivers/linstor-manager
@@ -327,6 +327,22 @@ def lock_vdi(session, args):
     return str(False)
 
 
+def lsof_resource(session, args):
+    try:
+        drbd_path = args['drbdPath']
+        (ret, stdout, stderr) = util.doexec(['lsof', drbd_path])
+        if ret == 0:
+            return 'DRBD resource `{}` is open: {}'.format(
+                drbd_path, stdout
+            )
+        return '`lsof` on DRBD resource `{}` returned {}: {}'.format(
+            drbd_path, ret, stderr
+        )
+    except Exception as e:
+        util.SMlog('linstor-manager:lsof_drbd error: {}'.format(e))
+        raise
+
+
 if __name__ == '__main__':
     XenAPIPlugin.dispatch({
         'prepareSr': prepare_sr,
@@ -344,5 +360,6 @@ if __name__ == '__main__':
         'getDepth': get_depth,
         'getKeyHash': get_key_hash,
         'getBlockBitmap': get_block_bitmap,
-        'lockVdi': lock_vdi
+        'lockVdi': lock_vdi,
+        'lsofResource': lsof_resource
     })
diff --git a/drivers/linstorvolumemanager.py b/drivers/linstorvolumemanager.py
index 5c04d02..0357b92 100755
--- a/drivers/linstorvolumemanager.py
+++ b/drivers/linstorvolumemanager.py
@@ -16,6 +16,7 @@
 #
 
 
+import errno
 import glob
 import json
 import linstor
@@ -23,6 +24,7 @@ import os.path
 import re
 import shutil
 import socket
+import stat
 import time
 import util
 import uuid
@@ -37,6 +39,85 @@ DATABASE_MKFS = 'mkfs.ext4'
 REG_DRBDADM_PRIMARY = re.compile("([^\\s]+)\\s+role:Primary")
 REG_DRBDSETUP_IP = re.compile('[^\\s]+\\s+(.*):.*$')
 
+DRBD_BY_RES_PATH = '/dev/drbd/by-res/'
+
+
+# Check if a path is a DRBD resource and log the process name/pid
+# that opened it.
+def log_lsof_drbd(path):
+    PLUGIN = 'linstor-manager'
+    PLUGIN_CMD = 'lsofResource'
+
+    # Ignore if it's not a symlink to DRBD resource.
+    if not path.startswith(DRBD_BY_RES_PATH):
+        return
+
+    # Compute resource name.
+    res_name_end = path.find('/', len(DRBD_BY_RES_PATH))
+    if res_name_end == -1:
+        return
+    res_name = path[len(DRBD_BY_RES_PATH):res_name_end]
+
+    try:
+        # Ensure path is a DRBD.
+        drbd_path = os.path.realpath(path)
+        stats = os.stat(drbd_path)
+        if not stat.S_ISBLK(stats.st_mode) or os.major(stats.st_rdev) != 147:
+            return
+
+        # Find where the device is open.
+        (ret, stdout, stderr) = util.doexec(['drbdadm', 'status', res_name])
+        if ret != 0:
+            util.SMlog('Failed to execute `drbdadm status` on `{}`: {}'.format(
+                res_name, stderr
+            ))
+            return
+
+        # Is it a local device?
+        if stdout.startswith('{} role:Primary'.format(res_name)):
+            (ret, stdout, stderr) = util.doexec(['lsof', drbd_path])
+            if ret == 0:
+                util.SMlog(
+                    'DRBD resource `{}` is open on local host: {}'
+                    .format(path, stdout)
+                )
+            else:
+                util.SMlog(
+                    '`lsof` on local DRBD resource `{}` returned {}: {}'
+                    .format(path, ret, stderr)
+                )
+            return
+
+        # Is it a remote device?
+        res = REG_DRBDADM_PRIMARY.search(stdout)
+        if not res:
+            util.SMlog(
+                'Cannot find where is open DRBD resource `{}`'
+                .format(path)
+            )
+            return
+        node_name = res.groups()[0]
+
+        session = util.get_localAPI_session()
+        hosts = session.xenapi.host.get_all_records()
+        for host_ref, host_record in hosts.items():
+            if node_name != host_record['hostname']:
+                continue
+
+            ret = session.xenapi.host.call_plugin(
+                host_ref, PLUGIN, PLUGIN_CMD, {'drbdPath': drbd_path},
+            )
+            util.SMlog('DRBD resource `{}` status on host `{}`: {}'.format(
+                path, host_ref, ret
+            ))
+            return
+        util.SMlog('Cannot find primary host of DRBD resource {}'.format(path))
+    except Exception as e:
+        util.SMlog(
+            'Got exception while trying to determine where DRBD resource ' +
+            '`{}` is open: {}'.format(path, e)
+        )
+
 
 # ==============================================================================
 
@@ -162,7 +243,7 @@ class LinstorVolumeManager(object):
         '_kv_cache_dirty', '_resource_cache_dirty', '_volume_info_cache_dirty'
     )
 
-    DEV_ROOT_PATH = '/dev/drbd/by-res/'
+    DEV_ROOT_PATH = DRBD_BY_RES_PATH
 
     # Default LVM extent size.
     BLOCK_SIZE = 4 * 1024 * 1024
diff --git a/drivers/vhdutil.py b/drivers/vhdutil.py
index 422834e..0a8fe91 100755
--- a/drivers/vhdutil.py
+++ b/drivers/vhdutil.py
@@ -99,7 +99,7 @@ def fullSizeVHD(virtual_size):
 
 def ioretry(cmd):
     return util.ioretry(lambda: util.pread2(cmd),
-            errlist = [errno.EIO, errno.EAGAIN])
+            errlist = [errno.EIO, errno.EROFS, errno.EAGAIN])
 
 def getVHDInfo(path, extractUuidFunction, includeParent = True):
     """Get the VHD info. The parent info may optionally be omitted: vhd-util
-- 
2.46.0

