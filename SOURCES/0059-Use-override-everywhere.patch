From e4f2b5b8a7f8ad0c5642a78c6992e2685fb49e26 Mon Sep 17 00:00:00 2001
From: Ronan Abhamon <ronan.abhamon@vates.fr>
Date: Fri, 8 Nov 2024 13:44:57 +0100
Subject: [PATCH 59/60] Use `override` everywhere!

Also use return type annotations on these methods.

Signed-off-by: Ronan Abhamon <ronan.abhamon@vates.fr>
---
 .mypy.ini                       |   3 +
 drivers/BaseISCSI.py            |  42 +++--
 drivers/CephFSSR.py             |  43 +++--
 drivers/DummySR.py              |  72 ++++---
 drivers/EXTSR.py                |  32 +++-
 drivers/FileSR.py               | 102 ++++++----
 drivers/GlusterFSSR.py          |  43 +++--
 drivers/HBASR.py                |  36 ++--
 drivers/ISOSR.py                |  56 ++++--
 drivers/LUNperVDI.py            |  20 +-
 drivers/LVHDSR.py               |  95 ++++++----
 drivers/LVHDoFCoESR.py          |  14 +-
 drivers/LVHDoHBASR.py           |  38 ++--
 drivers/LVHDoISCSISR.py         |  41 ++--
 drivers/LargeBlockSR.py         |  23 ++-
 drivers/LinstorSR.py            |  76 +++++---
 drivers/MooseFSSR.py            |  43 +++--
 drivers/NFSSR.py                |  40 ++--
 drivers/RawISCSISR.py           |  20 +-
 drivers/SHMSR.py                |  42 +++--
 drivers/SMBSR.py                |  41 ++--
 drivers/SR.py                   |  37 ++--
 drivers/VDI.py                  |  54 +++---
 drivers/XFSSR.py                |  32 +++-
 drivers/ZFSSR.py                |  32 +++-
 drivers/blktap2.py              | 129 ++++++++-----
 drivers/cleanup.py              | 320 ++++++++++++++++++++------------
 drivers/flock.py                |   5 +-
 drivers/lcache.py               |  14 +-
 drivers/linstorvhdutil.py       |   5 +-
 drivers/linstorvolumemanager.py |   4 +-
 drivers/lock.py                 |   2 +-
 drivers/mpath_cli.py            |   5 +-
 drivers/nfs-on-slave            |   6 +-
 drivers/srmetadata.py           |  22 ++-
 drivers/udevSR.py               |  53 ++++--
 misc/fairlock/fairlock.py       |   7 +-
 sm_typing/__init__.py           |  12 ++
 stubs/XenAPIPlugin.pyi          |   2 +-
 tests/lvmlib.py                 |   8 +-
 tests/shared_iscsi_test_base.py |  11 +-
 tests/test_BaseISCSI.py         |   5 +-
 tests/test_FileSR.py            |  28 ++-
 tests/test_ISCSISR.py           |  21 ++-
 tests/test_LVHDSR.py            |  16 +-
 tests/test_LVHDoHBASR.py        |   6 +-
 tests/test_LVHDoISCSISR.py      |  10 +-
 tests/test_SMBSR.py             |   8 +-
 tests/test_SR.py                |   8 +-
 tests/test_blktap2.py           |  12 +-
 tests/test_cbt.py               |  43 +++--
 tests/test_cleanup.py           |  11 +-
 tests/test_fairlock.py          |   5 +-
 tests/test_fjournaler.py        |   8 +-
 tests/test_keymanagerutil.py    |   9 +-
 tests/test_lock.py              |   9 +-
 tests/test_lock_queue.py        |   5 +-
 tests/test_lvutil.py            |  15 +-
 tests/test_mpath_dmp.py         |   6 +-
 tests/test_on_slave.py          |  11 +-
 tests/test_sr_health_check.py   |   6 +-
 tests/test_srmetadata.py        |  11 +-
 tests/test_storage_init.py      |  14 +-
 tests/test_util.py              |  16 +-
 tests/testlib.py                |  13 +-
 65 files changed, 1296 insertions(+), 682 deletions(-)
 create mode 100644 .mypy.ini

diff --git a/.mypy.ini b/.mypy.ini
new file mode 100644
index 00000000..651016c0
--- /dev/null
+++ b/.mypy.ini
@@ -0,0 +1,3 @@
+[mypy]
+enable_error_code = explicit-override
+
diff --git a/drivers/BaseISCSI.py b/drivers/BaseISCSI.py
index 077fa91c..34ce5f5e 100755
--- a/drivers/BaseISCSI.py
+++ b/drivers/BaseISCSI.py
@@ -18,7 +18,10 @@
 # ISCSISR: ISCSI software initiator SR driver
 #
 
+from sm_typing import override
+
 import SR
+import VDI
 import util
 import time
 import LUNperVDI
@@ -100,11 +103,12 @@ class BaseISCSISR(SR.SR):
             self._initPaths()
         return self._address
 
-    def handles(type):
+    @override
+    @staticmethod
+    def handles(type) -> bool:
         return False
-    handles = staticmethod(handles)
 
-    def _synchroniseAddrList(self, addrlist):
+    def _synchroniseAddrList(self, addrlist) -> None:
         if not self.multihomed:
             return
         change = False
@@ -133,7 +137,8 @@ class BaseISCSISR(SR.SR):
             except:
                 pass
 
-    def load(self, sr_uuid):
+    @override
+    def load(self, sr_uuid) -> None:
         if self.force_tapdisk:
             self.sr_vditype = 'aio'
         else:
@@ -276,7 +281,7 @@ class BaseISCSISR(SR.SR):
             self._address = self.tgtidx
         self._synchroniseAddrList(addrlist)
 
-    def _init_adapters(self):
+    def _init_adapters(self) -> None:
         # Generate a list of active adapters
         ids = scsiutil._genHostList(ISCSI_PROCNAME)
         util.SMlog(ids)
@@ -293,7 +298,8 @@ class BaseISCSISR(SR.SR):
                 pass
         self._devs = scsiutil.cacheSCSIidentifiers()
 
-    def attach(self, sr_uuid):
+    @override
+    def attach(self, sr_uuid) -> None:
         self._mpathHandle()
 
         multiTargets = False
@@ -428,10 +434,11 @@ class BaseISCSISR(SR.SR):
                 realdev = os.path.realpath(os.path.join(dev_path, dev))
                 util.set_scheduler(os.path.basename(realdev))
 
-    def detach(self, sr_uuid):
+    @override
+    def detach(self, sr_uuid) -> None:
         self.detach_and_delete(sr_uuid, delete=False)
 
-    def detach_and_delete(self, sr_uuid, delete=True):
+    def detach_and_delete(self, sr_uuid, delete=True) -> None:
         keys = []
         pbdref = None
         try:
@@ -472,7 +479,8 @@ class BaseISCSISR(SR.SR):
 
         self.attached = False
 
-    def create(self, sr_uuid, size):
+    @override
+    def create(self, sr_uuid, size) -> None:
         # Check whether an SR already exists
         SRs = self.session.xenapi.SR.get_all_records()
         for sr in SRs:
@@ -501,11 +509,13 @@ class BaseISCSISR(SR.SR):
         self.session.xenapi.SR.set_sm_config(self.sr_ref, self.sm_config)
         return
 
-    def delete(self, sr_uuid):
+    @override
+    def delete(self, sr_uuid) -> None:
         self.detach(sr_uuid)
         return
 
-    def probe(self):
+    @override
+    def probe(self) -> str:
         SRs = self.session.xenapi.SR.get_all_records()
         Recs = {}
         for sr in SRs:
@@ -515,8 +525,9 @@ class BaseISCSISR(SR.SR):
                sm_config['targetIQN'] == self.targetIQN:
                 Recs[record["uuid"]] = sm_config
         return self.srlist_toxml(Recs)
-    
-    def scan(self, sr_uuid):
+
+    @override
+    def scan(self, sr_uuid) -> None:
         if not self.passthrough:
             if not self.attached:
                 raise xs_errors.XenError('SRUnavailable')
@@ -528,9 +539,10 @@ class BaseISCSISR(SR.SR):
                 if vdi.managed:
                     self.physical_utilisation += vdi.size
             self.virtual_allocation = self.physical_utilisation
-        return super(BaseISCSISR, self).scan(sr_uuid)
+        super(BaseISCSISR, self).scan(sr_uuid)
 
-    def vdi(self, uuid):
+    @override
+    def vdi(self, uuid) -> VDI.VDI:
         return LUNperVDI.RAWVDI(self, uuid)
 
     def _scan_IQNs(self):
diff --git a/drivers/CephFSSR.py b/drivers/CephFSSR.py
index 80884767..9e8e46e1 100644
--- a/drivers/CephFSSR.py
+++ b/drivers/CephFSSR.py
@@ -18,6 +18,8 @@
 #
 # CEPHFSSR: Based on FileSR, mounts ceph fs share
 
+from sm_typing import override
+
 import errno
 import os
 import socket
@@ -33,6 +35,7 @@ import SR
 import SRCommand
 import FileSR
 # end of careful
+import VDI
 import cleanup
 import util
 import vhdutil
@@ -83,13 +86,14 @@ class CephFSSR(FileSR.FileSR):
 
     DRIVER_TYPE = 'cephfs'
 
-    def handles(sr_type):
+    @override
+    @staticmethod
+    def handles(sr_type) -> bool:
         # fudge, because the parent class (FileSR) checks for smb to alter its behavior
         return sr_type == CephFSSR.DRIVER_TYPE or sr_type == 'smb'
 
-    handles = staticmethod(handles)
-
-    def load(self, sr_uuid):
+    @override
+    def load(self, sr_uuid) -> None:
         if not self._is_ceph_available():
             raise xs_errors.XenError(
                 'SRUnavailable',
@@ -180,7 +184,8 @@ class CephFSSR(FileSR.FileSR):
             except OSError as inst:
                 raise CephFSException("rmdir failed with error '%s'" % inst.strerror)
 
-    def attach(self, sr_uuid):
+    @override
+    def attach(self, sr_uuid) -> None:
         if not self.checkmount():
             try:
                 self.mount()
@@ -189,7 +194,8 @@ class CephFSSR(FileSR.FileSR):
                 raise xs_errors.SROSError(12, exc.errstr)
         self.attached = True
 
-    def probe(self):
+    @override
+    def probe(self) -> str:
         try:
             self.mount(PROBE_MOUNTPOINT)
             sr_list = filter(util.match_uuid, util.listdir(PROBE_MOUNTPOINT))
@@ -199,7 +205,8 @@ class CephFSSR(FileSR.FileSR):
         # Create a dictionary from the SR uuids to feed SRtoXML()
         return util.SRtoXML({sr_uuid: {} for sr_uuid in sr_list})
 
-    def detach(self, sr_uuid):
+    @override
+    def detach(self, sr_uuid) -> None:
         if not self.checkmount():
             return
         util.SMlog("Aborting GC/coalesce")
@@ -210,7 +217,8 @@ class CephFSSR(FileSR.FileSR):
         os.unlink(self.path)
         self.attached = False
 
-    def create(self, sr_uuid, size):
+    @override
+    def create(self, sr_uuid, size) -> None:
         if self.checkmount():
             raise xs_errors.SROSError(113, 'CephFS mount point already attached')
 
@@ -244,7 +252,8 @@ class CephFSSR(FileSR.FileSR):
                                            os.strerror(inst.code)))
         self.detach(sr_uuid)
 
-    def delete(self, sr_uuid):
+    @override
+    def delete(self, sr_uuid) -> None:
         # try to remove/delete non VDI contents first
         super(CephFSSR, self).delete(sr_uuid)
         try:
@@ -259,7 +268,8 @@ class CephFSSR(FileSR.FileSR):
             if inst.code != errno.ENOENT:
                 raise xs_errors.SROSError(114, "Failed to remove CephFS mount point")
 
-    def vdi(self, uuid, loadLocked=False):
+    @override
+    def vdi(self, uuid, loadLocked=False) -> VDI.VDI:
         return CephFSFileVDI(self, uuid)
 
     @staticmethod
@@ -267,7 +277,8 @@ class CephFSSR(FileSR.FileSR):
         return util.find_executable('ceph')
 
 class CephFSFileVDI(FileSR.FileVDI):
-    def attach(self, sr_uuid, vdi_uuid):
+    @override
+    def attach(self, sr_uuid, vdi_uuid) -> str:
         if not hasattr(self, 'xenstore_data'):
             self.xenstore_data = {}
 
@@ -275,7 +286,8 @@ class CephFSFileVDI(FileSR.FileVDI):
 
         return super(CephFSFileVDI, self).attach(sr_uuid, vdi_uuid)
 
-    def generate_config(self, sr_uuid, vdi_uuid):
+    @override
+    def generate_config(self, sr_uuid, vdi_uuid) -> str:
         util.SMlog("SMBFileVDI.generate_config")
         if not util.pathexists(self.path):
             raise xs_errors.XenError('VDIUnavailable')
@@ -289,15 +301,16 @@ class CephFSFileVDI(FileSR.FileVDI):
         config = xmlrpc.client.dumps(tuple([resp]), "vdi_attach_from_config")
         return xmlrpc.client.dumps((config,), "", True)
 
-    def attach_from_config(self, sr_uuid, vdi_uuid):
+    @override
+    def attach_from_config(self, sr_uuid, vdi_uuid) -> str:
         try:
             if not util.pathexists(self.sr.path):
-                self.sr.attach(sr_uuid)
+                return self.sr.attach(sr_uuid)
         except:
             util.logException("SMBFileVDI.attach_from_config")
             raise xs_errors.XenError('SRUnavailable',
                                      opterr='Unable to attach from config')
-
+        return ''
 
 if __name__ == '__main__':
     SRCommand.run(CephFSSR, DRIVER_INFO)
diff --git a/drivers/DummySR.py b/drivers/DummySR.py
index be0298b9..f5674db0 100755
--- a/drivers/DummySR.py
+++ b/drivers/DummySR.py
@@ -17,7 +17,7 @@
 #
 # DummySR: an example dummy SR for the SDK
 
-from sm_typing import List, Tuple
+from sm_typing import Dict, Optional, List, Tuple, override
 
 import SR
 import VDI
@@ -49,35 +49,43 @@ TYPE = 'dummy'
 class DummySR(SR.SR):
     """dummy storage repository"""
 
-    def handles(type):
+    @override
+    @staticmethod
+    def handles(type) -> bool:
         if type == TYPE:
             return True
         return False
-    handles = staticmethod(handles)
 
-    def load(self, sr_uuid):
+    @override
+    def load(self, sr_uuid) -> None:
         self.sr_vditype = 'phy'
 
-    def content_type(self, sr_uuid):
+    @override
+    def content_type(self, sr_uuid) -> str:
         return super(DummySR, self).content_type(sr_uuid)
 
-    def create(self, sr_uuid, size):
+    @override
+    def create(self, sr_uuid, size) -> None:
         self._assertValues(['sr_uuid', 'args', 'host_ref', 'session_ref', 'device_config', 'command', 'sr_ref'])
         assert(len(self.srcmd.params['args']) == 1)
 
-    def delete(self, sr_uuid):
+    @override
+    def delete(self, sr_uuid) -> None:
         self._assertValues(['sr_uuid', 'args', 'host_ref', 'session_ref', 'device_config', 'command', 'sr_ref'])
         assert(len(self.srcmd.params['args']) == 0)
 
-    def attach(self, sr_uuid):
+    @override
+    def attach(self, sr_uuid) -> None:
         self._assertValues(['sr_uuid', 'args', 'host_ref', 'session_ref', 'device_config', 'command', 'sr_ref'])
         assert(len(self.srcmd.params['args']) == 0)
 
-    def detach(self, sr_uuid):
+    @override
+    def detach(self, sr_uuid) -> None:
         self._assertValues(['sr_uuid', 'args', 'host_ref', 'session_ref', 'device_config', 'command', 'sr_ref'])
         assert(len(self.srcmd.params['args']) == 0)
 
-    def probe(self):
+    @override
+    def probe(self) -> str:
         # N.B. There are no SR references
         self._assertValues(['args', 'host_ref', 'session_ref', 'device_config', 'command'])
         assert(len(self.srcmd.params['args']) == 0)
@@ -91,10 +99,12 @@ class DummySR(SR.SR):
         # Return the Probe XML
         return util.SRtoXML(SRlist)
 
-    def vdi(self, uuid):
+    @override
+    def vdi(self, uuid) -> VDI.VDI:
         return DummyVDI(self, uuid)
 
-    def scan(self, sr_uuid):
+    @override
+    def scan(self, sr_uuid) -> None:
         self._assertValues(['sr_uuid', 'args', 'host_ref', 'session_ref', 'device_config', 'command', 'sr_ref'])
         assert(len(self.srcmd.params['args']) == 0)
 
@@ -108,7 +118,7 @@ class DummySR(SR.SR):
         self.physical_size = 2000000000000
         self.physical_utilisation = 0
         self.virtual_allocation = 0
-        return super(DummySR, self).scan(sr_uuid)
+        super(DummySR, self).scan(sr_uuid)
 
     def _assertValues(self, vals):
         for attr in vals:
@@ -134,15 +144,17 @@ class DummySR(SR.SR):
 
 
 class DummyVDI(VDI.VDI):
-    def load(self, vdi_uuid):
+    @override
+    def load(self, vdi_uuid) -> None:
         self.path = "/dev/null"  # returned on attach
         self.uuid = vdi_uuid
         self.size = 0
         self.utilisation = 0
         self.location = vdi_uuid
-        self.sm_config = {}
+        self.sm_config: Dict[str, str] = {}
 
-    def create(self, sr_uuid, vdi_uuid, size):
+    @override
+    def create(self, sr_uuid, vdi_uuid, size) -> str:
         self.sr._assertValues(['sr_uuid', 'args', 'host_ref', 'device_config', 'command', 'sr_ref', 'vdi_sm_config'])
         assert(len(self.sr.srcmd.params['args']) == 8)
 
@@ -161,7 +173,8 @@ class DummyVDI(VDI.VDI):
         self.run_corner_cases_tests()
         return self.get_params()
 
-    def delete(self, sr_uuid, vdi_uuid, data_only=False):
+    @override
+    def delete(self, sr_uuid, vdi_uuid, data_only=False) -> None:
         self.sr._assertValues(['sr_uuid', 'args', 'host_ref', 'device_config', 'command', 'sr_ref', 'vdi_ref', 'vdi_location', 'vdi_uuid'])
         assert(len(self.sr.srcmd.params['args']) == 0)
 
@@ -170,7 +183,8 @@ class DummyVDI(VDI.VDI):
         self.run_corner_cases_tests()
         self._db_forget()
 
-    def introduce(self, sr_uuid, vdi_uuid):
+    @override
+    def introduce(self, sr_uuid, vdi_uuid) -> str:
         self.sr._assertValues(['sr_uuid', 'args', 'host_ref', 'device_config', 'command', 'sr_ref', 'vdi_sm_config', 'new_uuid'])
         assert(len(self.sr.srcmd.params['args']) == 0)
         self.vdi_sm_config = self.sr.srcmd.params['vdi_sm_config']
@@ -186,19 +200,22 @@ class DummyVDI(VDI.VDI):
         self.run_corner_cases_tests()
         return  super(DummyVDI, self).get_params()
 
-    def attach(self, sr_uuid, vdi_uuid):
+    @override
+    def attach(self, sr_uuid, vdi_uuid) -> str:
         self.sr._assertValues(['sr_uuid', 'args', 'host_ref', 'device_config', 'command', 'sr_ref', 'vdi_ref', 'vdi_location', 'vdi_uuid'])
         assert(len(self.sr.srcmd.params['args']) == 1)
         vdi = super(DummyVDI, self).attach(sr_uuid, vdi_uuid)
         self.run_corner_cases_tests()
         return vdi
 
-    def detach(self, sr_uuid, vdi_uuid):
+    @override
+    def detach(self, sr_uuid, vdi_uuid) -> None:
         self.sr._assertValues(['sr_uuid', 'args', 'host_ref', 'device_config', 'command', 'sr_ref', 'vdi_ref', 'vdi_location', 'vdi_uuid'])
         self.run_corner_cases_tests()
         assert(len(self.sr.srcmd.params['args']) == 0)
 
-    def activate(self, sr_uuid, vdi_uuid):
+    @override
+    def activate(self, sr_uuid, vdi_uuid) -> Optional[Dict[str, str]]:
         self.sr._assertValues(['sr_uuid', 'args', 'host_ref', 'device_config', 'command', 'sr_ref', 'vdi_ref', 'vdi_location', 'vdi_uuid'])
         assert(len(self.sr.srcmd.params['args']) == 1)
         self.vdi_ref = self.sr.srcmd.params['vdi_ref']
@@ -206,13 +223,16 @@ class DummyVDI(VDI.VDI):
         self.run_corner_cases_tests()
         for key in self.other_config.keys():
             util.SMlog("\tvdi_other_config: [%s:%s]" % (key, self.other_config[key]))
+        return None
 
-    def deactivate(self, sr_uuid, vdi_uuid):
+    @override
+    def deactivate(self, sr_uuid, vdi_uuid) -> None:
         self.sr._assertValues(['sr_uuid', 'args', 'host_ref', 'device_config', 'command', 'sr_ref', 'vdi_ref', 'vdi_location', 'vdi_uuid'])
         self.run_corner_cases_tests()
         assert(len(self.sr.srcmd.params['args']) == 0)
 
-    def resize(self, sr_uuid, vdi_uuid, size):
+    @override
+    def resize(self, sr_uuid, vdi_uuid, size) -> str:
         self.sr._assertValues(['sr_uuid', 'args', 'host_ref', 'device_config', 'command', 'sr_ref', 'vdi_ref', 'vdi_location', 'vdi_uuid'])
         assert(len(self.sr.srcmd.params['args']) == 1)
 
@@ -222,7 +242,8 @@ class DummyVDI(VDI.VDI):
         self.run_corner_cases_tests()
         return super(DummyVDI, self).get_params()
 
-    def snapshot(self, sr_uuid, vdi_uuid):
+    @override
+    def snapshot(self, sr_uuid, vdi_uuid) -> str:
         self.sr._assertValues(['sr_uuid', 'args', 'host_ref', 'device_config', 'command', 'sr_ref'])
         assert(len(self.sr.srcmd.params['args']) == 0)
 
@@ -236,7 +257,8 @@ class DummyVDI(VDI.VDI):
         self.run_corner_cases_tests()
         return vdi.get_params()
 
-    def clone(self, sr_uuid, vdi_uuid):
+    @override
+    def clone(self, sr_uuid, vdi_uuid) -> str:
         self.sr._assertValues(['sr_uuid', 'args', 'host_ref', 'device_config', 'command', 'sr_ref'])
         assert(len(self.sr.srcmd.params['args']) == 0)
 
diff --git a/drivers/EXTSR.py b/drivers/EXTSR.py
index 16481620..30aa3832 100755
--- a/drivers/EXTSR.py
+++ b/drivers/EXTSR.py
@@ -17,8 +17,11 @@
 #
 # EXTSR: Based on local-file storage repository, mounts ext3 partition
 
+from sm_typing import override
+
 import SR
 from SR import deviceCheck
+import VDI
 import SRCommand
 import FileSR
 import util
@@ -57,11 +60,13 @@ DRIVER_CONFIG = {"ATTACH_FROM_CONFIG_WITH_TAPDISK": True}
 class EXTSR(FileSR.FileSR):
     """EXT3 Local file storage repository"""
 
-    def handles(srtype):
+    @override
+    @staticmethod
+    def handles(srtype) -> bool:
         return srtype == 'ext'
-    handles = staticmethod(handles)
 
-    def load(self, sr_uuid):
+    @override
+    def load(self, sr_uuid) -> None:
         self.ops_exclusive = FileSR.OPS_EXCLUSIVE
         self.lock = Lock(vhdutil.LOCK_TYPE_SR, self.uuid)
         self.sr_vditype = SR.DEFAULT_TAP
@@ -72,7 +77,8 @@ class EXTSR(FileSR.FileSR):
         self.attached = self._checkmount()
         self.driver_config = DRIVER_CONFIG
 
-    def delete(self, sr_uuid):
+    @override
+    def delete(self, sr_uuid) -> None:
         super(EXTSR, self).delete(sr_uuid)
 
         # Check PVs match VG
@@ -102,7 +108,8 @@ class EXTSR(FileSR.FileSR):
             raise xs_errors.XenError('LVMDelete',
                                      opterr='errno is %d' % inst.code)
 
-    def attach(self, sr_uuid):
+    @override
+    def attach(self, sr_uuid) -> None:
         if not self._checkmount():
             try:
                 #Activate LV
@@ -136,7 +143,8 @@ class EXTSR(FileSR.FileSR):
         for dev in self.dconf['device'].split(','):
             self.block_setscheduler(dev)
 
-    def detach(self, sr_uuid):
+    @override
+    def detach(self, sr_uuid) -> None:
         super(EXTSR, self).detach(sr_uuid)
         try:
             # deactivate SR
@@ -147,13 +155,15 @@ class EXTSR(FileSR.FileSR):
                 'LVMUnMount',
                 opterr='lvm -an failed errno is %d' % inst.code)
 
+    @override
     @deviceCheck
-    def probe(self):
+    def probe(self) -> str:
         return lvutil.srlist_toxml(lvutil.scan_srlist(EXT_PREFIX, self.dconf['device']),
                 EXT_PREFIX)
 
+    @override
     @deviceCheck
-    def create(self, sr_uuid, size):
+    def create(self, sr_uuid, size) -> None:
         if self._checkmount():
             raise xs_errors.XenError('SRExists')
 
@@ -214,12 +224,14 @@ class EXTSR(FileSR.FileSR):
             self.session, self.sr_ref,
             scsiutil.devlist_to_serialstring(self.dconf['device'].split(',')))
 
-    def vdi(self, uuid):
+    @override
+    def vdi(self, uuid) -> VDI.VDI:
         return EXTFileVDI(self, uuid)
 
 
 class EXTFileVDI(FileSR.FileVDI):
-    def attach(self, sr_uuid, vdi_uuid):
+    @override
+    def attach(self, sr_uuid, vdi_uuid) -> str:
         if not hasattr(self, 'xenstore_data'):
             self.xenstore_data = {}
 
diff --git a/drivers/FileSR.py b/drivers/FileSR.py
index 9f2ec28f..60699a3e 100755
--- a/drivers/FileSR.py
+++ b/drivers/FileSR.py
@@ -17,7 +17,7 @@
 #
 # FileSR: local-file storage repository
 
-from sm_typing import Dict, List
+from sm_typing import Dict, Optional, List, override
 
 import SR
 import VDI
@@ -73,9 +73,10 @@ class FileSR(SR.SR):
 
     SR_TYPE = "file"
 
-    def handles(srtype):
+    @override
+    @staticmethod
+    def handles(srtype) -> bool:
         return srtype == 'file'
-    handles = staticmethod(handles)
 
     def _check_o_direct(self):
         if self.sr_ref and self.session is not None:
@@ -91,7 +92,8 @@ class FileSR(SR.SR):
         SR.SR.__init__(self, srcmd, sr_uuid)
         self._check_o_direct()
 
-    def load(self, sr_uuid):
+    @override
+    def load(self, sr_uuid) -> None:
         self.ops_exclusive = OPS_EXCLUSIVE
         self.lock = Lock(vhdutil.LOCK_TYPE_SR, self.uuid)
         self.sr_vditype = vhdutil.VDI_TYPE_VHD
@@ -104,7 +106,8 @@ class FileSR(SR.SR):
         self.attached = False
         self.driver_config = DRIVER_CONFIG
 
-    def create(self, sr_uuid, size):
+    @override
+    def create(self, sr_uuid, size) -> None:
         """ Create the SR.  The path must not already exist, or if it does, 
         it must be empty.  (This accounts for the case where the user has
         mounted a device onto a directory manually and want to use this as the
@@ -126,7 +129,8 @@ class FileSR(SR.SR):
         except:
             raise xs_errors.XenError('FileSRCreate')
 
-    def delete(self, sr_uuid):
+    @override
+    def delete(self, sr_uuid) -> None:
         self.attach(sr_uuid)
         cleanup.gc_force(self.session, self.uuid)
 
@@ -158,10 +162,11 @@ class FileSR(SR.SR):
             raise xs_errors.XenError('FileSRDelete', \
                   opterr='error %d' % inst.code)
 
-    def attach(self, sr_uuid):
+    @override
+    def attach(self, sr_uuid) -> None:
         self.attach_and_bind(sr_uuid)
 
-    def attach_and_bind(self, sr_uuid, bind=True):
+    def attach_and_bind(self, sr_uuid, bind=True) -> None:
         if not self._checkmount():
             try:
                 util.ioretry(lambda: util.makedirs(self.path, mode=0o700))
@@ -180,7 +185,8 @@ class FileSR(SR.SR):
                                          opterr='fail to mount FileSR. Errno is %s' % inst.code)
         self.attached = True
 
-    def detach(self, sr_uuid):
+    @override
+    def detach(self, sr_uuid) -> None:
         if self._checkmount():
             try:
                 util.SMlog("Aborting GC/coalesce")
@@ -192,7 +198,8 @@ class FileSR(SR.SR):
                 raise xs_errors.XenError('SRInUse', opterr=str(e))
         self.attached = False
 
-    def scan(self, sr_uuid):
+    @override
+    def scan(self, sr_uuid) -> None:
         if not self._checkmount():
             raise xs_errors.XenError('SRUnavailable', \
                   opterr='no such directory %s' % self.path)
@@ -226,7 +233,8 @@ class FileSR(SR.SR):
         # default behaviour from here on
         super(FileSR, self).scan(sr_uuid)
 
-    def update(self, sr_uuid):
+    @override
+    def update(self, sr_uuid) -> None:
         if not self._checkmount():
             raise xs_errors.XenError('SRUnavailable', \
                   opterr='no such directory %s' % self.path)
@@ -239,10 +247,12 @@ class FileSR(SR.SR):
         self.physical_utilisation = self._getutilisation()
         self._db_update()
 
-    def content_type(self, sr_uuid):
+    @override
+    def content_type(self, sr_uuid) -> str:
         return super(FileSR, self).content_type(sr_uuid)
 
-    def vdi(self, uuid):
+    @override
+    def vdi(self, uuid) -> VDI.VDI:
         return FileVDI(self, uuid)
 
     def added_vdi(self, vdi):
@@ -252,7 +262,8 @@ class FileSR(SR.SR):
         if uuid in self.vdis:
             del self.vdis[uuid]
 
-    def replay(self, uuid):
+    @override
+    def replay(self, uuid) -> None:
         try:
             file = open(self.path + "/filelog.txt", "r")
             data = file.readlines()
@@ -392,7 +403,7 @@ class FileSR(SR.SR):
         st2 = os.stat(self.remotepath)
         return st1.st_dev == st2.st_dev and st1.st_ino == st2.st_ino
 
-    def _checkmount(self):
+    def _checkmount(self) -> bool:
         mount_path = self.path
         if self.handles("smb"):
             mount_path = self.mountpoint
@@ -402,7 +413,7 @@ class FileSR(SR.SR):
                                  util.pathexists(self.remotepath) and self._isbind()))
 
     # Override in SharedFileSR.
-    def _check_hardlinks(self):
+    def _check_hardlinks(self) -> bool:
         return True
 
 class FileVDI(VDI.VDI):
@@ -445,7 +456,8 @@ class FileVDI(VDI.VDI):
 
         return found
 
-    def load(self, vdi_uuid):
+    @override
+    def load(self, vdi_uuid) -> None:
         self.lock = self.sr.lock
 
         self.sr.srcmd.params['o_direct'] = self.sr.o_direct
@@ -554,13 +566,15 @@ class FileVDI(VDI.VDI):
                 raise xs_errors.XenError('VDILoad', \
                       opterr='Failed load VDI information %s' % self.path)
 
-    def update(self, sr_uuid, vdi_location):
+    @override
+    def update(self, sr_uuid, vdi_location) -> None:
         self.load(vdi_location)
         vdi_ref = self.sr.srcmd.params['vdi_ref']
         self.sm_config = self.session.xenapi.VDI.get_sm_config(vdi_ref)
         self._db_update()
 
-    def create(self, sr_uuid, vdi_uuid, size):
+    @override
+    def create(self, sr_uuid, vdi_uuid, size) -> str:
         if util.ioretry(lambda: util.pathexists(self.path)):
             raise xs_errors.XenError('VDIExists')
 
@@ -591,7 +605,8 @@ class FileVDI(VDI.VDI):
         self.sr._update(self.sr.uuid, self.size)
         return super(FileVDI, self).get_params()
 
-    def delete(self, sr_uuid, vdi_uuid, data_only=False):
+    @override
+    def delete(self, sr_uuid, vdi_uuid, data_only=False) -> None:
         if not util.ioretry(lambda: util.pathexists(self.path)):
             return super(FileVDI, self).delete(sr_uuid, vdi_uuid, data_only)
 
@@ -614,7 +629,8 @@ class FileVDI(VDI.VDI):
         self.sr._kickGC()
         return super(FileVDI, self).delete(sr_uuid, vdi_uuid, data_only)
 
-    def attach(self, sr_uuid, vdi_uuid):
+    @override
+    def attach(self, sr_uuid, vdi_uuid) -> str:
         if self.path is None:
             self._find_path_with_retries(vdi_uuid)
         if not self._checkpath(self.path):
@@ -638,10 +654,12 @@ class FileVDI(VDI.VDI):
         except util.CommandException as inst:
             raise xs_errors.XenError('VDILoad', opterr='error %d' % inst.code)
 
-    def detach(self, sr_uuid, vdi_uuid):
+    @override
+    def detach(self, sr_uuid, vdi_uuid) -> None:
         self.attached = False
 
-    def resize(self, sr_uuid, vdi_uuid, size):
+    @override
+    def resize(self, sr_uuid, vdi_uuid, size) -> str:
         if not self.exists:
             raise xs_errors.XenError('VDIUnavailable', \
                   opterr='VDI %s unavailable %s' % (vdi_uuid, self.path))
@@ -681,10 +699,12 @@ class FileVDI(VDI.VDI):
         super(FileVDI, self).resize_cbt(self.sr.uuid, self.uuid, self.size)
         return VDI.VDI.get_params(self)
 
-    def clone(self, sr_uuid, vdi_uuid):
+    @override
+    def clone(self, sr_uuid, vdi_uuid) -> str:
         return self._do_snapshot(sr_uuid, vdi_uuid, VDI.SNAPSHOT_DOUBLE)
 
-    def compose(self, sr_uuid, vdi1, vdi2):
+    @override
+    def compose(self, sr_uuid, vdi1, vdi2) -> None:
         if self.vdi_type != vhdutil.VDI_TYPE_VHD:
             raise xs_errors.XenError('Unimplemented')
         parent_fn = vdi1 + vhdutil.FILE_EXTN[vhdutil.VDI_TYPE_VHD]
@@ -711,8 +731,9 @@ class FileVDI(VDI.VDI):
 
         vhdutil.killData(self.path)
 
+    @override
     def _do_snapshot(self, sr_uuid, vdi_uuid, snapType,
-                     cloneOp=False, secondary=None, cbtlog=None):
+                     cloneOp=False, secondary=None, cbtlog=None) -> str:
         # If cbt enabled, save file consistency state
         if cbtlog is not None:
             if blktap2.VDI.tap_status(self.session, vdi_uuid):
@@ -734,7 +755,8 @@ class FileVDI(VDI.VDI):
         finally:
             blktap2.VDI.tap_unpause(self.session, sr_uuid, vdi_uuid, secondary)
 
-    def _rename(self, src, dst):
+    @override
+    def _rename(self, src, dst) -> None:
         util.SMlog("FileVDI._rename %s to %s" % (src, dst))
         util.ioretry(lambda: os.rename(src, dst))
 
@@ -915,7 +937,8 @@ class FileVDI(VDI.VDI):
             ret_vdi = self
         return ret_vdi.get_params()
 
-    def get_params(self):
+    @override
+    def get_params(self) -> str:
         if not self._checkpath(self.path):
             raise xs_errors.XenError('VDIUnavailable', \
                   opterr='VDI %s unavailable %s' % (self.uuid, self.path))
@@ -995,7 +1018,8 @@ class FileVDI(VDI.VDI):
         return uuid
     extractUuid = staticmethod(extractUuid)
 
-    def generate_config(self, sr_uuid, vdi_uuid):
+    @override
+    def generate_config(self, sr_uuid, vdi_uuid) -> str:
         """
         Generate the XML config required to attach and activate
         a VDI for use when XAPI is not running. Attach and
@@ -1014,7 +1038,8 @@ class FileVDI(VDI.VDI):
         config = xmlrpc.client.dumps(tuple([resp]), "vdi_attach_from_config")
         return xmlrpc.client.dumps((config, ), "", True)
 
-    def attach_from_config(self, sr_uuid, vdi_uuid):
+    @override
+    def attach_from_config(self, sr_uuid, vdi_uuid) -> str:
         """
         Attach and activate a VDI using config generated by
         vdi_generate_config above. This is used for cases such as
@@ -1023,15 +1048,17 @@ class FileVDI(VDI.VDI):
         util.SMlog("FileVDI.attach_from_config")
         try:
             if not util.pathexists(self.sr.path):
-                self.sr.attach(sr_uuid)
+                return self.sr.attach(sr_uuid)
         except:
             util.logException("FileVDI.attach_from_config")
             raise xs_errors.XenError(
                 'SRUnavailable',
                 opterr='Unable to attach from config'
             )
+        return ''
 
-    def _create_cbt_log(self):
+    @override
+    def _create_cbt_log(self) -> str:
         # Create CBT log file
         # Name: <vdi_uuid>.cbtlog
         #Handle if file already exists
@@ -1040,7 +1067,8 @@ class FileVDI(VDI.VDI):
         open_file.close()
         return super(FileVDI, self)._create_cbt_log()
 
-    def _delete_cbt_log(self):
+    @override
+    def _delete_cbt_log(self) -> None:
         logPath = self._get_cbt_logpath(self.uuid)
         try:
             os.remove(logPath)
@@ -1048,7 +1076,8 @@ class FileVDI(VDI.VDI):
             if e.errno != errno.ENOENT:
                 raise
 
-    def _cbt_log_exists(self, logpath):
+    @override
+    def _cbt_log_exists(self, logpath) -> bool:
         return util.pathexists(logpath)
 
 
@@ -1074,7 +1103,8 @@ class SharedFileSR(FileSR):
     def _raise_hardlink_error(self):
         raise OSError(524, "Unknown error 524")
 
-    def _check_hardlinks(self):
+    @override
+    def _check_hardlinks(self) -> bool:
         hardlink_conf = self._read_hardlink_conf()
         if hardlink_conf is not None:
             return hardlink_conf
@@ -1116,7 +1146,7 @@ class SharedFileSR(FileSR):
     def _get_hardlink_conf_path(self):
         return os.path.join(self.path, 'sm-hardlink.conf')
 
-    def _read_hardlink_conf(self):
+    def _read_hardlink_conf(self) -> Optional[bool]:
         try:
             with open(self._get_hardlink_conf_path(), 'r') as f:
                 try:
diff --git a/drivers/GlusterFSSR.py b/drivers/GlusterFSSR.py
index 041a9142..7b515dc8 100644
--- a/drivers/GlusterFSSR.py
+++ b/drivers/GlusterFSSR.py
@@ -16,6 +16,8 @@
 # along with this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 
+from sm_typing import override
+
 import errno
 import os
 import syslog as _syslog
@@ -29,6 +31,7 @@ import SR
 import SRCommand
 import FileSR
 # end of careful
+import VDI
 import cleanup
 import util
 import vhdutil
@@ -77,13 +80,14 @@ class GlusterFSSR(FileSR.FileSR):
 
     DRIVER_TYPE = 'glusterfs'
 
-    def handles(sr_type):
+    @override
+    @staticmethod
+    def handles(sr_type) -> bool:
         # fudge, because the parent class (FileSR) checks for smb to alter its behavior
         return sr_type == GlusterFSSR.DRIVER_TYPE or sr_type == 'smb'
 
-    handles = staticmethod(handles)
-
-    def load(self, sr_uuid):
+    @override
+    def load(self, sr_uuid) -> None:
         if not self._is_glusterfs_available():
             raise xs_errors.XenError(
                 'SRUnavailable',
@@ -160,7 +164,8 @@ class GlusterFSSR(FileSR.FileSR):
             except OSError as inst:
                 raise GlusterFSException("rmdir failed with error '%s'" % inst.strerror)
 
-    def attach(self, sr_uuid):
+    @override
+    def attach(self, sr_uuid) -> None:
         if not self.checkmount():
             try:
                 self.mount()
@@ -169,7 +174,8 @@ class GlusterFSSR(FileSR.FileSR):
                 raise xs_errors.SROSError(12, exc.errstr)
         self.attached = True
 
-    def probe(self):
+    @override
+    def probe(self) -> str:
         try:
             self.mount(PROBE_MOUNTPOINT)
             sr_list = filter(util.match_uuid, util.listdir(PROBE_MOUNTPOINT))
@@ -179,7 +185,8 @@ class GlusterFSSR(FileSR.FileSR):
         # Create a dictionary from the SR uuids to feed SRtoXML()
         return util.SRtoXML({sr_uuid: {} for sr_uuid in sr_list})
 
-    def detach(self, sr_uuid):
+    @override
+    def detach(self, sr_uuid) -> None:
         if not self.checkmount():
             return
         util.SMlog("Aborting GC/coalesce")
@@ -190,7 +197,8 @@ class GlusterFSSR(FileSR.FileSR):
         os.unlink(self.path)
         self.attached = False
 
-    def create(self, sr_uuid, size):
+    @override
+    def create(self, sr_uuid, size) -> None:
         if self.checkmount():
             raise xs_errors.SROSError(113, 'GlusterFS mount point already attached')
 
@@ -224,7 +232,8 @@ class GlusterFSSR(FileSR.FileSR):
                                            os.strerror(inst.code)))
         self.detach(sr_uuid)
 
-    def delete(self, sr_uuid):
+    @override
+    def delete(self, sr_uuid) -> None:
         # try to remove/delete non VDI contents first
         super(GlusterFSSR, self).delete(sr_uuid)
         try:
@@ -239,7 +248,8 @@ class GlusterFSSR(FileSR.FileSR):
             if inst.code != errno.ENOENT:
                 raise xs_errors.SROSError(114, "Failed to remove GlusterFS mount point")
 
-    def vdi(self, uuid, loadLocked=False):
+    @override
+    def vdi(self, uuid, loadLocked=False) -> VDI.VDI:
         return GlusterFSFileVDI(self, uuid)
 
     @staticmethod
@@ -248,7 +258,8 @@ class GlusterFSSR(FileSR.FileSR):
 
 
 class GlusterFSFileVDI(FileSR.FileVDI):
-    def attach(self, sr_uuid, vdi_uuid):
+    @override
+    def attach(self, sr_uuid, vdi_uuid) -> str:
         if not hasattr(self, 'xenstore_data'):
             self.xenstore_data = {}
 
@@ -256,7 +267,8 @@ class GlusterFSFileVDI(FileSR.FileVDI):
 
         return super(GlusterFSFileVDI, self).attach(sr_uuid, vdi_uuid)
 
-    def generate_config(self, sr_uuid, vdi_uuid):
+    @override
+    def generate_config(self, sr_uuid, vdi_uuid) -> str:
         util.SMlog("SMBFileVDI.generate_config")
         if not util.pathexists(self.path):
             raise xs_errors.XenError('VDIUnavailable')
@@ -270,15 +282,16 @@ class GlusterFSFileVDI(FileSR.FileVDI):
         config = xmlrpc.client.dumps(tuple([resp]), "vdi_attach_from_config")
         return xmlrpc.client.dumps((config,), "", True)
 
-    def attach_from_config(self, sr_uuid, vdi_uuid):
+    @override
+    def attach_from_config(self, sr_uuid, vdi_uuid) -> str:
         try:
             if not util.pathexists(self.sr.path):
-                self.sr.attach(sr_uuid)
+                return self.sr.attach(sr_uuid)
         except:
             util.logException("SMBFileVDI.attach_from_config")
             raise xs_errors.XenError('SRUnavailable',
                                      opterr='Unable to attach from config')
-
+        return ''
 
 if __name__ == '__main__':
     SRCommand.run(GlusterFSSR, DRIVER_INFO)
diff --git a/drivers/HBASR.py b/drivers/HBASR.py
index 66ca3ee9..1740f42e 100755
--- a/drivers/HBASR.py
+++ b/drivers/HBASR.py
@@ -19,8 +19,11 @@
 # hardware based iSCSI
 #
 
+from sm_typing import Dict, List, override
+
 import SR
 import SRCommand
+import VDI
 import devscan
 import scsiutil
 import util
@@ -50,20 +53,22 @@ DRIVER_INFO = {
 class HBASR(SR.SR):
     """HBA storage repository"""
 
-    def handles(type):
+    @override
+    @staticmethod
+    def handles(type) -> bool:
         if type == "hba":
             return True
         return False
-    handles = staticmethod(handles)
 
-    def load(self, sr_uuid):
+    @override
+    def load(self, sr_uuid) -> None:
         self.sr_vditype = 'phy'
         self.type = "any"
         if 'type' in self.dconf and self.dconf['type']:
             self.type = self.dconf['type']
         self.attached = False
         self.procname = ""
-        self.devs = {}
+        self.devs: Dict[str, List[str]] = {}
 
     def _init_hbadict(self):
         if not hasattr(self, "hbas"):
@@ -174,15 +179,18 @@ class HBASR(SR.SR):
             raise xs_errors.XenError('XMLParse', \
                                      opterr='HBA probe failed')
 
-    def attach(self, sr_uuid):
+    @override
+    def attach(self, sr_uuid) -> None:
         self._mpathHandle()
 
-    def detach(self, sr_uuid):
+    @override
+    def detach(self, sr_uuid) -> None:
         if util._containsVDIinuse(self):
             return
         return
 
-    def create(self, sr_uuid, size):
+    @override
+    def create(self, sr_uuid, size) -> None:
         # Check whether an SR already exists
         SRs = self.session.xenapi.SR.get_all_records()
         for sr in SRs:
@@ -211,11 +219,13 @@ class HBASR(SR.SR):
         self.sm_config['multipathable'] = 'true'
         self.session.xenapi.SR.set_sm_config(self.sr_ref, self.sm_config)
 
-    def delete(self, sr_uuid):
+    @override
+    def delete(self, sr_uuid) -> None:
         self.detach(sr_uuid)
         return
 
-    def probe(self):
+    @override
+    def probe(self) -> str:
         self._init_hbadict()
         self.attach("")
         SRs = self.session.xenapi.SR.get_all_records()
@@ -228,7 +238,8 @@ class HBASR(SR.SR):
                 Recs[record["uuid"]] = sm_config
         return self.srlist_toxml(Recs)
 
-    def scan(self, sr_uuid):
+    @override
+    def scan(self, sr_uuid) -> None:
         self._init_hbadict()
         if not self.passthrough:
             if not self.attached:
@@ -242,7 +253,7 @@ class HBASR(SR.SR):
                 if vdi.managed:
                     self.physical_utilisation += vdi.size
             self.virtual_allocation = self.physical_utilisation
-        return super(HBASR, self).scan(sr_uuid)
+        super(HBASR, self).scan(sr_uuid)
 
     def print_devs(self):
         self.attach("")
@@ -273,7 +284,8 @@ class HBASR(SR.SR):
     def _getLUNbySMconfig(self, sm_config):
         raise xs_errors.XenError('VDIUnavailable')
 
-    def vdi(self, uuid):
+    @override
+    def vdi(self, uuid) -> VDI.VDI:
         return LUNperVDI.RAWVDI(self, uuid)
 
     def srlist_toxml(self, SRs):
diff --git a/drivers/ISOSR.py b/drivers/ISOSR.py
index 64f99b48..401461c6 100755
--- a/drivers/ISOSR.py
+++ b/drivers/ISOSR.py
@@ -17,6 +17,8 @@
 #
 # ISOSR: remote iso storage repository
 
+from sm_typing import override
+
 import SR
 import VDI
 import SRCommand
@@ -152,7 +154,7 @@ class ISOSR(SR.SR):
     """Local file storage repository"""
 
     # Some helper functions:
-    def _checkmount(self):
+    def _checkmount(self) -> bool:
         """Checks that the mountpoint exists and is mounted"""
         if not util.pathexists(self.mountpoint):
             return False
@@ -221,21 +223,24 @@ class ISOSR(SR.SR):
                     vdi.read_only = False
 
 # Now for the main functions:
-    def handles(type):
+    @override
+    @staticmethod
+    def handles(type) -> bool:
         """Do we handle this type?"""
         if type == TYPE:
             return True
         return False
-    handles = staticmethod(handles)
 
-    def content_type(self, sr_uuid):
+    @override
+    def content_type(self, sr_uuid) -> str:
         """Returns the content_type XML"""
         return super(ISOSR, self).content_type(sr_uuid)
 
     # pylint: disable=no-member
     vdi_path_regex = re.compile(r"[a-z0-9.-]+\.(iso|img)", re.I)
 
-    def vdi(self, uuid):
+    @override
+    def vdi(self, uuid) -> VDI.VDI:
         """Create a VDI class.  If the VDI does not exist, we determine
         here what its filename should be."""
 
@@ -267,7 +272,8 @@ class ISOSR(SR.SR):
 
         return ISOVDI(self, filename)
 
-    def load(self, sr_uuid):
+    @override
+    def load(self, sr_uuid) -> None:
         """Initialises the SR"""
         # First of all, check we've got the correct keys in dconf
         if 'location' not in self.dconf:
@@ -302,10 +308,12 @@ class ISOSR(SR.SR):
         # Some info we need:
         self.sr_vditype = 'phy'
 
-    def delete(self, sr_uuid):
+    @override
+    def delete(self, sr_uuid) -> None:
         pass
 
-    def attach(self, sr_uuid):
+    @override
+    def attach(self, sr_uuid) -> None:
         """Std. attach"""
         # Very-Legacy mode means the ISOs are in the local fs - so no need to attach.
         if 'legacy_mode' in self.dconf:
@@ -475,8 +483,8 @@ class ISOSR(SR.SR):
         except nfs.NfsException as e:
             raise xs_errors.XenError('NFSTarget', opterr=str(e.errstr))
 
-
-    def after_master_attach(self, uuid):
+    @override
+    def after_master_attach(self, uuid) -> None:
         """Perform actions required after attaching on the pool master
         Return:
           None
@@ -568,7 +576,8 @@ class ISOSR(SR.SR):
         """Pass cache options to mount.cifs"""
         return "cache=none"
 
-    def detach(self, sr_uuid):
+    @override
+    def detach(self, sr_uuid) -> None:
         """Std. detach"""
         if 'legacy_mode' in self.dconf or not self._checkmount():
             return
@@ -579,7 +588,8 @@ class ISOSR(SR.SR):
             raise xs_errors.XenError('NFSUnMount', \
                                          opterr='error is %d' % inst.code)
 
-    def scan(self, sr_uuid):
+    @override
+    def scan(self, sr_uuid) -> None:
         """Scan: see _loadvdis"""
         if not util.isdir(self.path):
             raise xs_errors.XenError('SRUnavailable', \
@@ -660,9 +670,10 @@ class ISOSR(SR.SR):
                 self.session.xenapi.VDI.remove_from_sm_config(vdi, 'xs-tools')
 
         else:
-            return super(ISOSR, self).scan(sr_uuid)
+            super(ISOSR, self).scan(sr_uuid)
 
-    def create(self, sr_uuid, size):
+    @override
+    def create(self, sr_uuid, size) -> None:
         self.attach(sr_uuid)
         if 'type' in self.dconf:
             smconfig = self.session.xenapi.SR.get_sm_config(self.sr_ref)
@@ -681,9 +692,10 @@ class ISOSR(SR.SR):
 
         self.detach(sr_uuid)
 
-        
+
 class ISOVDI(VDI.VDI):
-    def load(self, vdi_uuid):
+    @override
+    def load(self, vdi_uuid) -> None:
         # Nb, in the vdi_create call, the filename is unset, so the following
         # will fail.
         self.vdi_type = "iso"
@@ -725,17 +737,20 @@ class ISOVDI(VDI.VDI):
                 self.sm_config['xs-tools-version'] = product_version
                 self.sm_config['xs-tools-build'] = build_number
 
-    def detach(self, sr_uuid, vdi_uuid):
+    @override
+    def detach(self, sr_uuid, vdi_uuid) -> None:
         pass
 
-    def attach(self, sr_uuid, vdi_uuid):
+    @override
+    def attach(self, sr_uuid, vdi_uuid) -> str:
         try:
             os.stat(self.path)
             return super(ISOVDI, self).attach(sr_uuid, vdi_uuid)
         except:
             raise xs_errors.XenError('VDIMissing')
 
-    def create(self, sr_uuid, vdi_uuid, size):
+    @override
+    def create(self, sr_uuid, vdi_uuid, size) -> str:
         self.uuid = vdi_uuid
         self.path = os.path.join(self.sr.path, self.filename)
         self.size = size
@@ -758,7 +773,8 @@ class ISOVDI(VDI.VDI):
             raise xs_errors.XenError('VDICreate', \
                      opterr='could not create file: "%s"' % self.path)
 
-    def delete(self, sr_uuid, vdi_uuid, data_only=False):
+    @override
+    def delete(self, sr_uuid, vdi_uuid, data_only=False) -> None:
         util.SMlog("Deleting...")
 
         self.uuid = vdi_uuid
diff --git a/drivers/LUNperVDI.py b/drivers/LUNperVDI.py
index 497ba6b5..e3583a59 100755
--- a/drivers/LUNperVDI.py
+++ b/drivers/LUNperVDI.py
@@ -18,6 +18,8 @@
 # LUNperVDI: Generic Raw LUN handler, used by HBASR and ISCSISR
 #
 
+from sm_typing import override
+
 import os
 import VDI
 import util
@@ -28,7 +30,8 @@ MAX_TIMEOUT = 15
 
 
 class RAWVDI(VDI.VDI):
-    def load(self, vdi_uuid):
+    @override
+    def load(self, vdi_uuid) -> None:
         if not self.sr.attached:
             raise xs_errors.XenError('SRUnavailable')
 
@@ -60,7 +63,8 @@ class RAWVDI(VDI.VDI):
         sm_config['backend-kind'] = 'vbd'
         self.sm_config = sm_config
 
-    def introduce(self, sr_uuid, vdi_uuid):
+    @override
+    def introduce(self, sr_uuid, vdi_uuid) -> str:
         self.sm_config = self.sr.srcmd.params['vdi_sm_config']
         vdi_path = self.sr._getLUNbySMconfig(self.sm_config)
         self._query(vdi_path, self.sm_config['LUNid'])
@@ -78,7 +82,8 @@ class RAWVDI(VDI.VDI):
             self.sr.vdis[vdi_uuid]._db_introduce()
         return super(RAWVDI, self).get_params()
 
-    def create(self, sr_uuid, vdi_uuid, size):
+    @override
+    def create(self, sr_uuid, vdi_uuid, size) -> str:
         VDIs = util._getVDIs(self.sr)
         self.sr._loadvdis()
         smallest = 0
@@ -98,7 +103,8 @@ class RAWVDI(VDI.VDI):
             return super(RAWVDI, self.sr.vdis[v['uuid']]).get_params()
         raise xs_errors.XenError('SRNoSpace')
 
-    def delete(self, sr_uuid, vdi_uuid, data_only=False):
+    @override
+    def delete(self, sr_uuid, vdi_uuid, data_only=False) -> None:
         try:
             vdi = util._getVDI(self.sr, vdi_uuid)
             if not vdi['managed']:
@@ -108,7 +114,8 @@ class RAWVDI(VDI.VDI):
         except:
             pass
 
-    def attach(self, sr_uuid, vdi_uuid):
+    @override
+    def attach(self, sr_uuid, vdi_uuid) -> str:
         self.sr._loadvdis()
         if vdi_uuid not in self.sr.vdis:
             raise xs_errors.XenError('VDIUnavailable')
@@ -126,7 +133,8 @@ class RAWVDI(VDI.VDI):
                 raise xs_errors.XenError('VDIUnavailable')
         return super(RAWVDI, self).attach(sr_uuid, vdi_uuid)
 
-    def detach(self, sr_uuid, vdi_uuid):
+    @override
+    def detach(self, sr_uuid, vdi_uuid) -> None:
         self.sr._loadvdis()
         if 'SCSIid' in self.sm_config:
             self.sr.mpathmodule.reset(self.sm_config['SCSIid'], True)  # explicitly unmap
diff --git a/drivers/LVHDSR.py b/drivers/LVHDSR.py
index 0cb86bea..3e9afcde 100755
--- a/drivers/LVHDSR.py
+++ b/drivers/LVHDSR.py
@@ -18,7 +18,7 @@
 # LVHDSR: VHD on LVM storage repository
 #
 
-from sm_typing import Dict, List
+from sm_typing import Dict, List, override
 
 import SR
 from SR import deviceCheck
@@ -135,7 +135,9 @@ class LVHDSR(SR.SR):
 
     legacyMode = True
 
-    def handles(type):
+    @override
+    @staticmethod
+    def handles(type) -> bool:
         """Returns True if this SR class understands the given dconf string"""
         # we can pose as LVMSR or EXTSR for compatibility purposes
         if __name__ == '__main__':
@@ -147,9 +149,9 @@ class LVHDSR(SR.SR):
         elif name.endswith("EXTSR"):
             return type == "ext"
         return type == LVHDSR.DRIVER_TYPE
-    handles = staticmethod(handles)
 
-    def load(self, sr_uuid):
+    @override
+    def load(self, sr_uuid) -> None:
         self.ops_exclusive = OPS_EXCLUSIVE
 
         self.isMaster = False
@@ -238,7 +240,8 @@ class LVHDSR(SR.SR):
         except:
             pass
 
-    def cleanup(self):
+    @override
+    def cleanup(self) -> None:
         # we don't need to hold the lock to dec refcounts of activated LVs
         if not self.lvActivator.deactivateAll():
             raise util.SMException("failed to deactivate LVs")
@@ -481,8 +484,9 @@ class LVHDSR(SR.SR):
                 util.logException("LVHDSR._expand_size for %s failed to resize"
                                   " the PV" % self.uuid)
 
+    @override
     @deviceCheck
-    def create(self, uuid, size):
+    def create(self, uuid, size) -> None:
         util.SMlog("LVHDSR.create for %s" % self.uuid)
         if not self.isMaster:
             util.SMlog('sr_create blocked for non-master')
@@ -510,7 +514,8 @@ class LVHDSR(SR.SR):
         self.session.xenapi.SR.add_to_sm_config(self.sr_ref, \
                                                 self.FLAG_USE_VHD, 'true')
 
-    def delete(self, uuid):
+    @override
+    def delete(self, uuid) -> None:
         util.SMlog("LVHDSR.delete for %s" % self.uuid)
         if not self.isMaster:
             raise xs_errors.XenError('LVMMaster')
@@ -564,7 +569,8 @@ class LVHDSR(SR.SR):
         lvutil.removeVG(self.dconf['device'], self.vgname)
         self._cleanup()
 
-    def attach(self, uuid):
+    @override
+    def attach(self, uuid) -> None:
         util.SMlog("LVHDSR.attach for %s" % self.uuid)
 
         self._cleanup(True)  # in case of host crashes, if detach wasn't called
@@ -602,7 +608,8 @@ class LVHDSR(SR.SR):
         for dev in self.dconf['device'].split(','):
             self.block_setscheduler(dev)
 
-    def detach(self, uuid):
+    @override
+    def detach(self, uuid) -> None:
         util.SMlog("LVHDSR.detach for %s" % self.uuid)
         cleanup.abort(self.uuid)
 
@@ -660,12 +667,14 @@ class LVHDSR(SR.SR):
         # only place to do so.
         self._cleanup(self.isMaster)
 
-    def forget_vdi(self, uuid):
+    @override
+    def forget_vdi(self, uuid) -> None:
         if not self.legacyMode:
             LVMMetadataHandler(self.mdpath).deleteVdiFromMetadata(uuid)
         super(LVHDSR, self).forget_vdi(uuid)
 
-    def scan(self, uuid):
+    @override
+    def scan(self, uuid) -> None:
         activated = True
         try:
             lvname = ''
@@ -686,7 +695,7 @@ class LVHDSR(SR.SR):
             # Now check if there are any VDIs in the metadata, which are not in
             # XAPI
             if self.mdexists:
-                vdiToSnaps = {}
+                vdiToSnaps: Dict[str, List[str]] = {}
                 # get VDIs from XAPI
                 vdis = self.session.xenapi.SR.get_VDIs(self.sr_ref)
                 vdi_uuids = set([])
@@ -813,7 +822,8 @@ class LVHDSR(SR.SR):
             if lvname != '' and activated:
                 self.lvmCache.deactivateNoRefcount(lvname)
 
-    def update(self, uuid):
+    @override
+    def update(self, uuid) -> None:
         if not lvutil._checkVG(self.vgname):
             return
         self._updateStats(uuid, 0)
@@ -842,15 +852,17 @@ class LVHDSR(SR.SR):
         self.physical_utilisation = stats['physical_utilisation']
         self._db_update()
 
+    @override
     @deviceCheck
-    def probe(self):
+    def probe(self) -> str:
         return lvutil.srlist_toxml(
                 lvutil.scan_srlist(lvhdutil.VG_PREFIX, self.dconf['device']),
                 lvhdutil.VG_PREFIX,
                 ('metadata' in self.srcmd.params['sr_sm_config'] and \
                  self.srcmd.params['sr_sm_config']['metadata'] == 'true'))
 
-    def vdi(self, uuid):
+    @override
+    def vdi(self, uuid) -> VDI.VDI:
         return LVHDVDI(self, uuid)
 
     def _loadvdis(self):
@@ -1307,12 +1319,13 @@ class LVHDSR(SR.SR):
         # Ensure we have space for at least one LV
         self._ensureSpaceAvailable(self.journaler.LV_SIZE)
 
-        
+
 class LVHDVDI(VDI.VDI):
 
     JRN_CLONE = "clone"  # journal entry type for the clone operation
 
-    def load(self, vdi_uuid):
+    @override
+    def load(self, vdi_uuid) -> None:
         self.lock = self.sr.lock
         self.lvActivator = self.sr.lvActivator
         self.loaded = False
@@ -1352,7 +1365,8 @@ class LVHDVDI(VDI.VDI):
         self.lvname = "%s%s" % (lvhdutil.LV_PREFIX[self.vdi_type], vdi_uuid)
         self.path = os.path.join(self.sr.path, self.lvname)
 
-    def create(self, sr_uuid, vdi_uuid, size):
+    @override
+    def create(self, sr_uuid, vdi_uuid, size) -> str:
         util.SMlog("LVHDVDI.create for %s" % self.uuid)
         if not self.sr.isMaster:
             raise xs_errors.XenError('LVMMaster')
@@ -1416,7 +1430,8 @@ class LVHDVDI(VDI.VDI):
 
         return VDI.VDI.get_params(self)
 
-    def delete(self, sr_uuid, vdi_uuid, data_only=False):
+    @override
+    def delete(self, sr_uuid, vdi_uuid, data_only=False) -> None:
         util.SMlog("LVHDVDI.delete for %s" % self.uuid)
         try:
             self._loadThis()
@@ -1461,7 +1476,8 @@ class LVHDVDI(VDI.VDI):
         self.sr._kickGC()
         return super(LVHDVDI, self).delete(sr_uuid, vdi_uuid, data_only)
 
-    def attach(self, sr_uuid, vdi_uuid):
+    @override
+    def attach(self, sr_uuid, vdi_uuid) -> str:
         util.SMlog("LVHDVDI.attach for %s" % self.uuid)
         if self.sr.journaler.hasJournals(self.uuid):
             raise xs_errors.XenError('VDIUnavailable',
@@ -1491,7 +1507,8 @@ class LVHDVDI(VDI.VDI):
             if not self.sr.lvActivator.deactivateAll():
                 util.SMlog("Failed to deactivate LVs back (%s)" % self.uuid)
 
-    def detach(self, sr_uuid, vdi_uuid):
+    @override
+    def detach(self, sr_uuid, vdi_uuid) -> None:
         util.SMlog("LVHDVDI.detach for %s" % self.uuid)
         self._loadThis()
         already_deflated = (self.utilisation < \
@@ -1522,7 +1539,8 @@ class LVHDVDI(VDI.VDI):
                 raise xs_errors.XenError("SMGeneral", opterr="deactivation")
 
     # We only support offline resize
-    def resize(self, sr_uuid, vdi_uuid, size):
+    @override
+    def resize(self, sr_uuid, vdi_uuid, size) -> str:
         util.SMlog("LVHDVDI.resize for %s" % self.uuid)
         if not self.sr.isMaster:
             raise xs_errors.XenError('LVMMaster')
@@ -1575,11 +1593,13 @@ class LVHDVDI(VDI.VDI):
         super(LVHDVDI, self).resize_cbt(self.sr.uuid, self.uuid, self.size)
         return VDI.VDI.get_params(self)
 
-    def clone(self, sr_uuid, vdi_uuid):
+    @override
+    def clone(self, sr_uuid, vdi_uuid) -> str:
         return self._do_snapshot(
                      sr_uuid, vdi_uuid, VDI.SNAPSHOT_DOUBLE, cloneOp=True)
 
-    def compose(self, sr_uuid, vdi1, vdi2):
+    @override
+    def compose(self, sr_uuid, vdi1, vdi2) -> None:
         util.SMlog("LVHDSR.compose for %s -> %s" % (vdi2, vdi1))
         if self.vdi_type != vhdutil.VDI_TYPE_VHD:
             raise xs_errors.XenError('Unimplemented')
@@ -1639,8 +1659,9 @@ class LVHDVDI(VDI.VDI):
         self._chainSetActive(False, True)
         self.attached = False
 
+    @override
     def _do_snapshot(self, sr_uuid, vdi_uuid, snapType,
-                     cloneOp=False, secondary=None, cbtlog=None):
+                     cloneOp=False, secondary=None, cbtlog=None) -> str:
         # If cbt enabled, save file consistency state
         if cbtlog is not None:
             if blktap2.VDI.tap_status(self.session, vdi_uuid):
@@ -2169,7 +2190,8 @@ class LVHDVDI(VDI.VDI):
             self.session.xenapi.SR.set_physical_utilisation(self.sr.sr_ref,
                     str(sr_utilisation))
 
-    def update(self, sr_uuid, vdi_uuid):
+    @override
+    def update(self, sr_uuid, vdi_uuid) -> None:
         if self.sr.legacyMode:
             return
 
@@ -2189,28 +2211,33 @@ class LVHDVDI(VDI.VDI):
             self.session.xenapi.VDI.get_metadata_of_pool(vdi_ref)
         LVMMetadataHandler(self.sr.mdpath).updateMetadata(update_map)
 
-    def _ensure_cbt_space(self):
+    @override
+    def _ensure_cbt_space(self) -> None:
         self.sr.ensureCBTSpace()
 
-    def _create_cbt_log(self):
+    @override
+    def _create_cbt_log(self) -> str:
         logname = self._get_cbt_logname(self.uuid)
         self.sr.lvmCache.create(logname, self.sr.journaler.LV_SIZE, CBTLOG_TAG)
         logpath = super(LVHDVDI, self)._create_cbt_log()
         self.sr.lvmCache.deactivateNoRefcount(logname)
         return logpath
 
-    def _delete_cbt_log(self):
+    @override
+    def _delete_cbt_log(self) -> None:
         logpath = self._get_cbt_logpath(self.uuid)
         if self._cbt_log_exists(logpath):
             logname = self._get_cbt_logname(self.uuid)
             self.sr.lvmCache.remove(logname)
 
-    def _rename(self, oldpath, newpath):
+    @override
+    def _rename(self, oldpath, newpath) -> None:
         oldname = os.path.basename(oldpath)
         newname = os.path.basename(newpath)
         self.sr.lvmCache.rename(oldname, newname)
 
-    def _activate_cbt_log(self, lv_name):
+    @override
+    def _activate_cbt_log(self, lv_name) -> bool:
         self.sr.lvmCache.refresh()
         if not self.sr.lvmCache.is_active(lv_name):
             try:
@@ -2223,14 +2250,16 @@ class LVHDVDI(VDI.VDI):
         else:
             return False
 
-    def _deactivate_cbt_log(self, lv_name):
+    @override
+    def _deactivate_cbt_log(self, lv_name) -> None:
         try:
             self.sr.lvmCache.deactivateNoRefcount(lv_name)
         except Exception as e:
             util.SMlog("Exception in _deactivate_cbt_log, Error: %s." % str(e))
             raise
 
-    def _cbt_log_exists(self, logpath):
+    @override
+    def _cbt_log_exists(self, logpath) -> bool:
         return lvutil.exists(logpath)
 
 if __name__ == '__main__':
diff --git a/drivers/LVHDoFCoESR.py b/drivers/LVHDoFCoESR.py
index 766d83f4..11bf298e 100755
--- a/drivers/LVHDoFCoESR.py
+++ b/drivers/LVHDoFCoESR.py
@@ -18,7 +18,10 @@
 # LVHDoFCoESR: LVHD over Fibre Channel over Ethernet driver
 #
 
+from sm_typing import override
+
 import SR
+import VDI
 import LVHDoHBASR
 import LVHDSR
 import SRCommand
@@ -54,7 +57,9 @@ class LVHDoFCoESR(LVHDoHBASR.LVHDoHBASR):
 
     """LVHD over FCoE storage repository"""
 
-    def handles(type):
+    @override
+    @staticmethod
+    def handles(type) -> bool:
         if __name__ == '__main__':
             name = sys.argv[0]
         else:
@@ -64,9 +69,9 @@ class LVHDoFCoESR(LVHDoHBASR.LVHDoHBASR):
         if type == "lvhdofcoe":
             return True
         return False
-    handles = staticmethod(handles)
 
-    def load(self, sr_uuid):
+    @override
+    def load(self, sr_uuid) -> None:
         driver = SR.driver('hba')
         if 'type' not in self.original_srcmd.params['device_config'] or \
                 'type' in self.original_srcmd.params['device_config'] and \
@@ -86,7 +91,8 @@ class LVHDoFCoESR(LVHDoHBASR.LVHDoHBASR):
         self.SCSIid = self.dconf['SCSIid']
         LVHDSR.LVHDSR.load(self, sr_uuid)
 
-    def vdi(self, uuid):
+    @override
+    def vdi(self, uuid) -> VDI.VDI:
         return LVHDoFCoEVDI(self, uuid)
 
 
diff --git a/drivers/LVHDoHBASR.py b/drivers/LVHDoHBASR.py
index 1eb8fb63..78451273 100755
--- a/drivers/LVHDoHBASR.py
+++ b/drivers/LVHDoHBASR.py
@@ -19,9 +19,12 @@
 # hardware based iSCSI
 #
 
+from sm_typing import override
+
 import SR
 import LVHDSR
 import SRCommand
+import VDI
 import lvutil
 import HBASR
 import os
@@ -58,7 +61,9 @@ DRIVER_INFO = {
 class LVHDoHBASR(LVHDSR.LVHDSR):
     """LVHD over HBA storage repository"""
 
-    def handles(type):
+    @override
+    @staticmethod
+    def handles(type) -> bool:
         if __name__ == '__main__':
             name = sys.argv[0]
         else:
@@ -68,9 +73,9 @@ class LVHDoHBASR(LVHDSR.LVHDSR):
         if type == "lvhdohba":
             return True
         return False
-    handles = staticmethod(handles)
 
-    def load(self, sr_uuid):
+    @override
+    def load(self, sr_uuid) -> None:
         driver = SR.driver('hba')
         self.hbasr = driver(self.original_srcmd, sr_uuid)
 
@@ -108,7 +113,8 @@ class LVHDoHBASR(LVHDSR.LVHDSR):
         self.SCSIid = self.dconf['SCSIid']
         super(LVHDoHBASR, self).load(sr_uuid)
 
-    def create(self, sr_uuid, size):
+    @override
+    def create(self, sr_uuid, size) -> None:
         self.hbasr.attach(sr_uuid)
         if self.mpath == "true":
             self.mpathmodule.refresh(self.SCSIid, 0)
@@ -121,7 +127,8 @@ class LVHDoHBASR(LVHDSR.LVHDSR):
                 util.remove_mpathcount_field(self.session, self.host_ref, \
                                              self.sr_ref, self.SCSIid)
 
-    def attach(self, sr_uuid):
+    @override
+    def attach(self, sr_uuid) -> None:
         self.hbasr.attach(sr_uuid)
         if self.mpath == "true":
             self.mpathmodule.refresh(self.SCSIid, 0)
@@ -140,7 +147,8 @@ class LVHDoHBASR(LVHDSR.LVHDSR):
         LVHDSR.LVHDSR.attach(self, sr_uuid)
         self._setMultipathableFlag(SCSIid=self.SCSIid)
 
-    def scan(self, sr_uuid):
+    @override
+    def scan(self, sr_uuid) -> None:
         # During a reboot, scan is called ahead of attach, which causes the MGT
         # to point of the wrong device instead of dm-x. Running multipathing will
         # take care of this scenario.
@@ -154,7 +162,8 @@ class LVHDoHBASR(LVHDSR.LVHDSR):
                 self._pathrefresh(LVHDoHBASR)
         LVHDSR.LVHDSR.scan(self, sr_uuid)
 
-    def probe(self):
+    @override
+    def probe(self) -> str:
         if self.mpath == "true" and 'SCSIid' in self.dconf:
         # When multipathing is enabled, since we don't refcount the multipath maps,
         # we should not attempt to do the iscsi.attach/detach when the map is already present,
@@ -181,7 +190,8 @@ class LVHDoHBASR(LVHDSR.LVHDSR):
                 self.mpathmodule.reset(self.SCSIid, explicit_unmap=True)
             raise
 
-    def detach(self, sr_uuid):
+    @override
+    def detach(self, sr_uuid) -> None:
         LVHDSR.LVHDSR.detach(self, sr_uuid)
         self.mpathmodule.reset(self.SCSIid, explicit_unmap=True)
         try:
@@ -205,7 +215,8 @@ class LVHDoHBASR(LVHDSR.LVHDSR):
                       (os.path.basename(node)), 'w') as f:
                 f.write('1\n')
 
-    def delete(self, sr_uuid):
+    @override
+    def delete(self, sr_uuid) -> None:
         self._pathrefresh(LVHDoHBASR)
         try:
             LVHDSR.LVHDSR.delete(self, sr_uuid)
@@ -214,12 +225,14 @@ class LVHDoHBASR(LVHDSR.LVHDSR):
                 self.mpathmodule.reset(self.SCSIid, explicit_unmap=True)
             self._remove_device_nodes()
 
-    def vdi(self, uuid):
+    @override
+    def vdi(self, uuid) -> VDI.VDI:
         return LVHDoHBAVDI(self, uuid)
 
 
 class LVHDoHBAVDI(LVHDSR.LVHDVDI):
-    def generate_config(self, sr_uuid, vdi_uuid):
+    @override
+    def generate_config(self, sr_uuid, vdi_uuid) -> str:
         util.SMlog("LVHDoHBAVDI.generate_config")
         if not lvutil._checkLV(self.path):
             raise xs_errors.XenError('VDIUnavailable')
@@ -235,7 +248,8 @@ class LVHDoHBAVDI(LVHDSR.LVHDVDI):
         config = xmlrpc.client.dumps(tuple([dict]), "vdi_attach_from_config")
         return xmlrpc.client.dumps((config, ), "", True)
 
-    def attach_from_config(self, sr_uuid, vdi_uuid):
+    @override
+    def attach_from_config(self, sr_uuid, vdi_uuid) -> str:
         util.SMlog("LVHDoHBAVDI.attach_from_config")
         self.sr.hbasr.attach(sr_uuid)
         if self.sr.mpath == "true":
diff --git a/drivers/LVHDoISCSISR.py b/drivers/LVHDoISCSISR.py
index 442ec30f..799e89d6 100755
--- a/drivers/LVHDoISCSISR.py
+++ b/drivers/LVHDoISCSISR.py
@@ -18,7 +18,10 @@
 # LVHDoISCSISR: LVHD over ISCSI software initiator SR driver
 #
 
+from sm_typing import override
+
 import SR
+import VDI
 import LVHDSR
 import BaseISCSI
 import SRCommand
@@ -71,7 +74,9 @@ DRIVER_INFO = {
 class LVHDoISCSISR(LVHDSR.LVHDSR):
     """LVHD over ISCSI storage repository"""
 
-    def handles(type):
+    @override
+    @staticmethod
+    def handles(type) -> bool:
         if __name__ == '__main__':
             name = sys.argv[0]
         else:
@@ -81,9 +86,9 @@ class LVHDoISCSISR(LVHDSR.LVHDSR):
         if type == "lvhdoiscsi":
             return True
         return False
-    handles = staticmethod(handles)
 
-    def load(self, sr_uuid):
+    @override
+    def load(self, sr_uuid) -> None:
         if not sr_uuid:
             # This is a probe call, generate a temp sr_uuid
             sr_uuid = util.gen_uuid()
@@ -426,7 +431,8 @@ class LVHDoISCSISR(LVHDSR.LVHDSR):
         self.iscsi.print_LUNs()
         self.iscsi.detach(sr_uuid)
 
-    def create(self, sr_uuid, size):
+    @override
+    def create(self, sr_uuid, size) -> None:
         # Check SCSIid not already in use by other PBDs
         if util.test_SCSIid(self.session, sr_uuid, self.SCSIid):
             raise xs_errors.XenError('SRInUse')
@@ -441,13 +447,15 @@ class LVHDoISCSISR(LVHDSR.LVHDSR):
             raise xs_errors.XenError("SRUnavailable", opterr=inst)
         self.iscsi.detach(sr_uuid)
 
-    def delete(self, sr_uuid):
+    @override
+    def delete(self, sr_uuid) -> None:
         self._pathrefresh(LVHDoISCSISR)
         LVHDSR.LVHDSR.delete(self, sr_uuid)
         for i in self.iscsiSRs:
             i.detach(sr_uuid)
 
-    def attach(self, sr_uuid):
+    @override
+    def attach(self, sr_uuid) -> None:
         try:
             connected = False
             stored_exception = None
@@ -485,12 +493,14 @@ class LVHDoISCSISR(LVHDSR.LVHDSR):
             raise xs_errors.XenError("SRUnavailable", opterr=inst)
         self._setMultipathableFlag(SCSIid=self.SCSIid)
 
-    def detach(self, sr_uuid):
+    @override
+    def detach(self, sr_uuid) -> None:
         LVHDSR.LVHDSR.detach(self, sr_uuid)
         for i in self.iscsiSRs:
             i.detach(sr_uuid)
 
-    def scan(self, sr_uuid):
+    @override
+    def scan(self, sr_uuid) -> None:
         self._pathrefresh(LVHDoISCSISR)
         if self.mpath == "true":
             for i in self.iscsiSRs:
@@ -500,7 +510,8 @@ class LVHDoISCSISR(LVHDSR.LVHDSR):
                     util.SMlog("Connection failed for target %s, continuing.." % i.target)
         LVHDSR.LVHDSR.scan(self, sr_uuid)
 
-    def probe(self):
+    @override
+    def probe(self) -> str:
         self.uuid = util.gen_uuid()
 
         # When multipathing is enabled, since we don't refcount the multipath maps,
@@ -523,7 +534,8 @@ class LVHDoISCSISR(LVHDSR.LVHDSR):
         self.iscsi.detach(self.uuid)
         return out
 
-    def check_sr(self, sr_uuid):
+    @override
+    def check_sr(self, sr_uuid) -> None:
         """Hook to check SR health"""
         pbdref = util.find_my_pbd(self.session, self.host_ref, self.sr_ref)
         if pbdref:
@@ -536,12 +548,14 @@ class LVHDoISCSISR(LVHDSR.LVHDSR):
                         except xs_errors.SROSError:
                             util.SMlog("Failed to attach iSCSI target")
 
-    def vdi(self, uuid):
+    @override
+    def vdi(self, uuid) -> VDI.VDI:
         return LVHDoISCSIVDI(self, uuid)
 
 
 class LVHDoISCSIVDI(LVHDSR.LVHDVDI):
-    def generate_config(self, sr_uuid, vdi_uuid):
+    @override
+    def generate_config(self, sr_uuid, vdi_uuid) -> str:
         util.SMlog("LVHDoISCSIVDI.generate_config")
         if not lvutil._checkLV(self.path):
             raise xs_errors.XenError('VDIUnavailable')
@@ -562,7 +576,8 @@ class LVHDoISCSIVDI(LVHDSR.LVHDVDI):
         config = xmlrpc.client.dumps(tuple([dict]), "vdi_attach_from_config")
         return xmlrpc.client.dumps((config, ), "", True)
 
-    def attach_from_config(self, sr_uuid, vdi_uuid):
+    @override
+    def attach_from_config(self, sr_uuid, vdi_uuid) -> str:
         util.SMlog("LVHDoISCSIVDI.attach_from_config")
         try:
             self.sr.iscsi.attach(sr_uuid)
diff --git a/drivers/LargeBlockSR.py b/drivers/LargeBlockSR.py
index ba0ac1d1..fa66cfce 100644
--- a/drivers/LargeBlockSR.py
+++ b/drivers/LargeBlockSR.py
@@ -14,6 +14,8 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
+from sm_typing import override
+
 import SR
 from SR import deviceCheck
 import SRCommand
@@ -52,17 +54,20 @@ class LargeBlockSR(EXTSR.EXTSR):
     DRIVER_TYPE = "largeblock"
     LOOP_SECTOR_SIZE = 512
 
+    @override
     @staticmethod
-    def handles(srtype):
+    def handles(srtype) -> bool:
         return srtype == LargeBlockSR.DRIVER_TYPE
 
-    def load(self, sr_uuid):
+    @override
+    def load(self, sr_uuid) -> None:
         super(LargeBlockSR, self).load(sr_uuid)
         self.is_deleting = False
         self.vgname = LARGEBLOCK_PREFIX + sr_uuid
         self.remotepath = os.path.join("/dev", self.vgname, sr_uuid)
 
-    def attach(self, sr_uuid):
+    @override
+    def attach(self, sr_uuid) -> None:
         if not self.is_deleting:
             vg_device = self._get_device()
             self.dconf["device"] = ",".join(vg_device)
@@ -71,7 +76,8 @@ class LargeBlockSR(EXTSR.EXTSR):
                 self._redo_vg_connection() # Call redo VG connection to connect it correctly to the loop device instead of the real 4KiB block device
         super(LargeBlockSR, self).attach(sr_uuid)
 
-    def detach(self, sr_uuid):
+    @override
+    def detach(self, sr_uuid) -> None:
         if not self.is_deleting:
             vg_device = self._get_device()
             self.dconf["device"] = ",".join(vg_device)
@@ -79,8 +85,9 @@ class LargeBlockSR(EXTSR.EXTSR):
         if not self.is_deleting:
             self._destroy_emulated_device()
 
+    @override
     @deviceCheck
-    def create(self, sr_uuid, size):
+    def create(self, sr_uuid, size) -> None:
         base_devices = self.dconf["device"].split(",")
         if len(base_devices) > 1:
             raise xs_errors.XenError("ConfigDeviceInvalid", opterr="Multiple devices configuration is not supported")
@@ -96,7 +103,8 @@ class LargeBlockSR(EXTSR.EXTSR):
         finally:
             self._destroy_emulated_device(base_devices)
 
-    def delete(self, sr_uuid):
+    @override
+    def delete(self, sr_uuid) -> None:
         base_devices = self._get_device()
         self.dconf["device"] = ",".join(self._get_loopdev_from_device(base_devices))
 
@@ -112,8 +120,9 @@ class LargeBlockSR(EXTSR.EXTSR):
             self._destroy_emulated_device(base_devices)
             self.is_deleting = False
 
+    @override
     @deviceCheck
-    def probe(self):
+    def probe(self) -> str:
         # We override EXTSR.probe because it uses EXT_PREFIX in this call
         return lvutil.srlist_toxml(
             lvutil.scan_srlist(LARGEBLOCK_PREFIX, self.dconf['device']),
diff --git a/drivers/LinstorSR.py b/drivers/LinstorSR.py
index 22c1b37e..459ed420 100755
--- a/drivers/LinstorSR.py
+++ b/drivers/LinstorSR.py
@@ -14,6 +14,8 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
+from sm_typing import Optional, override
+
 from constants import CBTLOG_TAG
 
 try:
@@ -302,11 +304,13 @@ class LinstorSR(SR.SR):
     # SR methods.
     # --------------------------------------------------------------------------
 
+    @override
     @staticmethod
-    def handles(type):
+    def handles(type) -> bool:
         return type == LinstorSR.DRIVER_TYPE
 
-    def load(self, sr_uuid):
+    @override
+    def load(self, sr_uuid) -> None:
         if not LINSTOR_AVAILABLE:
             raise util.SMException(
                 'Can\'t load LinstorSR: LINSTOR libraries are missing'
@@ -541,12 +545,14 @@ class LinstorSR(SR.SR):
 
         return wrap
 
-    def cleanup(self):
+    @override
+    def cleanup(self) -> None:
         if self._vdi_shared_time:
             self._shared_lock_vdi(self.srcmd.params['vdi_uuid'], locked=False)
 
+    @override
     @_locked_load
-    def create(self, uuid, size):
+    def create(self, uuid, size) -> None:
         util.SMlog('LinstorSR.create for {}'.format(self.uuid))
 
         host_adresses = util.get_host_addresses(self.session)
@@ -635,8 +641,9 @@ class LinstorSR(SR.SR):
                 )
             raise e
 
+    @override
     @_locked_load
-    def delete(self, uuid):
+    def delete(self, uuid) -> None:
         util.SMlog('LinstorSR.delete for {}'.format(self.uuid))
         cleanup.gc_force(self.session, self.uuid)
 
@@ -698,8 +705,9 @@ class LinstorSR(SR.SR):
 
         Lock.cleanupAll(self.uuid)
 
+    @override
     @_locked_load
-    def update(self, uuid):
+    def update(self, uuid) -> None:
         util.SMlog('LinstorSR.update for {}'.format(self.uuid))
 
         # Well, how can we update a SR if it doesn't exist? :thinking:
@@ -722,8 +730,9 @@ class LinstorSR(SR.SR):
             )
         }
 
+    @override
     @_locked_load
-    def attach(self, uuid):
+    def attach(self, uuid) -> None:
         util.SMlog('LinstorSR.attach for {}'.format(self.uuid))
 
         if not self._linstor:
@@ -732,18 +741,22 @@ class LinstorSR(SR.SR):
                 opterr='no such group: {}'.format(self._group_name)
             )
 
+    @override
     @_locked_load
-    def detach(self, uuid):
+    def detach(self, uuid) -> None:
         util.SMlog('LinstorSR.detach for {}'.format(self.uuid))
         cleanup.abort(self.uuid)
 
+    @override
     @_locked_load
-    def probe(self):
+    def probe(self) -> str:
         util.SMlog('LinstorSR.probe for {}'.format(self.uuid))
         # TODO
+        return ''
 
+    @override
     @_locked_load
-    def scan(self, uuid):
+    def scan(self, uuid) -> None:
         if self._init_status == self.INIT_STATUS_FAIL:
             return
 
@@ -792,8 +805,9 @@ class LinstorSR(SR.SR):
 
         return self._is_master
 
+    @override
     @_locked_load
-    def vdi(self, uuid):
+    def vdi(self, uuid) -> VDI.VDI:
         return LinstorVDI(self, uuid)
 
     # To remove in python 3.10
@@ -1565,7 +1579,8 @@ class LinstorVDI(VDI.VDI):
     # VDI methods.
     # --------------------------------------------------------------------------
 
-    def load(self, vdi_uuid):
+    @override
+    def load(self, vdi_uuid) -> None:
         self._lock = self.sr.lock
         self._exists = True
         self._linstor = self.sr._linstor
@@ -1636,7 +1651,8 @@ class LinstorVDI(VDI.VDI):
         except Exception as e:
             raise_bad_load(e)
 
-    def create(self, sr_uuid, vdi_uuid, size):
+    @override
+    def create(self, sr_uuid, vdi_uuid, size) -> str:
         # Usage example:
         # xe vdi-create sr-uuid=39a5826b-5a90-73eb-dd09-51e3a116f937
         # name-label="linstor-vdi-1" virtual-size=4096MiB sm-config:type=vhd
@@ -1744,7 +1760,8 @@ class LinstorVDI(VDI.VDI):
 
         return VDI.VDI.get_params(self)
 
-    def delete(self, sr_uuid, vdi_uuid, data_only=False):
+    @override
+    def delete(self, sr_uuid, vdi_uuid, data_only=False) -> None:
         util.SMlog('LinstorVDI.delete for {}'.format(self.uuid))
         if self.attached:
             raise xs_errors.XenError('VDIInUse')
@@ -1790,7 +1807,8 @@ class LinstorVDI(VDI.VDI):
         self.sr._kick_gc()
         return super(LinstorVDI, self).delete(sr_uuid, vdi_uuid, data_only)
 
-    def attach(self, sr_uuid, vdi_uuid):
+    @override
+    def attach(self, sr_uuid, vdi_uuid) -> str:
         util.SMlog('LinstorVDI.attach for {}'.format(self.uuid))
         attach_from_config = self.sr.srcmd.cmd == 'vdi_attach_from_config'
         if (
@@ -1845,7 +1863,8 @@ class LinstorVDI(VDI.VDI):
         self.attached = True
         return VDI.VDI.attach(self, self.sr.uuid, self.uuid)
 
-    def detach(self, sr_uuid, vdi_uuid):
+    @override
+    def detach(self, sr_uuid, vdi_uuid) -> None:
         util.SMlog('LinstorVDI.detach for {}'.format(self.uuid))
         detach_from_config = self.sr.srcmd.cmd == 'vdi_detach_from_config'
         self.attached = False
@@ -1907,7 +1926,8 @@ class LinstorVDI(VDI.VDI):
                     util.SMlog('Failed to clean VDI {} during detach: {}'.format(vdi_uuid, e))
             vdi_uuid = parent_vdi_uuid
 
-    def resize(self, sr_uuid, vdi_uuid, size):
+    @override
+    def resize(self, sr_uuid, vdi_uuid, size) -> str:
         util.SMlog('LinstorVDI.resize for {}'.format(self.uuid))
         if not self.sr.is_master():
             raise xs_errors.XenError(
@@ -1973,10 +1993,12 @@ class LinstorVDI(VDI.VDI):
         self.sr._update_stats(self.size - old_size)
         return VDI.VDI.get_params(self)
 
-    def clone(self, sr_uuid, vdi_uuid):
+    @override
+    def clone(self, sr_uuid, vdi_uuid) -> str:
         return self._do_snapshot(sr_uuid, vdi_uuid, VDI.SNAPSHOT_DOUBLE)
 
-    def compose(self, sr_uuid, vdi1, vdi2):
+    @override
+    def compose(self, sr_uuid, vdi1, vdi2) -> None:
         util.SMlog('VDI.compose for {} -> {}'.format(vdi2, vdi1))
         if self.vdi_type != vhdutil.VDI_TYPE_VHD:
             raise xs_errors.XenError('Unimplemented')
@@ -2007,7 +2029,8 @@ class LinstorVDI(VDI.VDI):
 
         util.SMlog('Compose done')
 
-    def generate_config(self, sr_uuid, vdi_uuid):
+    @override
+    def generate_config(self, sr_uuid, vdi_uuid) -> str:
         """
         Generate the XML config required to attach and activate
         a VDI for use when XAPI is not running. Attach and
@@ -2053,7 +2076,8 @@ class LinstorVDI(VDI.VDI):
         config = xmlrpc.client.dumps(tuple([resp]), 'vdi_attach_from_config')
         return xmlrpc.client.dumps((config,), "", True)
 
-    def attach_from_config(self, sr_uuid, vdi_uuid):
+    @override
+    def attach_from_config(self, sr_uuid, vdi_uuid) -> str:
         """
         Attach and activate a VDI using config generated by
         vdi_generate_config above. This is used for cases such as
@@ -2074,6 +2098,7 @@ class LinstorVDI(VDI.VDI):
                 'SRUnavailable',
                 opterr='Unable to attach from config'
             )
+        return ''
 
     def reset_leaf(self, sr_uuid, vdi_uuid):
         if self.vdi_type != vhdutil.VDI_TYPE_VHD:
@@ -2140,7 +2165,8 @@ class LinstorVDI(VDI.VDI):
             })
         self.hidden = hidden
 
-    def update(self, sr_uuid, vdi_uuid):
+    @override
+    def update(self, sr_uuid, vdi_uuid) -> None:
         xenapi = self.session.xenapi
         vdi_ref = xenapi.VDI.get_by_uuid(self.uuid)
 
@@ -2316,13 +2342,15 @@ class LinstorVDI(VDI.VDI):
     # Implement specific SR methods.
     # --------------------------------------------------------------------------
 
-    def _rename(self, oldpath, newpath):
+    @override
+    def _rename(self, oldpath, newpath) -> None:
         # TODO: I'm not sure... Used by CBT.
         volume_uuid = self._linstor.get_volume_uuid_from_device_path(oldpath)
         self._linstor.update_volume_name(volume_uuid, newpath)
 
+    @override
     def _do_snapshot(self, sr_uuid, vdi_uuid, snapType,
-                     cloneOp=False, secondary=None, cbtlog=None):
+                     cloneOp=False, secondary=None, cbtlog=None) -> str:
         # If cbt enabled, save file consistency state.
         if cbtlog is not None:
             if blktap2.VDI.tap_status(self.session, vdi_uuid):
diff --git a/drivers/MooseFSSR.py b/drivers/MooseFSSR.py
index 8fc4a4ad..4ebd7bd8 100755
--- a/drivers/MooseFSSR.py
+++ b/drivers/MooseFSSR.py
@@ -18,6 +18,8 @@
 #
 # MooseFSSR: Based on CEPHFSSR and FileSR, mounts MooseFS share
 
+from sm_typing import override
+
 import errno
 import os
 import syslog as _syslog
@@ -32,6 +34,7 @@ import SR
 import SRCommand
 import FileSR
 # end of careful
+import VDI
 import cleanup
 import util
 import vhdutil
@@ -79,13 +82,14 @@ class MooseFSSR(FileSR.FileSR):
 
     DRIVER_TYPE = 'moosefs'
 
-    def handles(sr_type):
+    @override
+    @staticmethod
+    def handles(sr_type) -> bool:
         # fudge, because the parent class (FileSR) checks for smb to alter its behavior
         return sr_type == MooseFSSR.DRIVER_TYPE or sr_type == 'smb'
 
-    handles = staticmethod(handles)
-
-    def load(self, sr_uuid):
+    @override
+    def load(self, sr_uuid) -> None:
         if not self._is_moosefs_available():
             raise xs_errors.XenError(
                 'SRUnavailable',
@@ -176,7 +180,8 @@ class MooseFSSR(FileSR.FileSR):
             except OSError as inst:
                 raise MooseFSException("Command rmdir failed with error '%s'" % inst.strerror)
 
-    def attach(self, sr_uuid):
+    @override
+    def attach(self, sr_uuid) -> None:
         if not self.checkmount():
             try:
                 self.mount()
@@ -184,7 +189,8 @@ class MooseFSSR(FileSR.FileSR):
                 raise xs_errors.SROSError(12, exc.errstr)
         self.attached = True
 
-    def probe(self):
+    @override
+    def probe(self) -> str:
         try:
             self.mount(PROBE_MOUNTPOINT)
             sr_list = filter(util.match_uuid, util.listdir(PROBE_MOUNTPOINT))
@@ -194,7 +200,8 @@ class MooseFSSR(FileSR.FileSR):
         # Create a dictionary from the SR uuids to feed SRtoXML()
         return util.SRtoXML({sr_uuid: {} for sr_uuid in sr_list})
 
-    def detach(self, sr_uuid):
+    @override
+    def detach(self, sr_uuid) -> None:
         if not self.checkmount():
             return
         util.SMlog("Aborting GC/coalesce")
@@ -204,7 +211,8 @@ class MooseFSSR(FileSR.FileSR):
         self.unmount(self.mountpoint, True)
         self.attached = False
 
-    def create(self, sr_uuid, size):
+    @override
+    def create(self, sr_uuid, size) -> None:
         if self.checkmount():
             raise xs_errors.SROSError(113, 'MooseFS mount point already attached')
 
@@ -248,7 +256,8 @@ class MooseFSSR(FileSR.FileSR):
         finally:
             self.detach(sr_uuid)
 
-    def delete(self, sr_uuid):
+    @override
+    def delete(self, sr_uuid) -> None:
         # try to remove/delete non VDI contents first
         super(MooseFSSR, self).delete(sr_uuid)
         try:
@@ -268,7 +277,8 @@ class MooseFSSR(FileSR.FileSR):
             if inst.code != errno.ENOENT:
                 raise xs_errors.SROSError(114, "Failed to remove MooseFS mount point")
 
-    def vdi(self, uuid, loadLocked=False):
+    @override
+    def vdi(self, uuid, loadLocked=False) -> VDI.VDI:
         return MooseFSFileVDI(self, uuid)
 
     @staticmethod
@@ -276,7 +286,8 @@ class MooseFSSR(FileSR.FileSR):
         return util.find_executable('mfsmount')
 
 class MooseFSFileVDI(FileSR.FileVDI):
-    def attach(self, sr_uuid, vdi_uuid):
+    @override
+    def attach(self, sr_uuid, vdi_uuid) -> str:
         if not hasattr(self, 'xenstore_data'):
             self.xenstore_data = {}
 
@@ -284,7 +295,8 @@ class MooseFSFileVDI(FileSR.FileVDI):
 
         return super(MooseFSFileVDI, self).attach(sr_uuid, vdi_uuid)
 
-    def generate_config(self, sr_uuid, vdi_uuid):
+    @override
+    def generate_config(self, sr_uuid, vdi_uuid) -> str:
         util.SMlog("MooseFSFileVDI.generate_config")
         if not util.pathexists(self.path):
             raise xs_errors.XenError('VDIUnavailable')
@@ -298,15 +310,16 @@ class MooseFSFileVDI(FileSR.FileVDI):
         config = xmlrpc.client.dumps(tuple([resp]), "vdi_attach_from_config")
         return xmlrpc.client.dumps((config,), "", True)
 
-    def attach_from_config(self, sr_uuid, vdi_uuid):
+    @override
+    def attach_from_config(self, sr_uuid, vdi_uuid) -> str:
         try:
             if not util.pathexists(self.sr.path):
-                self.sr.attach(sr_uuid)
+                return self.sr.attach(sr_uuid)
         except:
             util.logException("MooseFSFileVDI.attach_from_config")
             raise xs_errors.XenError('SRUnavailable',
                                      opterr='Unable to attach from config')
-
+        return ''
 
 if __name__ == '__main__':
     SRCommand.run(MooseFSSR, DRIVER_INFO)
diff --git a/drivers/NFSSR.py b/drivers/NFSSR.py
index ef73e1b4..6eeedeb7 100755
--- a/drivers/NFSSR.py
+++ b/drivers/NFSSR.py
@@ -17,9 +17,12 @@
 #
 # FileSR: local-file storage repository
 
+from sm_typing import override
+
 import socket
 
 import SR
+import VDI
 import SRCommand
 import FileSR
 import util
@@ -68,11 +71,13 @@ PROBEVERSION = 'probeversion'
 class NFSSR(FileSR.SharedFileSR):
     """NFS file-based storage repository"""
 
-    def handles(type):
+    @override
+    @staticmethod
+    def handles(type) -> bool:
         return type == 'nfs'
-    handles = staticmethod(handles)
 
-    def load(self, sr_uuid):
+    @override
+    def load(self, sr_uuid) -> None:
         self.ops_exclusive = FileSR.OPS_EXCLUSIVE
         self.lock = Lock(vhdutil.LOCK_TYPE_SR, self.uuid)
         self.sr_vditype = SR.DEFAULT_TAP
@@ -137,7 +142,8 @@ class NFSSR(FileSR.SharedFileSR):
         except nfs.NfsException as exc:
             raise xs_errors.XenError('NFSMount', opterr=exc.errstr)
 
-    def attach(self, sr_uuid):
+    @override
+    def attach(self, sr_uuid) -> None:
         if not self._checkmount():
             try:
                 self.validate_remotepath(False)
@@ -164,7 +170,8 @@ class NFSSR(FileSR.SharedFileSR):
             self.mount(self.path, self.remotepath,
                        timeout=io_timeout, retrans=io_retrans)
 
-    def probe(self):
+    @override
+    def probe(self) -> str:
         # Verify NFS target and port
         util._testHost(self.dconf['server'], NFSPORT, 'NFSTarget')
 
@@ -182,7 +189,8 @@ class NFSSR(FileSR.SharedFileSR):
             except:
                 pass
 
-    def detach(self, sr_uuid):
+    @override
+    def detach(self, sr_uuid) -> None:
         """Detach the SR: Unmounts and removes the mountpoint"""
         if not self._checkmount():
             return
@@ -199,7 +207,8 @@ class NFSSR(FileSR.SharedFileSR):
 
         self.attached = False
 
-    def create(self, sr_uuid, size):
+    @override
+    def create(self, sr_uuid, size) -> None:
         util._testHost(self.dconf['server'], NFSPORT, 'NFSTarget')
         self.validate_remotepath(True)
         if self._checkmount():
@@ -239,7 +248,8 @@ class NFSSR(FileSR.SharedFileSR):
                                 % inst.code)
         self.detach(sr_uuid)
 
-    def delete(self, sr_uuid):
+    @override
+    def delete(self, sr_uuid) -> None:
         # try to remove/delete non VDI contents first
         super(NFSSR, self).delete(sr_uuid)
         try:
@@ -260,7 +270,8 @@ class NFSSR(FileSR.SharedFileSR):
             if inst.code != errno.ENOENT:
                 raise xs_errors.XenError('NFSDelete')
 
-    def vdi(self, uuid):
+    @override
+    def vdi(self, uuid) -> VDI.VDI:
         return NFSFileVDI(self, uuid)
 
     def scan_exports(self, target):
@@ -287,7 +298,8 @@ class NFSSR(FileSR.SharedFileSR):
 
 
 class NFSFileVDI(FileSR.FileVDI):
-    def attach(self, sr_uuid, vdi_uuid):
+    @override
+    def attach(self, sr_uuid, vdi_uuid) -> str:
         if not hasattr(self, 'xenstore_data'):
             self.xenstore_data = {}
 
@@ -295,7 +307,8 @@ class NFSFileVDI(FileSR.FileVDI):
 
         return super(NFSFileVDI, self).attach(sr_uuid, vdi_uuid)
 
-    def generate_config(self, sr_uuid, vdi_uuid):
+    @override
+    def generate_config(self, sr_uuid, vdi_uuid) -> str:
         util.SMlog("NFSFileVDI.generate_config")
         if not util.pathexists(self.path):
             raise xs_errors.XenError('VDIUnavailable')
@@ -311,12 +324,13 @@ class NFSFileVDI(FileSR.FileVDI):
         config = xmlrpc.client.dumps(tuple([resp]), "vdi_attach_from_config")
         return xmlrpc.client.dumps((config, ), "", True)
 
-    def attach_from_config(self, sr_uuid, vdi_uuid):
+    @override
+    def attach_from_config(self, sr_uuid, vdi_uuid) -> str:
         """Used for HA State-file only. Will not just attach the VDI but
         also start a tapdisk on the file"""
         util.SMlog("NFSFileVDI.attach_from_config")
         try:
-            self.sr.attach(sr_uuid)
+            return self.sr.attach(sr_uuid)
         except:
             util.logException("NFSFileVDI.attach_from_config")
             raise xs_errors.XenError('SRUnavailable', \
diff --git a/drivers/RawISCSISR.py b/drivers/RawISCSISR.py
index 1df1c7a2..a4848a88 100644
--- a/drivers/RawISCSISR.py
+++ b/drivers/RawISCSISR.py
@@ -18,8 +18,11 @@
 # ISCSISR: ISCSI software initiator SR driver
 #
 
+from sm_typing import override
+
 import SR
 import SRCommand
+import VDI
 import BaseISCSI
 import LUNperVDI
 import util
@@ -53,25 +56,30 @@ DRIVER_INFO = {
 class RawISCSISR(BaseISCSI.BaseISCSISR):
     """Raw ISCSI storage repository"""
 
-    def handles(type):
+    @override
+    @staticmethod
+    def handles(type) -> bool:
         if type == "iscsi":
             return True
         return False
-    handles = staticmethod(handles)
 
-    def load(self, vdi_uuid):
+    @override
+    def load(self, vdi_uuid) -> None:
         super(RawISCSISR, self).load(vdi_uuid)
         self.managed = True
 
-    def detach(self, sr_uuid):
+    @override
+    def detach(self, sr_uuid) -> None:
         super(RawISCSISR, self).detach_and_delete(sr_uuid)
 
-    def vdi(self, uuid):
+    @override
+    def vdi(self, uuid) -> VDI.VDI:
         return ISCSIVDI(self, uuid)
 
 
 class ISCSIVDI(LUNperVDI.RAWVDI):
-    def load(self, vdi_uuid):
+    @override
+    def load(self, vdi_uuid) -> None:
         super(ISCSIVDI, self).load(vdi_uuid)
         self.managed = True
 
diff --git a/drivers/SHMSR.py b/drivers/SHMSR.py
index 5e3ef7f4..250d5813 100644
--- a/drivers/SHMSR.py
+++ b/drivers/SHMSR.py
@@ -15,6 +15,8 @@
 # along with this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 
+from sm_typing import override
+
 import SR
 import VDI
 import SRCommand
@@ -54,25 +56,29 @@ class SHMSR(SR.SR):
         except:
             pass
 
-    def handles(type):
+    @override
+    @staticmethod
+    def handles(type) -> bool:
         """Do we handle this type?"""
         if type == TYPE:
             return True
         return False
-    handles = staticmethod(handles)
 
-    def content_type(self, sr_uuid):
+    @override
+    def content_type(self, sr_uuid) -> str:
         """Returns the content_type XML"""
         return super(SHMSR, self).content_type(sr_uuid)
 
-    def vdi(self, uuid):
+    @override
+    def vdi(self, uuid) -> VDI.VDI:
         """Create a VDI class"""
         if 'vdi_location' in self.srcmd.params:
             return SHMVDI(self, uuid, self.srcmd.params['vdi_location'])
         else:
             return SHMVDI(self, uuid, self.srcmd.params['device_config']['location'])
 
-    def load(self, sr_uuid):
+    @override
+    def load(self, sr_uuid) -> None:
         """Initialises the SR"""
         if 'location' not in self.dconf:
             raise xs_errors.XenError('ConfigLocationMissing')
@@ -82,26 +88,31 @@ class SHMSR(SR.SR):
         self.physical_utilisation = 0
         self.virtual_allocation = 0
 
-    def attach(self, sr_uuid):
+    @override
+    def attach(self, sr_uuid) -> None:
         """Std. attach"""
         self._loadvdis()
 
-    def detach(self, sr_uuid):
+    @override
+    def detach(self, sr_uuid) -> None:
         """Std. detach"""
         pass
 
-    def scan(self, sr_uuid):
+    @override
+    def scan(self, sr_uuid) -> None:
         """Scan"""
         self._loadvdis()
-        return super(SHMSR, self).scan(sr_uuid)
+        super(SHMSR, self).scan(sr_uuid)
 
-    def create(self, sr_uuid, size):
+    @override
+    def create(self, sr_uuid, size) -> None:
         self.attach(sr_uuid)
         self.detach(sr_uuid)
 
 
 class SHMVDI(VDI.VDI):
-    def load(self, vdi_uuid):
+    @override
+    def load(self, vdi_uuid) -> None:
         try:
             stat = os.stat(self.path)
             self.utilisation = int(stat.st_size)
@@ -120,13 +131,16 @@ class SHMVDI(VDI.VDI):
         self.shareable = True
         self.sm_config = {}
 
-    def detach(self, sr_uuid, vdi_uuid):
+    @override
+    def detach(self, sr_uuid, vdi_uuid) -> None:
         pass
 
-    def clone(self, sr_uuid, vdi_uuid):
+    @override
+    def clone(self, sr_uuid, vdi_uuid) -> str:
         return self.get_params()
 
-    def snapshot(self, sr_uuid, vdi_uuid):
+    @override
+    def snapshot(self, sr_uuid, vdi_uuid) -> str:
         return self.get_params()
 
 if __name__ == '__main__':
diff --git a/drivers/SMBSR.py b/drivers/SMBSR.py
index 962060cd..34ba40d6 100755
--- a/drivers/SMBSR.py
+++ b/drivers/SMBSR.py
@@ -17,8 +17,11 @@
 #
 # SMBSR: SMB filesystem based storage repository
 
+from sm_typing import override
+
 import SR
 import SRCommand
+import VDI
 import FileSR
 import util
 import errno
@@ -71,11 +74,13 @@ class SMBException(Exception):
 class SMBSR(FileSR.SharedFileSR):
     """SMB file-based storage repository"""
 
-    def handles(type):
+    @override
+    @staticmethod
+    def handles(type) -> bool:
         return type == 'smb'
-    handles = staticmethod(handles)
 
-    def load(self, sr_uuid):
+    @override
+    def load(self, sr_uuid) -> None:
         self.ops_exclusive = FileSR.OPS_EXCLUSIVE
         self.lock = Lock(vhdutil.LOCK_TYPE_SR, self.uuid)
         self.sr_vditype = SR.DEFAULT_TAP
@@ -190,7 +195,8 @@ class SMBSR(FileSR.SharedFileSR):
                 restrictions['restrict_cifs'] == "true":
             raise xs_errors.XenError('NoSMBLicense')
 
-    def attach(self, sr_uuid):
+    @override
+    def attach(self, sr_uuid) -> None:
         if not self.checkmount():
             try:
                 self.mount()
@@ -208,7 +214,8 @@ class SMBSR(FileSR.SharedFileSR):
 
         self.attached = True
 
-    def probe(self):
+    @override
+    def probe(self) -> str:
         err = "SMBMount"
         try:
             self.mount(PROBE_MOUNTPOINT)
@@ -223,7 +230,8 @@ class SMBSR(FileSR.SharedFileSR):
         # Create a dictionary from the SR uuids to feed SRtoXML()
         return util.SRtoXML({sr_uuid: {} for sr_uuid in sr_list})
 
-    def detach(self, sr_uuid):
+    @override
+    def detach(self, sr_uuid) -> None:
         """Detach the SR: Unmounts and removes the mountpoint"""
         if not self.checkmount():
             return
@@ -241,7 +249,8 @@ class SMBSR(FileSR.SharedFileSR):
 
         self.attached = False
 
-    def create(self, sr_uuid, size):
+    @override
+    def create(self, sr_uuid, size) -> None:
         self.__check_license()
 
         if self.checkmount():
@@ -283,7 +292,8 @@ class SMBSR(FileSR.SharedFileSR):
                             .format(os.strerror(inst.code))) from inst
         self.detach(sr_uuid)
 
-    def delete(self, sr_uuid):
+    @override
+    def delete(self, sr_uuid) -> None:
         # try to remove/delete non VDI contents first
         super(SMBSR, self).delete(sr_uuid)
         try:
@@ -299,12 +309,14 @@ class SMBSR(FileSR.SharedFileSR):
             if inst.code != errno.ENOENT:
                 raise xs_errors.XenError('SMBDelete')
 
-    def vdi(self, uuid):
+    @override
+    def vdi(self, uuid) -> VDI.VDI:
         return SMBFileVDI(self, uuid)
 
 
 class SMBFileVDI(FileSR.FileVDI):
-    def attach(self, sr_uuid, vdi_uuid):
+    @override
+    def attach(self, sr_uuid, vdi_uuid) -> str:
         if not hasattr(self, 'xenstore_data'):
             self.xenstore_data = {}
 
@@ -312,7 +324,8 @@ class SMBFileVDI(FileSR.FileVDI):
 
         return super(SMBFileVDI, self).attach(sr_uuid, vdi_uuid)
 
-    def generate_config(self, sr_uuid, vdi_uuid):
+    @override
+    def generate_config(self, sr_uuid, vdi_uuid) -> str:
         util.SMlog("SMBFileVDI.generate_config")
         if not util.pathexists(self.path):
             raise xs_errors.XenError('VDIUnavailable')
@@ -327,17 +340,19 @@ class SMBFileVDI(FileSR.FileVDI):
         config = xmlrpc.client.dumps(tuple([resp]), "vdi_attach_from_config")
         return xmlrpc.client.dumps((config, ), "", True)
 
-    def attach_from_config(self, sr_uuid, vdi_uuid):
+    @override
+    def attach_from_config(self, sr_uuid, vdi_uuid) -> str:
         """Used for HA State-file only. Will not just attach the VDI but
         also start a tapdisk on the file"""
         util.SMlog("SMBFileVDI.attach_from_config")
         try:
             if not util.pathexists(self.sr.path):
-                self.sr.attach(sr_uuid)
+                return self.sr.attach(sr_uuid)
         except:
             util.logException("SMBFileVDI.attach_from_config")
             raise xs_errors.XenError('SRUnavailable', \
                         opterr='Unable to attach from config')
+        return ''
 
 
 if __name__ == '__main__':
diff --git a/drivers/SR.py b/drivers/SR.py
index d1aacdb3..fb2798ea 100755
--- a/drivers/SR.py
+++ b/drivers/SR.py
@@ -80,10 +80,10 @@ class SR(object):
       sr_vditype: string, repository type
     """
 
-    def handles(type):
+    @staticmethod
+    def handles(type) -> bool:
         """Returns True if this SR class understands the given dconf string"""
         return False
-    handles = staticmethod(handles)
 
     def __init__(self, srcmd, sr_uuid):
         """Base class initializer. All subclasses should call SR.__init__
@@ -229,7 +229,7 @@ class SR(object):
         except:
             pass
 
-    def create(self, uuid, size):
+    def create(self, uuid, size) -> None:
         """Create this repository.
         This operation may delete existing data.
 
@@ -243,7 +243,7 @@ class SR(object):
         """
         raise xs_errors.XenError('Unimplemented')
 
-    def delete(self, uuid):
+    def delete(self, uuid) -> None:
         """Delete this repository and its contents.
 
         This operation IS idempotent -- it will succeed if the repository
@@ -259,7 +259,7 @@ class SR(object):
         """
         raise xs_errors.XenError('Unimplemented')
 
-    def update(self, uuid):
+    def update(self, uuid) -> None:
         """Refresh the fields in the SR object
 
         Returns:
@@ -270,7 +270,7 @@ class SR(object):
         # no-op unless individual backends implement it
         return
 
-    def attach(self, uuid):
+    def attach(self, uuid) -> None:
         """Initiate local access to the SR. Initialises any
         device state required to access the substrate.
 
@@ -283,7 +283,7 @@ class SR(object):
         """
         raise xs_errors.XenError('Unimplemented')
 
-    def after_master_attach(self, uuid):
+    def after_master_attach(self, uuid) -> None:
         """Perform actions required after attaching on the pool master
         Return:
           None
@@ -298,7 +298,7 @@ class SR(object):
             self.session.xenapi.message.create(
                 msg_name, 2, "SR", uuid, msg_body)
 
-    def detach(self, uuid):
+    def detach(self, uuid) -> None:
         """Remove local access to the SR. Destroys any device
         state initiated by the sr_attach() operation.
 
@@ -312,7 +312,7 @@ class SR(object):
         """
         raise xs_errors.XenError('Unimplemented')
 
-    def probe(self):
+    def probe(self) -> str:
         """Perform a backend-specific scan, using the current dconf.  If the
         dconf is complete, then this will return a list of the SRs present of
         this type on the device, if any.  If the dconf is partial, then a
@@ -332,7 +332,7 @@ class SR(object):
         """
         raise xs_errors.XenError('Unimplemented')
 
-    def scan(self, uuid):
+    def scan(self, uuid) -> None:
         """
         Returns:
         """
@@ -342,7 +342,7 @@ class SR(object):
         scanrecord = ScanRecord(self)
         scanrecord.synchronise()
 
-    def replay(self, uuid):
+    def replay(self, uuid) -> None:
         """Replay a multi-stage log entry
 
         Returns:
@@ -352,30 +352,27 @@ class SR(object):
         """
         raise xs_errors.XenError('Unimplemented')
 
-    def content_type(self, uuid):
+    def content_type(self, uuid) -> str:
         """Returns the 'content_type' of an SR as a string"""
         return xmlrpc.client.dumps((str(self.sr_vditype), ), "", True)
 
-    def load(self, sr_uuid):
+    def load(self, sr_uuid) -> None:
         """Post-init hook"""
         pass
 
-    def check_sr(self, sr_uuid):
+    def check_sr(self, sr_uuid) -> None:
         """Hook to check SR health"""
         pass
 
-    def vdi(self, uuid):
+    def vdi(self, uuid) -> 'VDI.VDI':
         """Return VDI object owned by this repository"""
-        if uuid not in self.vdis:
-            self.vdis[uuid] = VDI.VDI(self, uuid)
         raise xs_errors.XenError('Unimplemented')
-        return self.vdis[uuid]
 
-    def forget_vdi(self, uuid):
+    def forget_vdi(self, uuid) -> None:
         vdi = self.session.xenapi.VDI.get_by_uuid(uuid)
         self.session.xenapi.VDI.db_forget(vdi)
 
-    def cleanup(self):
+    def cleanup(self) -> None:
         # callback after the op is done
         pass
 
diff --git a/drivers/VDI.py b/drivers/VDI.py
index bc2ae5f2..c396b80e 100755
--- a/drivers/VDI.py
+++ b/drivers/VDI.py
@@ -16,6 +16,8 @@
 # VDI: Base class for virtual disk instances
 #
 
+from sm_typing import Dict, Optional
+
 import SR
 import xmlrpc.client
 import xs_errors
@@ -132,7 +134,7 @@ class VDI(object):
         sr.srcmd.params['vdi_ref'] = vdi_ref
         return sr.vdi(vdi_uuid)
 
-    def create(self, sr_uuid, vdi_uuid, size):
+    def create(self, sr_uuid, vdi_uuid, size) -> str:
         """Create a VDI of size <Size> MB on the given SR. 
 
         This operation IS NOT idempotent and will fail if the UUID
@@ -145,7 +147,7 @@ class VDI(object):
         """
         raise xs_errors.XenError('Unimplemented')
 
-    def update(self, sr_uuid, vdi_uuid):
+    def update(self, sr_uuid, vdi_uuid) -> None:
         """Query and update the configuration of a particular VDI.
 
         Given an SR and VDI UUID, this operation returns summary statistics
@@ -155,7 +157,7 @@ class VDI(object):
         # no-op unless individual backends implement it
         return
 
-    def introduce(self, sr_uuid, vdi_uuid):
+    def introduce(self, sr_uuid, vdi_uuid) -> str:
         """Explicitly introduce a particular VDI.
 
         Given an SR and VDI UUID and a disk location (passed in via the <conf>
@@ -164,7 +166,7 @@ class VDI(object):
         """
         raise xs_errors.XenError('Unimplemented')
 
-    def attach(self, sr_uuid, vdi_uuid):
+    def attach(self, sr_uuid, vdi_uuid) -> str:
         """Initiate local access to the VDI. Initialises any device
         state required to access the VDI.
 
@@ -178,7 +180,7 @@ class VDI(object):
                    'xenstore_data': (self.xenstore_data or {})}
         return xmlrpc.client.dumps((struct, ), "", True)
 
-    def detach(self, sr_uuid, vdi_uuid):
+    def detach(self, sr_uuid, vdi_uuid) -> None:
         """Remove local access to the VDI. Destroys any device 
         state initialised via the vdi.attach() command.
 
@@ -186,7 +188,7 @@ class VDI(object):
         """
         raise xs_errors.XenError('Unimplemented')
 
-    def clone(self, sr_uuid, vdi_uuid):
+    def clone(self, sr_uuid, vdi_uuid) -> str:
         """Create a mutable instance of the referenced VDI.
 
         This operation is not idempotent and will fail if the UUID
@@ -207,14 +209,14 @@ class VDI(object):
         been paused for the duration of this call."""
         raise xs_errors.XenError('Unimplemented')
 
-    def generate_config(self, sr_uuid, vdi_uuid):
+    def generate_config(self, sr_uuid, vdi_uuid) -> str:
         """Generate the XML config required to activate a VDI for use
         when XAPI is not running. Activation is handled by the
         vdi_attach_from_config() SMAPI call.
         """
         raise xs_errors.XenError('Unimplemented')
 
-    def compose(self, sr_uuid, vdi1, vdi2):
+    def compose(self, sr_uuid, vdi1, vdi2) -> None:
         """Layer the updates from [vdi2] onto [vdi1], calling the result
         [vdi2].
 
@@ -223,7 +225,7 @@ class VDI(object):
         """
         raise xs_errors.XenError('Unimplemented')
 
-    def attach_from_config(self, sr_uuid, vdi_uuid):
+    def attach_from_config(self, sr_uuid, vdi_uuid) -> str:
         """Activate a VDI based on the config passed in on the CLI. For
         use when XAPI is not running. The config is generated by the
         Activation is handled by the vdi_generate_config() SMAPI call.
@@ -231,23 +233,23 @@ class VDI(object):
         raise xs_errors.XenError('Unimplemented')
 
     def _do_snapshot(self, sr_uuid, vdi_uuid, snapType,
-                     cloneOp=False, secondary=None, cbtlog=None):
+                     cloneOp=False, secondary=None, cbtlog=None) -> str:
         raise xs_errors.XenError('Unimplemented')
 
-    def _delete_cbt_log(self):
+    def _delete_cbt_log(self) -> None:
         raise xs_errors.XenError('Unimplemented')
 
-    def _rename(self, old, new):
+    def _rename(self, old, new) -> None:
         raise xs_errors.XenError('Unimplemented')
 
-    def _cbt_log_exists(self, logpath):
+    def _cbt_log_exists(self, logpath) -> bool:
         """Check if CBT log file exists
 
         Must be implemented by all classes inheriting from base VDI class
         """
         raise xs_errors.XenError('Unimplemented')
 
-    def resize(self, sr_uuid, vdi_uuid, size):
+    def resize(self, sr_uuid, vdi_uuid, size) -> str:
         """Resize the given VDI to size <size> MB. Size can
         be any valid disk size greater than [or smaller than]
         the current value.
@@ -293,7 +295,7 @@ class VDI(object):
                          % vdi_uuid)
             self._disable_cbt_on_error(alert_name, alert_str)
 
-    def delete(self, sr_uuid, vdi_uuid, data_only=False):
+    def delete(self, sr_uuid, vdi_uuid, data_only=False) -> None:
         """Delete this VDI.
 
         This operation IS idempotent and should succeed if the VDI
@@ -369,7 +371,7 @@ class VDI(object):
                 lock.release()
                 lock.cleanup("cbtlog", str(vdi_uuid))
 
-    def snapshot(self, sr_uuid, vdi_uuid):
+    def snapshot(self, sr_uuid, vdi_uuid) -> str:
         """Save an immutable copy of the referenced VDI.
 
         This operation IS NOT idempotent and will fail if the UUID
@@ -403,7 +405,7 @@ class VDI(object):
         return  self._do_snapshot(sr_uuid, vdi_uuid, snapType,
                                   secondary=secondary, cbtlog=cbtlog)
 
-    def activate(self, sr_uuid, vdi_uuid):
+    def activate(self, sr_uuid, vdi_uuid) -> Optional[Dict[str, str]]:
         """Activate VDI - called pre tapdisk open"""
         if self._get_blocktracking_status():
             if 'args' in self.sr.srcmd.params:
@@ -441,7 +443,7 @@ class VDI(object):
             return {'cbtlog': logpath}
         return None
 
-    def deactivate(self, sr_uuid, vdi_uuid):
+    def deactivate(self, sr_uuid, vdi_uuid) -> None:
         """Deactivate VDI - called post tapdisk close"""
         if self._get_blocktracking_status():
             from lock import Lock
@@ -457,7 +459,7 @@ class VDI(object):
             finally:
                 lock.release()
 
-    def get_params(self):
+    def get_params(self) -> str:
         """
         Returns:
           XMLRPC response containing a single struct with fields
@@ -467,7 +469,7 @@ class VDI(object):
                    'uuid': self.uuid}
         return xmlrpc.client.dumps((struct, ), "", True)
 
-    def load(self, vdi_uuid):
+    def load(self, vdi_uuid) -> None:
         """Post-init hook"""
         pass
 
@@ -804,7 +806,7 @@ class VDI(object):
                          % self.uuid)
             self._disable_cbt_on_error(alert_name, alert_str)
 
-    def _get_blocktracking_status(self, uuid=None):
+    def _get_blocktracking_status(self, uuid=None) -> bool:
         """ Get blocktracking status """
         if not uuid:
             uuid = self.uuid
@@ -825,7 +827,7 @@ class VDI(object):
         self.session.xenapi.VDI.add_to_other_config(
             vdi_ref, "cbt_enabled", enable)
 
-    def _ensure_cbt_space(self):
+    def _ensure_cbt_space(self) -> None:
         """ Ensure enough CBT space """
         pass
 
@@ -834,12 +836,12 @@ class VDI(object):
         logName = "%s.%s" % (uuid, CBTLOG_TAG)
         return logName
 
-    def _get_cbt_logpath(self, uuid):
+    def _get_cbt_logpath(self, uuid) -> str:
         """ Get CBT logpath """
         logName = self._get_cbt_logname(uuid)
         return os.path.join(self.sr.path, logName)
 
-    def _create_cbt_log(self):
+    def _create_cbt_log(self) -> str:
         """ Create CBT log """
         try:
             logpath = self._get_cbt_logpath(self.uuid)
@@ -858,7 +860,7 @@ class VDI(object):
 
         return logpath
 
-    def _activate_cbt_log(self, logname):
+    def _activate_cbt_log(self, logname) -> bool:
         """Activate CBT log file
 
         SR specific Implementation required for VDIs on block-based SRs.
@@ -866,7 +868,7 @@ class VDI(object):
         """
         return False
 
-    def _deactivate_cbt_log(self, logname):
+    def _deactivate_cbt_log(self, logname) -> None:
         """Deactivate CBT log file
 
         SR specific Implementation required for VDIs on block-based SRs.
diff --git a/drivers/XFSSR.py b/drivers/XFSSR.py
index ad4aca74..5bd73267 100755
--- a/drivers/XFSSR.py
+++ b/drivers/XFSSR.py
@@ -18,9 +18,12 @@
 #
 # XFSSR: Based on local-file storage repository, mounts xfs partition
 
+from sm_typing import override
+
 import SR
 from SR import deviceCheck
 import SRCommand
+import VDI
 import FileSR
 import util
 import lvutil
@@ -60,11 +63,13 @@ class XFSSR(FileSR.FileSR):
 
     DRIVER_TYPE = 'xfs'
 
-    def handles(srtype):
+    @override
+    @staticmethod
+    def handles(srtype) -> bool:
         return srtype == XFSSR.DRIVER_TYPE
-    handles = staticmethod(handles)
 
-    def load(self, sr_uuid):
+    @override
+    def load(self, sr_uuid) -> None:
         if not self._is_xfs_available():
             raise xs_errors.XenError(
                 'SRUnavailable',
@@ -81,7 +86,8 @@ class XFSSR(FileSR.FileSR):
         self.attached = self._checkmount()
         self.driver_config = DRIVER_CONFIG
 
-    def delete(self, sr_uuid):
+    @override
+    def delete(self, sr_uuid) -> None:
         super(XFSSR, self).delete(sr_uuid)
 
         # Check PVs match VG
@@ -111,7 +117,8 @@ class XFSSR(FileSR.FileSR):
             raise xs_errors.XenError('LVMDelete', \
                   opterr='errno is %d' % inst.code)
 
-    def attach(self, sr_uuid):
+    @override
+    def attach(self, sr_uuid) -> None:
         if not self._checkmount():
             try:
                 #Activate LV
@@ -150,7 +157,8 @@ class XFSSR(FileSR.FileSR):
         for dev in self.dconf['device'].split(','):
             self.block_setscheduler(dev)
 
-    def detach(self, sr_uuid):
+    @override
+    def detach(self, sr_uuid) -> None:
         super(XFSSR, self).detach(sr_uuid)
         try:
             # deactivate SR
@@ -160,13 +168,15 @@ class XFSSR(FileSR.FileSR):
             raise xs_errors.XenError('LVMUnMount', \
                   opterr='lvm -an failed errno is %d' % inst.code)
 
+    @override
     @deviceCheck
-    def probe(self):
+    def probe(self) -> str:
         return lvutil.srlist_toxml(lvutil.scan_srlist(EXT_PREFIX, self.dconf['device']),
                 EXT_PREFIX)
 
+    @override
     @deviceCheck
-    def create(self, sr_uuid, size):
+    def create(self, sr_uuid, size) -> None:
         if self._checkmount():
             raise xs_errors.XenError('SRExists')
 
@@ -224,7 +234,8 @@ class XFSSR(FileSR.FileSR):
         scsiutil.add_serial_record(self.session, self.sr_ref, \
                   scsiutil.devlist_to_serialstring(self.dconf['device'].split(',')))
 
-    def vdi(self, uuid, loadLocked = False):
+    @override
+    def vdi(self, uuid, loadLocked = False) -> VDI.VDI:
         return XFSFileVDI(self, uuid)
 
     @staticmethod
@@ -233,7 +244,8 @@ class XFSSR(FileSR.FileSR):
 
 
 class XFSFileVDI(FileSR.FileVDI):
-    def attach(self, sr_uuid, vdi_uuid):
+    @override
+    def attach(self, sr_uuid, vdi_uuid) -> str:
         if not hasattr(self, 'xenstore_data'):
             self.xenstore_data = {}
 
diff --git a/drivers/ZFSSR.py b/drivers/ZFSSR.py
index cf5eb12d..13a895a2 100644
--- a/drivers/ZFSSR.py
+++ b/drivers/ZFSSR.py
@@ -14,8 +14,11 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
+from sm_typing import override
+
 import SR
 import SRCommand
+import VDI
 
 import FileSR
 
@@ -71,11 +74,13 @@ def is_zfs_path(path):
 class ZFSSR(FileSR.FileSR):
     DRIVER_TYPE = 'zfs'
 
+    @override
     @staticmethod
-    def handles(type):
+    def handles(type) -> bool:
         return type == ZFSSR.DRIVER_TYPE
 
-    def load(self, sr_uuid):
+    @override
+    def load(self, sr_uuid) -> None:
         if not is_zfs_available():
             raise xs_errors.XenError(
                 'SRUnavailable',
@@ -83,7 +88,8 @@ class ZFSSR(FileSR.FileSR):
             )
         return super(ZFSSR, self).load(sr_uuid)
 
-    def create(self, sr_uuid, size):
+    @override
+    def create(self, sr_uuid, size) -> None:
         if not is_zfs_path(self.remotepath):
             raise xs_errors.XenError(
                 'ZFSSRCreate',
@@ -91,7 +97,8 @@ class ZFSSR(FileSR.FileSR):
             )
         return super(ZFSSR, self).create(sr_uuid, size)
 
-    def delete(self, sr_uuid):
+    @override
+    def delete(self, sr_uuid) -> None:
         if not self._checkmount():
             raise xs_errors.XenError(
                 'ZFSSRDelete',
@@ -99,28 +106,33 @@ class ZFSSR(FileSR.FileSR):
             )
         return super(ZFSSR, self).delete(sr_uuid)
 
-    def attach(self, sr_uuid):
+    @override
+    def attach(self, sr_uuid) -> None:
         if not is_zfs_path(self.remotepath):
             raise xs_errors.XenError(
                 'SRUnavailable',
                 opterr='Invalid ZFS path'
             )
-        return super(ZFSSR, self).attach(sr_uuid)
+        super(ZFSSR, self).attach(sr_uuid)
 
-    def detach(self, sr_uuid):
+    @override
+    def detach(self, sr_uuid) -> None:
         return super(ZFSSR, self).detach(sr_uuid)
 
-    def vdi(self, uuid, loadLocked=False):
+    @override
+    def vdi(self, uuid, loadLocked=False) -> VDI.VDI:
         return ZFSFileVDI(self, uuid)
 
     # Ensure _checkmount is overridden to prevent bad behaviors in FileSR.
-    def _checkmount(self):
+    @override
+    def _checkmount(self) -> bool:
         return super(ZFSSR, self)._checkmount() and \
             is_zfs_path(self.remotepath)
 
 
 class ZFSFileVDI(FileSR.FileVDI):
-    def attach(self, sr_uuid, vdi_uuid):
+    @override
+    def attach(self, sr_uuid, vdi_uuid) -> str:
         if not hasattr(self, 'xenstore_data'):
             self.xenstore_data = {}
 
diff --git a/drivers/blktap2.py b/drivers/blktap2.py
index 672f7448..bb2cbcac 100755
--- a/drivers/blktap2.py
+++ b/drivers/blktap2.py
@@ -18,7 +18,9 @@
 # blktap2: blktap/tapdisk management layer
 #
 
-from sm_typing import Any, Callable, ClassVar, Dict
+from sm_typing import Any, Callable, ClassVar, Dict, override
+
+from abc import abstractmethod
 
 import grp
 import os
@@ -152,7 +154,8 @@ class TapCtl(object):
             self.cmd = cmd
             self.info = info
 
-        def __str__(self):
+        @override
+        def __str__(self) -> str:
             items = self.info.items()
             info = ", ".join("%s=%s" % item
                              for item in items)
@@ -448,7 +451,8 @@ class TapdiskExists(Exception):
     def __init__(self, tapdisk):
         self.tapdisk = tapdisk
 
-    def __str__(self):
+    @override
+    def __str__(self) -> str:
         return "%s already running" % self.tapdisk
 
 
@@ -458,7 +462,8 @@ class TapdiskNotRunning(Exception):
     def __init__(self, **attrs):
         self.attrs = attrs
 
-    def __str__(self):
+    @override
+    def __str__(self) -> str:
         items = iter(self.attrs.items())
         attrs = ", ".join("%s=%s" % attr
                           for attr in items)
@@ -471,7 +476,8 @@ class TapdiskNotUnique(Exception):
     def __init__(self, tapdisks):
         self.tapdisks = tapdisks
 
-    def __str__(self):
+    @override
+    def __str__(self) -> str:
         tapdisks = map(str, self.tapdisks)
         return "Found multiple tapdisks: %s" % tapdisks
 
@@ -483,7 +489,8 @@ class TapdiskFailed(Exception):
         self.arg = arg
         self.err = err
 
-    def __str__(self):
+    @override
+    def __str__(self) -> str:
         return "Tapdisk(%s): %s" % (self.arg, self.err)
 
     def get_error(self):
@@ -496,7 +503,8 @@ class TapdiskInvalidState(Exception):
     def __init__(self, tapdisk):
         self.tapdisk = tapdisk
 
-    def __str__(self):
+    @override
+    def __str__(self) -> str:
         return str(self.tapdisk)
 
 
@@ -518,8 +526,9 @@ class KObject(object):
 
     SYSFS_CLASSTYPE: ClassVar[str] = ""
 
-    def sysfs_devname(self):
-        raise NotImplementedError("sysfs_devname is undefined")
+    @abstractmethod
+    def sysfs_devname(self) -> str:
+        pass
 
 
 class Attribute(object):
@@ -538,7 +547,8 @@ class Attribute(object):
         def __init__(self, name):
             self.name = name
 
-        def __str__(self):
+        @override
+        def __str__(self) -> str:
             return "No such attribute: %s" % self.name
 
     def _open(self, mode='r'):
@@ -595,10 +605,12 @@ class Blktap(ClassDevice):
     def free(self):
         TapCtl.free(self.minor)
 
-    def __str__(self):
+    @override
+    def __str__(self) -> str:
         return "%s(minor=%d)" % (self.__class__.__name__, self.minor)
 
-    def sysfs_devname(self):
+    @override
+    def sysfs_devname(self) -> str:
         return "blktap!blktap%d" % self.minor
 
     class Pool(Attribute):
@@ -666,7 +678,8 @@ class Tapdisk(object):
         self._dirty = False
         self._blktap = None
 
-    def __str__(self):
+    @override
+    def __str__(self) -> str:
         state = self.pause_state()
         return "Tapdisk(%s, pid=%d, minor=%s, state=%s)" % \
             (self.get_arg(), self.pid, self.minor, state)
@@ -752,7 +765,8 @@ class Tapdisk(object):
             self.type = _type
             self.path = path
 
-        def __str__(self):
+        @override
+        def __str__(self) -> str:
             return "%s:%s" % (self.type, self.path)
 
         @classmethod
@@ -772,14 +786,16 @@ class Tapdisk(object):
             def __init__(self, _type):
                 self.type = _type
 
-            def __str__(self):
+            @override
+            def __str__(self) -> str:
                 return "Not a Tapdisk type: %s" % self.type
 
         class InvalidArgument(Exception):
             def __init__(self, arg):
                 self.arg = arg
 
-            def __str__(self):
+            @override
+            def __str__(self) -> str:
                 return "Not a Tapdisk image: %s" % self.arg
 
     def get_arg(self):
@@ -921,7 +937,8 @@ class Tapdisk(object):
         t = self.from_minor(__get('minor'))
         self.__init__(t.pid, t.minor, t.type, t.path, t.state)
 
-    def __getattribute__(self, name):
+    @override
+    def __getattribute__(self, name) -> Any:
         def __get(name):
             # NB. avoid(rec(ursion)
             return object.__getattribute__(self, name)
@@ -1091,7 +1108,8 @@ class VDI(object):
             self.vdi_type = vdi_type
             self.target = target
 
-        def __str__(self):
+        @override
+        def __str__(self) -> str:
             return \
                 "Target %s has unexpected VDI type '%s'" % \
                 (type(self.target), self.vdi_type)
@@ -1176,11 +1194,12 @@ class VDI(object):
 
         BASEDIR: ClassVar[str] = ""
 
-        def _mklink(self, target):
-            raise NotImplementedError("_mklink is not defined")
+        def _mklink(self, target) -> None:
+            pass
 
-        def _equals(self, target):
-            raise NotImplementedError("_equals is not defined")
+        @abstractmethod
+        def _equals(self, target) -> bool:
+            pass
 
         def __init__(self, path):
             self._path = path
@@ -1201,7 +1220,7 @@ class VDI(object):
         def stat(self):
             return os.stat(self.path())
 
-        def mklink(self, target):
+        def mklink(self, target) -> None:
 
             path = self.path()
             util.SMlog("%s -> %s" % (self, target))
@@ -1224,7 +1243,8 @@ class VDI(object):
                 if e.errno != errno.ENOENT:
                     raise
 
-        def __str__(self):
+        @override
+        def __str__(self) -> str:
             path = self.path()
             return "%s(%s)" % (self.__class__.__name__, path)
 
@@ -1237,10 +1257,12 @@ class VDI(object):
         def symlink(self):
             return self.path()
 
-        def _mklink(self, target):
+        @override
+        def _mklink(self, target) -> None:
             os.symlink(target, self.path())
 
-        def _equals(self, target):
+        @override
+        def _equals(self, target) -> bool:
             return self.readlink() == target
 
     class DeviceNode(Link):
@@ -1257,7 +1279,8 @@ class VDI(object):
             """Whether @target refers to a block device."""
             return S_ISBLK(cls._real_stat(target).st_mode)
 
-        def _mklink(self, target):
+        @override
+        def _mklink(self, target) -> None:
 
             st = self._real_stat(target)
             if not S_ISBLK(st.st_mode):
@@ -1267,7 +1290,8 @@ class VDI(object):
             os.mknod(self.path(), st.st_mode | stat.S_IRGRP, st.st_rdev)
             os.chown(self.path(), st.st_uid, grp.getgrnam("disk").gr_gid)
 
-        def _equals(self, target):
+        @override
+        def _equals(self, target) -> bool:
             target_rdev = self._real_stat(target).st_rdev
             return self.stat().st_rdev == target_rdev
 
@@ -1282,7 +1306,8 @@ class VDI(object):
                 self.path = path
                 self.st = st
 
-            def __str__(self):
+            @override
+            def __str__(self) -> str:
                 return "%s is not a block device: %s" % (self.path, self.st)
 
     class Hybrid(Link):
@@ -1298,14 +1323,16 @@ class VDI(object):
                 return self._devnode.rdev()
             raise self._devnode.NotABlockDevice(self.path(), st)
 
-        def mklink(self, target):
+        @override
+        def mklink(self, target) -> None:
             if self._devnode.is_block(target):
                 self._obj = self._devnode
             else:
                 self._obj = self._symlink
             self._obj.mklink(target)
 
-        def _equals(self, target):
+        @override
+        def _equals(self, target) -> bool:
             return self._obj._equals(target)
 
     class PhyLink(SymLink):
@@ -2106,7 +2133,8 @@ class UEventHandler(object):
             super().__init__(args)
             self.key = args[0]
 
-        def __str__(self):
+        @override
+        def __str__(self) -> str:
             return \
                 "Key '%s' missing in environment. " % self.key + \
                 "Not called in udev context?"
@@ -2129,7 +2157,8 @@ class UEventHandler(object):
             self.event = event
             self.handler = handler
 
-        def __str__(self):
+        @override
+        def __str__(self) -> str:
             return "Uevent '%s' not handled by %s" % \
                 (self.event, self.handler.__class__.__name__)
 
@@ -2145,7 +2174,8 @@ class UEventHandler(object):
 
         return fn(self)
 
-    def __str__(self):
+    @override
+    def __str__(self) -> str:
         try:
             action = self.get_action()
         except:
@@ -2160,7 +2190,8 @@ class __BlktapControl(ClassDevice):
         ClassDevice.__init__(self)
         self._default_pool = None
 
-    def sysfs_devname(self):
+    @override
+    def sysfs_devname(self) -> str:
         return "blktap!control"
 
     class DefaultPool(Attribute):
@@ -2187,7 +2218,8 @@ class __BlktapControl(ClassDevice):
         def __init__(self, name):
             self.name = name
 
-        def __str__(self):
+        @override
+        def __str__(self) -> str:
             return "No such pool: {}".format(self.name)
 
     def get_pool(self, name):
@@ -2207,6 +2239,10 @@ class PagePool(KObject):
         self.path = path
         self._size = None
 
+    @override
+    def sysfs_devname(self) -> str:
+        return ''
+
     def sysfs_path(self):
         return self.path
 
@@ -2347,11 +2383,13 @@ class XenbusDevice(BusDevice):
             self._xs_rm_path(xapi_path)
             self._xs_rm_path(upstream_path)
 
-    def sysfs_devname(self):
+    @override
+    def sysfs_devname(self) -> str:
         return "%s-%d-%d" % (self.XENBUS_DEVTYPE,
                              self.domid, self.devid)
 
-    def __str__(self):
+    @override
+    def __str__(self) -> str:
         return self.sysfs_devname()
 
     @classmethod
@@ -2402,7 +2440,8 @@ class Blkback(XenBackendDevice):
             self.vbd = vbd
             self.str = _str
 
-        def __str__(self):
+        @override
+        def __str__(self) -> str:
             return "Backend %s " % self.vbd + \
                 "has %s = %s" % (self.KEY, self.str)
 
@@ -2435,10 +2474,12 @@ class Blkback(XenBackendDevice):
         def is_tap(self):
             return self.major == Tapdisk.major()
 
-        def __str__(self):
+        @override
+        def __str__(self) -> str:
             return "%s:%s" % (self.major, self.minor)
 
-        def __eq__(self, other):
+        @override
+        def __eq__(self, other) -> bool:
             return \
                 self.major == other.major and \
                 self.minor == other.minor
@@ -2554,14 +2595,16 @@ class BlkbackEventHandler(UEventHandler):
 
         UEventHandler.__init__(self)
 
-    def run(self):
+    @override
+    def run(self) -> None:
 
         self.xs_path = self.getenv('XENBUS_PATH')
         openlog(str(self), 0, self.LOG_FACILITY)
 
         UEventHandler.run(self)
 
-    def __str__(self):
+    @override
+    def __str__(self) -> str:
 
         try:
             path = self.xs_path
diff --git a/drivers/cleanup.py b/drivers/cleanup.py
index 940e6802..f1341dc9 100755
--- a/drivers/cleanup.py
+++ b/drivers/cleanup.py
@@ -18,6 +18,8 @@
 # Script to coalesce and garbage collect VHD-based SR's in the background
 #
 
+from sm_typing import Optional, override
+
 import os
 import os.path
 import sys
@@ -113,7 +115,7 @@ class Util:
     PREFIX = {"G": 1024 * 1024 * 1024, "M": 1024 * 1024, "K": 1024}
 
     @staticmethod
-    def log(text):
+    def log(text) -> None:
         util.SMlog(text, ident="SMGC")
 
     @staticmethod
@@ -552,11 +554,11 @@ class VDI(object):
     def extractUuid(path):
         raise NotImplementedError("Implement in sub class")
 
-    def load(self, info=None):
+    def load(self, info=None) -> None:
         """Load VDI info"""
-        pass  # abstract
+        pass
 
-    def getDriverName(self):
+    def getDriverName(self) -> str:
         return self.DRIVER_NAME_VHD
 
     def getRef(self):
@@ -588,7 +590,7 @@ class VDI(object):
             Util.log("Unpausing VDI %s" % self)
             self.unpause()
 
-    def pause(self, failfast=False):
+    def pause(self, failfast=False) -> None:
         if not blktap2.VDI.tap_pause(self.sr.xapi.session, self.sr.uuid,
                 self.uuid, failfast):
             raise util.SMException("Failed to pause VDI %s" % self)
@@ -709,10 +711,10 @@ class VDI(object):
             vdiList.append(self)
         return vdiList
 
-    def getSizeVHD(self):
+    def getSizeVHD(self) -> int:
         return self._sizeVHD
 
-    def getAllocatedSize(self):
+    def getAllocatedSize(self) -> int:
         return self._sizeAllocated
 
     def getTreeRoot(self):
@@ -745,12 +747,12 @@ class VDI(object):
             leaves.extend(child.getAllLeaves())
         return leaves
 
-    def updateBlockInfo(self):
+    def updateBlockInfo(self) -> Optional[str]:
         val = base64.b64encode(self._queryVHDBlocks()).decode()
         self.setConfig(VDI.DB_VHD_BLOCKS, val)
         return val
 
-    def rename(self, uuid):
+    def rename(self, uuid) -> None:
         "Rename the VDI file"
         assert(not self.sr.vdis.get(uuid))
         self._clearRef()
@@ -761,19 +763,20 @@ class VDI(object):
         del self.sr.vdis[oldUuid]
         self.sr.vdis[self.uuid] = self
 
-    def delete(self):
+    def delete(self) -> None:
         "Physically delete the VDI"
         lock.Lock.cleanup(self.uuid, lvhdutil.NS_PREFIX_LVM + self.sr.uuid)
         lock.Lock.cleanupAll(self.uuid)
         self._clear()
 
-    def getParent(self):
+    def getParent(self) -> str:
         return vhdutil.getParent(self.path, lambda x: x.strip())
 
-    def repair(self, parent):
+    def repair(self, parent) -> None:
         vhdutil.repair(parent)
 
-    def __str__(self):
+    @override
+    def __str__(self) -> str:
         strHidden = ""
         if self.hidden:
             strHidden = "*"
@@ -794,7 +797,7 @@ class VDI(object):
         return "%s%s(%s%s%s)%s" % (strHidden, self.uuid[0:8], strSizeVirt,
                 strSizeVHD, strSizeAllocated, strType)
 
-    def validate(self, fast=False):
+    def validate(self, fast=False) -> None:
         if not vhdutil.check(self.path, fast=fast):
             raise util.SMException("VHD %s corrupted" % self)
 
@@ -808,7 +811,7 @@ class VDI(object):
     def _clearRef(self):
         self._vdiRef = None
 
-    def _doCoalesce(self):
+    def _doCoalesce(self) -> None:
         """Coalesce self onto parent. Only perform the actual coalescing of
         VHD, but not the subsequent relinking. We'll do that as the next step,
         after reloading the entire SR in case things have changed while we
@@ -890,7 +893,7 @@ class VDI(object):
         if xcmsg:
             xapi.message.create(msg_name, "3", "SR", vdi.sr.uuid, msg_body)
 
-    def coalesce(self):
+    def coalesce(self) -> int:
         # size is returned in sectors
         return vhdutil.coalesce(self.path) * 512
 
@@ -951,7 +954,7 @@ class VDI(object):
 
         util.fistpoint.activate("LVHDRT_coalescing_VHD_data", self.sr.uuid)
 
-    def _relinkSkip(self):
+    def _relinkSkip(self) -> None:
         """Relink children of this VDI to point to the parent of this VDI"""
         abortFlag = IPCFlag(self.sr.uuid)
         for child in self.children:
@@ -1022,7 +1025,7 @@ class VDI(object):
         if ret:
             self.parentUuid = ret
 
-    def _setParent(self, parent):
+    def _setParent(self, parent) -> None:
         vhdutil.setParent(self.path, parent.path, False)
         self.parent = parent
         self.parentUuid = parent.uuid
@@ -1035,15 +1038,15 @@ class VDI(object):
             Util.log("Failed to update %s with vhd-parent field %s" % \
                      (self.uuid, self.parentUuid))
 
-    def _loadInfoHidden(self):
+    def _loadInfoHidden(self) -> None:
         hidden = vhdutil.getHidden(self.path)
         self.hidden = (hidden != 0)
 
-    def _setHidden(self, hidden=True):
+    def _setHidden(self, hidden=True) -> None:
         vhdutil.setHidden(self.path, hidden)
         self.hidden = hidden
 
-    def _increaseSizeVirt(self, size, atomic=True):
+    def _increaseSizeVirt(self, size, atomic=True) -> None:
         """ensure the virtual size of 'self' is at least 'size'. Note that
         resizing a VHD must always be offline and atomically: the file must
         not be open by anyone and no concurrent operations may take place.
@@ -1075,14 +1078,14 @@ class VDI(object):
 
         self.sizeVirt = vhdutil.getSizeVirt(self.path)
 
-    def _setSizeVirt(self, size):
+    def _setSizeVirt(self, size) -> None:
         """WARNING: do not call this method directly unless all VDIs in the
         subtree are guaranteed to be unplugged (and remain so for the duration
         of the operation): this operation is only safe for offline VHDs"""
         jFile = os.path.join(self.sr.path, self.uuid)
         vhdutil.setSizeVirt(self.path, size, jFile)
 
-    def _queryVHDBlocks(self):
+    def _queryVHDBlocks(self) -> bytes:
         return vhdutil.getBlockBitmap(self.path)
 
     def _getCoalescedSizeData(self):
@@ -1101,20 +1104,20 @@ class VDI(object):
         assert(sizeData <= self.sizeVirt)
         return sizeData
 
-    def _calcExtraSpaceForCoalescing(self):
+    def _calcExtraSpaceForCoalescing(self) -> int:
         sizeData = self._getCoalescedSizeData()
         sizeCoalesced = sizeData + vhdutil.calcOverheadBitmap(sizeData) + \
                 vhdutil.calcOverheadEmpty(self.sizeVirt)
         Util.log("Coalesced size = %s" % Util.num2str(sizeCoalesced))
         return sizeCoalesced - self.parent.getSizeVHD()
 
-    def _calcExtraSpaceForLeafCoalescing(self):
+    def _calcExtraSpaceForLeafCoalescing(self) -> int:
         """How much extra space in the SR will be required to
         [live-]leaf-coalesce this VDI"""
         # the space requirements are the same as for inline coalesce
         return self._calcExtraSpaceForCoalescing()
 
-    def _calcExtraSpaceForSnapshotCoalescing(self):
+    def _calcExtraSpaceForSnapshotCoalescing(self) -> int:
         """How much extra space in the SR will be required to
         snapshot-coalesce this VDI"""
         return self._calcExtraSpaceForCoalescing() + \
@@ -1149,7 +1152,8 @@ class FileVDI(VDI):
         else:
             self.fileName = "%s%s" % (self.uuid, vhdutil.FILE_EXTN_VHD)
 
-    def load(self, info=None):
+    @override
+    def load(self, info=None) -> None:
         if not info:
             if not util.pathexists(self.path):
                 raise util.SMException("%s not found" % self.path)
@@ -1169,7 +1173,8 @@ class FileVDI(VDI):
         self.path = os.path.join(self.sr.path, "%s%s" % \
                 (self.uuid, vhdutil.FILE_EXTN_VHD))
 
-    def rename(self, uuid):
+    @override
+    def rename(self, uuid) -> None:
         oldPath = self.path
         VDI.rename(self, uuid)
         self.fileName = "%s%s" % (self.uuid, vhdutil.FILE_EXTN_VHD)
@@ -1178,7 +1183,8 @@ class FileVDI(VDI):
         Util.log("Renaming %s -> %s" % (oldPath, self.path))
         os.rename(oldPath, self.path)
 
-    def delete(self):
+    @override
+    def delete(self) -> None:
         if len(self.children) > 0:
             raise util.SMException("VDI %s has children, can't delete" % \
                     self.uuid)
@@ -1193,7 +1199,8 @@ class FileVDI(VDI):
             raise util.SMException("os.unlink(%s) failed" % self.path)
         VDI.delete(self)
 
-    def getAllocatedSize(self):
+    @override
+    def getAllocatedSize(self) -> int:
         if self._sizeAllocated == -1:
             self._sizeAllocated = vhdutil.getAllocatedSize(self.path)
         return self._sizeAllocated
@@ -1205,7 +1212,8 @@ class LVHDVDI(VDI):
     JRN_ZERO = "zero"  # journal entry type for zeroing out end of parent
     DRIVER_NAME_RAW = "aio"
 
-    def load(self, info=None):
+    @override
+    def load(self, info=None) -> None:
         # `info` is always set. `None` default value is only here to match parent method.
         assert info, "No info given to LVHDVDI.load"
         self.parent = None
@@ -1227,7 +1235,8 @@ class LVHDVDI(VDI):
     def extractUuid(path):
         return lvhdutil.extractUuid(path)
 
-    def getDriverName(self):
+    @override
+    def getDriverName(self) -> str:
         if self.raw:
             return self.DRIVER_NAME_RAW
         return self.DRIVER_NAME_VHD
@@ -1274,11 +1283,14 @@ class LVHDVDI(VDI):
             util.fistpoint.activate("LVHDRT_coalescing_before_inflate_grandparent", self.sr.uuid)
             self.parent.inflate(self.parent.sizeLV + inc)
 
-    def updateBlockInfo(self):
+    @override
+    def updateBlockInfo(self) -> Optional[str]:
         if not self.raw:
             return VDI.updateBlockInfo(self)
+        return None
 
-    def rename(self, uuid):
+    @override
+    def rename(self, uuid) -> None:
         oldUuid = self.uuid
         oldLVName = self.fileName
         VDI.rename(self, uuid)
@@ -1297,7 +1309,8 @@ class LVHDVDI(VDI):
         RefCounter.set(self.uuid, cnt, bcnt, ns)
         RefCounter.reset(oldUuid, ns)
 
-    def delete(self):
+    @override
+    def delete(self) -> None:
         if len(self.children) > 0:
             raise util.SMException("VDI %s has children, can't delete" % \
                     self.uuid)
@@ -1310,7 +1323,8 @@ class LVHDVDI(VDI):
         RefCounter.reset(self.uuid, lvhdutil.NS_PREFIX_LVM + self.sr.uuid)
         VDI.delete(self)
 
-    def getSizeVHD(self):
+    @override
+    def getSizeVHD(self) -> int:
         if self._sizeVHD == -1:
             self._loadInfoSizeVHD()
         return self._sizeVHD
@@ -1328,7 +1342,8 @@ class LVHDVDI(VDI):
             raise util.SMException("phys size of %s = %d" % \
                     (self, self._sizeVHD))
 
-    def getAllocatedSize(self):
+    @override
+    def getAllocatedSize(self) -> int:
         if self._sizeAllocated == -1:
             self._loadInfoSizeAllocated()
         return self._sizeAllocated
@@ -1342,20 +1357,23 @@ class LVHDVDI(VDI):
         self._activate()
         self._sizeAllocated = vhdutil.getAllocatedSize(self.path)
 
-    def _loadInfoHidden(self):
+    @override
+    def _loadInfoHidden(self) -> None:
         if self.raw:
             self.hidden = self.sr.lvmCache.getHidden(self.fileName)
         else:
             VDI._loadInfoHidden(self)
 
-    def _setHidden(self, hidden=True):
+    @override
+    def _setHidden(self, hidden=True) -> None:
         if self.raw:
             self.sr.lvmCache.setHidden(self.fileName, hidden)
             self.hidden = hidden
         else:
             VDI._setHidden(self, hidden)
 
-    def __str__(self):
+    @override
+    def __str__(self) -> str:
         strType = "VHD"
         if self.raw:
             strType = "RAW"
@@ -1377,11 +1395,13 @@ class LVHDVDI(VDI):
                 Util.num2str(self.sizeVirt), strSizeVHD, strSizeAllocated,
                 Util.num2str(self.sizeLV), strActive)
 
-    def validate(self, fast=False):
+    @override
+    def validate(self, fast=False) -> None:
         if not self.raw:
             VDI.validate(self, fast)
 
-    def _doCoalesce(self):
+    @override
+    def _doCoalesce(self) -> None:
         """LVHD parents must first be activated, inflated, and made writable"""
         try:
             self._activateChain()
@@ -1394,7 +1414,8 @@ class LVHDVDI(VDI):
             self.parent.deflate()
             self.sr.lvmCache.setReadonly(self.parent.fileName, True)
 
-    def _setParent(self, parent):
+    @override
+    def _setParent(self, parent) -> None:
         self._activate()
         if self.lvReadonly:
             self.sr.lvmCache.setReadonly(self.fileName, False)
@@ -1428,7 +1449,8 @@ class LVHDVDI(VDI):
     def _deactivate(self):
         self.sr.lvActivator.deactivate(self.uuid, False)
 
-    def _increaseSizeVirt(self, size, atomic=True):
+    @override
+    def _increaseSizeVirt(self, size, atomic=True) -> None:
         "ensure the virtual size of 'self' is at least 'size'"
         self._activate()
         if not self.raw:
@@ -1464,7 +1486,8 @@ class LVHDVDI(VDI):
                 VDI.POLL_INTERVAL, 0)
         self.sr.journaler.remove(self.JRN_ZERO, self.uuid)
 
-    def _setSizeVirt(self, size):
+    @override
+    def _setSizeVirt(self, size) -> None:
         """WARNING: do not call this method directly unless all VDIs in the
         subtree are guaranteed to be unplugged (and remain so for the duration
         of the operation): this operation is only safe for offline VHDs"""
@@ -1477,25 +1500,29 @@ class LVHDVDI(VDI):
         finally:
             lvhdutil.deleteVHDJournalLV(self.sr.lvmCache, self.uuid)
 
-    def _queryVHDBlocks(self):
+    @override
+    def _queryVHDBlocks(self) -> bytes:
         self._activate()
         return VDI._queryVHDBlocks(self)
 
-    def _calcExtraSpaceForCoalescing(self):
+    @override
+    def _calcExtraSpaceForCoalescing(self) -> int:
         if self.parent.raw:
             return 0  # raw parents are never deflated in the first place
         sizeCoalesced = lvhdutil.calcSizeVHDLV(self._getCoalescedSizeData())
         Util.log("Coalesced size = %s" % Util.num2str(sizeCoalesced))
         return sizeCoalesced - self.parent.sizeLV
 
-    def _calcExtraSpaceForLeafCoalescing(self):
+    @override
+    def _calcExtraSpaceForLeafCoalescing(self) -> int:
         """How much extra space in the SR will be required to
         [live-]leaf-coalesce this VDI"""
         # we can deflate the leaf to minimize the space requirements
         deflateDiff = self.sizeLV - lvhdutil.calcSizeLV(self.getSizeVHD())
         return self._calcExtraSpaceForCoalescing() - deflateDiff
 
-    def _calcExtraSpaceForSnapshotCoalescing(self):
+    @override
+    def _calcExtraSpaceForSnapshotCoalescing(self) -> int:
         return self._calcExtraSpaceForCoalescing() + \
                 lvhdutil.calcSizeLV(self.getSizeVHD())
 
@@ -1505,7 +1532,8 @@ class LinstorVDI(VDI):
 
     VOLUME_LOCK_TIMEOUT = 30
 
-    def load(self, info=None):
+    @override
+    def load(self, info=None) -> None:
         self.parentUuid = info.parentUuid
         self.scanError = True
         self.parent = None
@@ -1532,7 +1560,8 @@ class LinstorVDI(VDI):
         self.scanError = False
         self.vdi_type = vhdutil.VDI_TYPE_VHD
 
-    def getSizeVHD(self, fetch=False):
+    @override
+    def getSizeVHD(self, fetch=False) -> int:
         if self._sizeVHD < 0 or fetch:
             self._sizeVHD = self.sr._vhdutil.get_size_phys(self.uuid)
         return self._sizeVHD
@@ -1542,7 +1571,8 @@ class LinstorVDI(VDI):
             self.drbd_size = self.sr._vhdutil.get_drbd_size(self.uuid)
         return self.drbd_size
 
-    def getAllocatedSize(self):
+    @override
+    def getAllocatedSize(self) -> int:
         if self._sizeAllocated == -1:
             if not self.raw:
                 self._sizeAllocated = self.sr._vhdutil.get_allocated_size(self.uuid)
@@ -1582,14 +1612,16 @@ class LinstorVDI(VDI):
         if not self.raw:
             self.inflate(LinstorVhdUtil.compute_volume_size(self.sizeVirt, self.vdi_type))
 
-    def rename(self, uuid):
+    @override
+    def rename(self, uuid) -> None:
         Util.log('Renaming {} -> {} (path={})'.format(
             self.uuid, uuid, self.path
         ))
         self.sr._linstor.update_volume_uuid(self.uuid, uuid)
         VDI.rename(self, uuid)
 
-    def delete(self):
+    @override
+    def delete(self) -> None:
         if len(self.children) > 0:
             raise util.SMException(
                 'VDI {} has children, can\'t delete'.format(self.uuid)
@@ -1602,32 +1634,38 @@ class LinstorVDI(VDI):
             self.sr.unlock()
         VDI.delete(self)
 
-    def validate(self, fast=False):
+    @override
+    def validate(self, fast=False) -> None:
         if not self.raw and not self.sr._vhdutil.check(self.uuid, fast=fast):
             raise util.SMException('VHD {} corrupted'.format(self))
 
-    def pause(self, failfast=False):
+    @override
+    def pause(self, failfast=False) -> None:
         self.sr._linstor.ensure_volume_is_not_locked(
             self.uuid, timeout=self.VOLUME_LOCK_TIMEOUT
         )
         return super(LinstorVDI, self).pause(failfast)
 
-    def coalesce(self):
+    @override
+    def coalesce(self) -> int:
         # Note: We raise `SMException` here to skip the current coalesce in case of failure.
         # Using another exception we can't execute the next coalesce calls.
         return self.sr._vhdutil.force_coalesce(self.path) * 512
 
-    def getParent(self):
+    @override
+    def getParent(self) -> str:
         return self.sr._vhdutil.get_parent(
             self.sr._linstor.get_volume_uuid_from_device_path(self.path)
         )
 
-    def repair(self, parent_uuid):
+    @override
+    def repair(self, parent_uuid) -> None:
         self.sr._vhdutil.force_repair(
             self.sr._linstor.get_device_path(parent_uuid)
         )
 
-    def _relinkSkip(self):
+    @override
+    def _relinkSkip(self) -> None:
         abortFlag = IPCFlag(self.sr.uuid)
         for child in self.children:
             if abortFlag.test(FLAG_TYPE_ABORT):
@@ -1651,7 +1689,8 @@ class LinstorVDI(VDI):
                 blktap2.VDI.tap_unpause(session, sr_uuid, vdi_uuid)
         self.children = []
 
-    def _setParent(self, parent):
+    @override
+    def _setParent(self, parent) -> None:
         self.sr._linstor.get_device_path(self.uuid)
         self.sr._vhdutil.force_parent(self.path, parent.path)
         self.parent = parent
@@ -1665,7 +1704,8 @@ class LinstorVDI(VDI):
             Util.log("Failed to update %s with vhd-parent field %s" % \
                      (self.uuid, self.parentUuid))
 
-    def _doCoalesce(self):
+    @override
+    def _doCoalesce(self) -> None:
         try:
             self._activateChain()
             self.parent.validate()
@@ -1685,7 +1725,8 @@ class LinstorVDI(VDI):
                 raise util.SMException(str(e))
             vdi = vdi.parent
 
-    def _setHidden(self, hidden=True):
+    @override
+    def _setHidden(self, hidden=True) -> None:
         HIDDEN_TAG = 'hidden'
 
         if self.raw:
@@ -1696,7 +1737,8 @@ class LinstorVDI(VDI):
         else:
             VDI._setHidden(self, hidden)
 
-    def _setSizeVirt(self, size):
+    @override
+    def _setSizeVirt(self, size) -> None:
         jfile = self.uuid + '-jvhd'
         self.sr._linstor.create_volume(
             jfile, vhdutil.MAX_VHD_JOURNAL_SIZE, persistent=False, volume_name=jfile
@@ -1711,7 +1753,8 @@ class LinstorVDI(VDI):
                 # We can ignore it, in any case this volume is not persistent.
                 pass
 
-    def _queryVHDBlocks(self):
+    @override
+    def _queryVHDBlocks(self) -> bytes:
         return self.sr._vhdutil.get_block_bitmap(self.uuid)
 
     def _inflateParentForCoalesce(self):
@@ -1721,7 +1764,8 @@ class LinstorVDI(VDI):
         if inc > 0:
             self.parent.inflate(self.parent.getDrbdSize() + inc)
 
-    def _calcExtraSpaceForCoalescing(self):
+    @override
+    def _calcExtraSpaceForCoalescing(self) -> int:
         if self.parent.raw:
             return 0
         size_coalesced = LinstorVhdUtil.compute_volume_size(
@@ -1730,14 +1774,16 @@ class LinstorVDI(VDI):
         Util.log("Coalesced size = %s" % Util.num2str(size_coalesced))
         return size_coalesced - self.parent.getDrbdSize()
 
-    def _calcExtraSpaceForLeafCoalescing(self):
+    @override
+    def _calcExtraSpaceForLeafCoalescing(self) -> int:
         assert self.getDrbdSize() > 0
         assert self.getSizeVHD() > 0
         deflate_diff = self.getDrbdSize() - LinstorVolumeManager.round_up_volume_size(self.getSizeVHD())
         assert deflate_diff >= 0
         return self._calcExtraSpaceForCoalescing() - deflate_diff
 
-    def _calcExtraSpaceForSnapshotCoalescing(self):
+    @override
+    def _calcExtraSpaceForSnapshotCoalescing(self) -> int:
         assert self.getSizeVHD() > 0
         return self._calcExtraSpaceForCoalescing() + \
             LinstorVolumeManager.round_up_volume_size(self.getSizeVHD())
@@ -1869,10 +1915,10 @@ class SR(object):
             return False
         return True
 
-    def scan(self, force=False):
+    def scan(self, force=False) -> None:
         """Scan the SR and load VDI info for each VDI. If called repeatedly,
         update VDI objects if they already exist"""
-        pass  # abstract
+        pass
 
     def scanLocked(self, force=False):
         self.lock()
@@ -2078,14 +2124,14 @@ class SR(object):
             vdiList.extend(vdi.getAllPrunable())
         return vdiList
 
-    def deleteVDIs(self, vdiList):
+    def deleteVDIs(self, vdiList) -> None:
         for vdi in vdiList:
             if IPCFlag(self.uuid).test(FLAG_TYPE_ABORT):
                 raise AbortException("Aborting due to signal")
             Util.log("Deleting unlinked VDI %s" % vdi)
             self.deleteVDI(vdi)
 
-    def deleteVDI(self, vdi):
+    def deleteVDI(self, vdi) -> None:
         assert(len(vdi.children) == 0)
         del self.vdis[vdi.uuid]
         if vdi.parent:
@@ -2094,10 +2140,10 @@ class SR(object):
             self.vdiTrees.remove(vdi)
         vdi.delete()
 
-    def forgetVDI(self, vdiUuid):
+    def forgetVDI(self, vdiUuid) -> None:
         self.xapi.forgetVDI(self.uuid, vdiUuid)
 
-    def pauseVDIs(self, vdiList):
+    def pauseVDIs(self, vdiList) -> None:
         paused = []
         failed = False
         for vdi in vdiList:
@@ -2124,14 +2170,15 @@ class SR(object):
         if failed:
             raise util.SMException("Failed to unpause VDIs")
 
-    def getFreeSpace(self):
+    def getFreeSpace(self) -> int:
         return 0
 
     def cleanup(self):
         Util.log("In cleanup")
         return
 
-    def __str__(self):
+    @override
+    def __str__(self) -> str:
         if self.name:
             ret = "%s ('%s')" % (self.uuid[0:4], self.name)
         else:
@@ -2166,7 +2213,7 @@ class SR(object):
         if self._locked == 0:
             self._srLock.release()
 
-    def needUpdateBlockInfo(self):
+    def needUpdateBlockInfo(self) -> bool:
         for vdi in self.vdis.values():
             if vdi.scanError or len(vdi.children) == 0:
                 continue
@@ -2174,7 +2221,7 @@ class SR(object):
                 return True
         return False
 
-    def updateBlockInfo(self):
+    def updateBlockInfo(self) -> None:
         for vdi in self.vdis.values():
             if vdi.scanError or len(vdi.children) == 0:
                 continue
@@ -2203,7 +2250,7 @@ class SR(object):
                 if not dryRun:
                     self.journaler.remove(t, uuid)
 
-    def cleanupCache(self, maxAge=-1):
+    def cleanupCache(self, maxAge=-1) -> int:
         return 0
 
     def _coalesce(self, vdi):
@@ -2436,7 +2483,7 @@ class SR(object):
             return False
         return True
 
-    def _liveLeafCoalesce(self, vdi):
+    def _liveLeafCoalesce(self, vdi) -> bool:
         util.fistpoint.activate("LVHDRT_coaleaf_delay_3", self.uuid)
         self.lock()
         try:
@@ -2537,44 +2584,43 @@ class SR(object):
         self._finishCoalesceLeaf(parent)
         self._updateSlavesOnResize(parent)
 
-    def _calcExtraSpaceNeeded(self, child, parent):
+    def _calcExtraSpaceNeeded(self, child, parent) -> int:
         assert(not parent.raw)  # raw parents not supported
         extra = child.getSizeVHD() - parent.getSizeVHD()
         if extra < 0:
             extra = 0
         return extra
 
-    def _prepareCoalesceLeaf(self, vdi):
+    def _prepareCoalesceLeaf(self, vdi) -> None:
         pass
 
-    def _updateNode(self, vdi):
+    def _updateNode(self, vdi) -> None:
         pass
 
-    def _finishCoalesceLeaf(self, parent):
+    def _finishCoalesceLeaf(self, parent) -> None:
         pass
 
-    def _updateSlavesOnUndoLeafCoalesce(self, parent, child):
+    def _updateSlavesOnUndoLeafCoalesce(self, parent, child) -> None:
         pass
 
-    def _updateSlavesOnRename(self, vdi, oldName, origParentUuid):
+    def _updateSlavesOnRename(self, vdi, oldName, origParentUuid) -> None:
         pass
 
-    def _updateSlavesOnResize(self, vdi):
+    def _updateSlavesOnResize(self, vdi) -> None:
         pass
 
-    def _removeStaleVDIs(self, uuidsPresent):
+    def _removeStaleVDIs(self, uuidsPresent) -> None:
         for uuid in list(self.vdis.keys()):
             if not uuid in uuidsPresent:
                 Util.log("VDI %s disappeared since last scan" % \
                         self.vdis[uuid])
                 del self.vdis[uuid]
 
-    def _handleInterruptedCoalesceLeaf(self):
+    def _handleInterruptedCoalesceLeaf(self) -> None:
         """An interrupted leaf-coalesce operation may leave the VHD tree in an
         inconsistent state. If the old-leaf VDI is still present, we revert the
         operation (in case the original error is persistent); otherwise we must
         finish the operation"""
-        # abstract
         pass
 
     def _buildTree(self, force):
@@ -2613,7 +2659,8 @@ class FileSR(SR):
         self.path = "/var/run/sr-mount/%s" % self.uuid
         self.journaler = fjournaler.Journaler(self.path)
 
-    def scan(self, force=False):
+    @override
+    def scan(self, force=False) -> None:
         if not util.pathexists(self.path):
             raise util.SMException("directory %s not found!" % self.uuid)
         vhds = self._scan(force)
@@ -2639,10 +2686,12 @@ class FileSR(SR):
         self.logFilter.logState()
         self._handleInterruptedCoalesceLeaf()
 
-    def getFreeSpace(self):
+    @override
+    def getFreeSpace(self) -> int:
         return util.get_fs_size(self.path) - util.get_fs_utilisation(self.path)
 
-    def deleteVDIs(self, vdiList):
+    @override
+    def deleteVDIs(self, vdiList) -> None:
         rootDeleted = False
         for vdi in vdiList:
             if not vdi.parent:
@@ -2652,7 +2701,8 @@ class FileSR(SR):
         if self.xapi.srRecord["type"] == "nfs" and rootDeleted:
             self.xapi.markCacheSRsDirty()
 
-    def cleanupCache(self, maxAge=-1):
+    @override
+    def cleanupCache(self, maxAge=-1) -> int:
         """Clean up IntelliCache cache files. Caches for leaf nodes are
         removed when the leaf node no longer exists or its allow-caching
         attribute is not set. Caches for parent nodes are removed when the
@@ -2741,7 +2791,8 @@ class FileSR(SR):
             return vhds
         raise util.SMException("Scan error")
 
-    def deleteVDI(self, vdi):
+    @override
+    def deleteVDI(self, vdi) -> None:
         self._checkSlaves(vdi)
         SR.deleteVDI(self, vdi)
 
@@ -2766,7 +2817,8 @@ class FileSR(SR):
         _host = self.xapi.session.xenapi.host
         text = _host.call_plugin( * call)
 
-    def _handleInterruptedCoalesceLeaf(self):
+    @override
+    def _handleInterruptedCoalesceLeaf(self) -> None:
         entries = self.journaler.getAll(VDI.JRN_LEAF)
         for uuid, parentUuid in entries.items():
             fileList = os.listdir(self.path)
@@ -2850,26 +2902,31 @@ class LVHDSR(SR):
         self.lvActivator = LVActivator(self.uuid, self.lvmCache)
         self.journaler = journaler.Journaler(self.lvmCache)
 
-    def deleteVDI(self, vdi):
+    @override
+    def deleteVDI(self, vdi) -> None:
         if self.lvActivator.get(vdi.uuid, False):
             self.lvActivator.deactivate(vdi.uuid, False)
         self._checkSlaves(vdi)
         SR.deleteVDI(self, vdi)
 
-    def forgetVDI(self, vdiUuid):
+    @override
+    def forgetVDI(self, vdiUuid) -> None:
         SR.forgetVDI(self, vdiUuid)
         mdpath = os.path.join(self.path, lvutil.MDVOLUME_NAME)
         LVMMetadataHandler(mdpath).deleteVdiFromMetadata(vdiUuid)
 
-    def getFreeSpace(self):
+    @override
+    def getFreeSpace(self) -> int:
         stats = lvutil._getVGstats(self.vgName)
         return stats['physical_size'] - stats['physical_utilisation']
 
+    @override
     def cleanup(self):
         if not self.lvActivator.deactivateAll():
             Util.log("ERROR deactivating LVs while cleaning up")
 
-    def needUpdateBlockInfo(self):
+    @override
+    def needUpdateBlockInfo(self) -> bool:
         for vdi in self.vdis.values():
             if vdi.scanError or vdi.raw or len(vdi.children) == 0:
                 continue
@@ -2877,7 +2934,8 @@ class LVHDSR(SR):
                 return True
         return False
 
-    def updateBlockInfo(self):
+    @override
+    def updateBlockInfo(self) -> None:
         numUpdated = 0
         for vdi in self.vdis.values():
             if vdi.scanError or vdi.raw or len(vdi.children) == 0:
@@ -2892,7 +2950,8 @@ class LVHDSR(SR):
             # inherit the refcount value and preventing the correct decrement
             self.cleanup()
 
-    def scan(self, force=False):
+    @override
+    def scan(self, force=False) -> None:
         vdis = self._scan(force)
         for uuid, vdiInfo in vdis.items():
             vdi = self.getVDI(uuid)
@@ -2923,7 +2982,8 @@ class LVHDSR(SR):
             return vdis
         raise util.SMException("Scan error")
 
-    def _removeStaleVDIs(self, uuidsPresent):
+    @override
+    def _removeStaleVDIs(self, uuidsPresent) -> None:
         for uuid in list(self.vdis.keys()):
             if not uuid in uuidsPresent:
                 Util.log("VDI %s disappeared since last scan" % \
@@ -2932,7 +2992,8 @@ class LVHDSR(SR):
                 if self.lvActivator.get(uuid, False):
                     self.lvActivator.remove(uuid, False)
 
-    def _liveLeafCoalesce(self, vdi):
+    @override
+    def _liveLeafCoalesce(self, vdi) -> bool:
         """If the parent is raw and the child was resized (virt. size), then
         we'll need to resize the parent, which can take a while due to zeroing
         out of the extended portion of the LV. Do it before pausing the child
@@ -2943,13 +3004,15 @@ class LVHDSR(SR):
 
         return SR._liveLeafCoalesce(self, vdi)
 
-    def _prepareCoalesceLeaf(self, vdi):
+    @override
+    def _prepareCoalesceLeaf(self, vdi) -> None:
         vdi._activateChain()
         self.lvmCache.setReadonly(vdi.parent.fileName, False)
         vdi.deflate()
         vdi.inflateParentForCoalesce()
 
-    def _updateNode(self, vdi):
+    @override
+    def _updateNode(self, vdi) -> None:
         # fix the refcounts: the remaining node should inherit the binary
         # refcount from the leaf (because if it was online, it should remain
         # refcounted as such), but the normal refcount from the parent (because
@@ -2963,16 +3026,19 @@ class LVHDSR(SR):
         assert(pCnt >= 0)
         RefCounter.set(vdi.parent.uuid, pCnt, cBcnt, ns)
 
-    def _finishCoalesceLeaf(self, parent):
+    @override
+    def _finishCoalesceLeaf(self, parent) -> None:
         if not parent.isSnapshot() or parent.isAttachedRW():
             parent.inflateFully()
         else:
             parent.deflate()
 
-    def _calcExtraSpaceNeeded(self, child, parent):
+    @override
+    def _calcExtraSpaceNeeded(self, child, parent) -> int:
         return lvhdutil.calcSizeVHDLV(parent.sizeVirt) - parent.sizeLV
 
-    def _handleInterruptedCoalesceLeaf(self):
+    @override
+    def _handleInterruptedCoalesceLeaf(self) -> None:
         entries = self.journaler.getAll(VDI.JRN_LEAF)
         for uuid, parentUuid in entries.items():
             childLV = lvhdutil.LV_PREFIX[vhdutil.VDI_TYPE_VHD] + uuid
@@ -3083,7 +3149,8 @@ class LVHDSR(SR):
                 if hostRef in onlineHosts:
                     raise
 
-    def _updateSlavesOnUndoLeafCoalesce(self, parent, child):
+    @override
+    def _updateSlavesOnUndoLeafCoalesce(self, parent, child) -> None:
         slaves = util.get_slaves_attached_on(self.xapi.session, [child.uuid])
         if not slaves:
             Util.log("Update-on-leaf-undo: VDI %s not attached on any slave" % \
@@ -3109,7 +3176,8 @@ class LVHDSR(SR):
                     slave, self.xapi.PLUGIN_ON_SLAVE, "multi", args)
             Util.log("call-plugin returned: '%s'" % text)
 
-    def _updateSlavesOnRename(self, vdi, oldNameLV, origParentUuid):
+    @override
+    def _updateSlavesOnRename(self, vdi, oldNameLV, origParentUuid) -> None:
         slaves = util.get_slaves_attached_on(self.xapi.session, [vdi.uuid])
         if not slaves:
             Util.log("Update-on-rename: VDI %s not attached on any slave" % vdi)
@@ -3131,7 +3199,8 @@ class LVHDSR(SR):
                     slave, self.xapi.PLUGIN_ON_SLAVE, "multi", args)
             Util.log("call-plugin returned: '%s'" % text)
 
-    def _updateSlavesOnResize(self, vdi):
+    @override
+    def _updateSlavesOnResize(self, vdi) -> None:
         uuids = [x.uuid for x in vdi.getAllLeaves()]
         slaves = util.get_slaves_attached_on(self.xapi.session, uuids)
         if not slaves:
@@ -3154,14 +3223,17 @@ class LinstorSR(SR):
         self.path = LinstorVolumeManager.DEV_ROOT_PATH
         self._reloadLinstor()
 
-    def deleteVDI(self, vdi):
+    @override
+    def deleteVDI(self, vdi) -> None:
         self._checkSlaves(vdi)
         SR.deleteVDI(self, vdi)
 
-    def getFreeSpace(self):
+    @override
+    def getFreeSpace(self) -> int:
         return self._linstor.max_volume_size_allowed
 
-    def scan(self, force=False):
+    @override
+    def scan(self, force=False) -> None:
         all_vdi_info = self._scan(force)
         for uuid, vdiInfo in all_vdi_info.items():
             # When vdiInfo is None, the VDI is RAW.
@@ -3177,7 +3249,8 @@ class LinstorSR(SR):
         self.logFilter.logState()
         self._handleInterruptedCoalesceLeaf()
 
-    def pauseVDIs(self, vdiList):
+    @override
+    def pauseVDIs(self, vdiList) -> None:
         self._linstor.ensure_volume_list_is_not_locked(
             vdiList, timeout=LinstorVDI.VOLUME_LOCK_TIMEOUT
         )
@@ -3294,18 +3367,21 @@ class LinstorSR(SR):
 
         return all_vdi_info
 
-    def _prepareCoalesceLeaf(self, vdi):
+    @override
+    def _prepareCoalesceLeaf(self, vdi) -> None:
         vdi._activateChain()
         vdi.deflate()
         vdi._inflateParentForCoalesce()
 
-    def _finishCoalesceLeaf(self, parent):
+    @override
+    def _finishCoalesceLeaf(self, parent) -> None:
         if not parent.isSnapshot() or parent.isAttachedRW():
             parent.inflateFully()
         else:
             parent.deflate()
 
-    def _calcExtraSpaceNeeded(self, child, parent):
+    @override
+    def _calcExtraSpaceNeeded(self, child, parent) -> int:
         return LinstorVhdUtil.compute_volume_size(parent.sizeVirt, parent.vdi_type) - parent.getDrbdSize()
 
     def _hasValidDevicePath(self, uuid):
@@ -3316,7 +3392,8 @@ class LinstorSR(SR):
             return False
         return True
 
-    def _liveLeafCoalesce(self, vdi):
+    @override
+    def _liveLeafCoalesce(self, vdi) -> bool:
         self.lock()
         try:
             self._linstor.ensure_volume_is_not_locked(
@@ -3326,7 +3403,8 @@ class LinstorSR(SR):
         finally:
             self.unlock()
 
-    def _handleInterruptedCoalesceLeaf(self):
+    @override
+    def _handleInterruptedCoalesceLeaf(self) -> None:
         entries = self.journaler.get_all(VDI.JRN_LEAF)
         for uuid, parentUuid in entries.items():
             if self._hasValidDevicePath(parentUuid) or \
diff --git a/drivers/flock.py b/drivers/flock.py
index 2d295ec4..a853da27 100644
--- a/drivers/flock.py
+++ b/drivers/flock.py
@@ -23,7 +23,7 @@ testing and trying of locks isn't well supported. Looks as if we've
 got to grow our own.
 """
 
-from sm_typing import ClassVar
+from sm_typing import ClassVar, override
 
 import os
 import fcntl
@@ -62,7 +62,8 @@ class Flock:
         idx = self.FIELDS[name]
         return self.fields[idx]
 
-    def __setattr__(self, name, value):
+    @override
+    def __setattr__(self, name, value) -> None:
         idx = self.FIELDS.get(name)
         if idx is None:
             self.__dict__[name] = value
diff --git a/drivers/lcache.py b/drivers/lcache.py
index f1e25c36..1b7c78f2 100755
--- a/drivers/lcache.py
+++ b/drivers/lcache.py
@@ -15,6 +15,8 @@
 # along with this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 
+from sm_typing import override
+
 import os
 import blktap2
 import glob
@@ -71,7 +73,8 @@ class CachingTap(object):
             self.tapdisk = tapdisk
             self.stats = stats
 
-        def __str__(self):
+        @override
+        def __str__(self) -> str:
             return \
                 "Tapdisk %s in state '%s' not found caching." % \
                 (self.tapdisk, self.stats)
@@ -116,7 +119,8 @@ class ParentCachingTap(CachingTap):
 
         return rd_hits, rd_miss, wr_rdir
 
-    def __str__(self):
+    @override
+    def __str__(self) -> str:
         return "%s(%s, minor=%s)" % \
             (self.__class__.__name__,
              self.tapdisk.path, self.tapdisk.minor)
@@ -144,7 +148,8 @@ class LeafCachingTap(CachingTap):
 
         return rd_hits, rd_miss, wr_rdir
 
-    def __str__(self):
+    @override
+    def __str__(self) -> str:
         return "%s(%s, minor=%s)" % \
             (self.__class__.__name__,
              self.tapdisk.path, self.tapdisk.minor)
@@ -166,7 +171,8 @@ class CacheFileSR(object):
         def __init__(self, path):
             self.path = path
 
-        def __str__(self):
+        @override
+        def __str__(self) -> str:
             return "Not a mount point: %s" % self.path
 
     @classmethod
diff --git a/drivers/linstorvhdutil.py b/drivers/linstorvhdutil.py
index 6ad4787d..c33c24c0 100644
--- a/drivers/linstorvhdutil.py
+++ b/drivers/linstorvhdutil.py
@@ -14,6 +14,8 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
+from sm_typing import override
+
 from linstorjournaler import LinstorJournaler
 from linstorvolumemanager import LinstorVolumeManager
 import base64
@@ -60,7 +62,8 @@ class LinstorCallException(util.SMException):
     def __init__(self, cmd_err):
         self.cmd_err = cmd_err
 
-    def __str__(self):
+    @override
+    def __str__(self) -> str:
         return str(self.cmd_err)
 
 
diff --git a/drivers/linstorvolumemanager.py b/drivers/linstorvolumemanager.py
index 55327254..5b7da10a 100755
--- a/drivers/linstorvolumemanager.py
+++ b/drivers/linstorvolumemanager.py
@@ -15,6 +15,7 @@
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 #
 
+from sm_typing import override
 
 import errno
 import json
@@ -375,7 +376,8 @@ class LinstorVolumeManager(object):
             self.virtual_size = 0
             self.diskful = []
 
-        def __repr__(self):
+        @override
+        def __repr__(self) -> str:
             return 'VolumeInfo("{}", {}, {}, {})'.format(
                 self.name, self.allocated_size, self.virtual_size,
                 self.diskful
diff --git a/drivers/lock.py b/drivers/lock.py
index 2e6e2c9c..6792d7b0 100755
--- a/drivers/lock.py
+++ b/drivers/lock.py
@@ -194,7 +194,7 @@ class LockImplementation(object):
         fd = self.lockfile.fileno()
         self.lock = flock.WriteLock(fd)
 
-    def _open_lockfile(self):
+    def _open_lockfile(self) -> None:
         """Provide a seam, so extreme situations could be tested"""
         util.SMlog("lock: opening lock file %s" % self.lockpath)
         self.lockfile = open(self.lockpath, "w+")
diff --git a/drivers/mpath_cli.py b/drivers/mpath_cli.py
index 4c7ce54a..357e84a0 100755
--- a/drivers/mpath_cli.py
+++ b/drivers/mpath_cli.py
@@ -15,6 +15,8 @@
 #
 # Talk to the multipathd cli
 
+from sm_typing import override
+
 import util
 import re
 import time
@@ -25,7 +27,8 @@ class MPathCLIFail(Exception):
     def __init__(self):
         return
 
-    def __str__(self):
+    @override
+    def __str__(self) -> str:
         return "MPath CLI failed"
 
 mpathcmd = ["/usr/sbin/multipathd", "-k"]
diff --git a/drivers/nfs-on-slave b/drivers/nfs-on-slave
index 3e2ee8d3..71837724 100644
--- a/drivers/nfs-on-slave
+++ b/drivers/nfs-on-slave
@@ -18,6 +18,9 @@
 # A plugin for synchronizing slaves when something changes on the Master
 
 import sys; sys.path.append("/opt/xensource/sm/")
+
+from sm_typing import override
+
 import util
 import os, glob, errno
 
@@ -31,7 +34,8 @@ class NfsCheckException(Exception):
         except:
             self.exe = None
 
-    def __str__(self):
+    @override
+    def __str__(self) -> str:
         return "File %s in use by pid %d (%s), fd %d" % \
             (self.path, self.pid, self.exe, self.fd)
 
diff --git a/drivers/srmetadata.py b/drivers/srmetadata.py
index c80fb6d7..34aa5f16 100755
--- a/drivers/srmetadata.py
+++ b/drivers/srmetadata.py
@@ -16,7 +16,9 @@
 # Functions to read and write SR metadata
 #
 
-from sm_typing import ClassVar
+from sm_typing import ClassVar, override
+
+from abc import abstractmethod
 
 from io import SEEK_SET
 
@@ -275,8 +277,9 @@ class MetadataHandler:
     def vdi_info_size(self):
         return self.VDI_INFO_SIZE_IN_SECTORS * SECTOR_SIZE
 
-    def spaceAvailableForVdis(self, count):
-        raise NotImplementedError("spaceAvailableForVdis is undefined")
+    @abstractmethod
+    def spaceAvailableForVdis(self, count) -> None:
+        pass
 
     # common utility functions
     def getMetadata(self, params={}):
@@ -660,10 +663,10 @@ class MetadataHandler:
             raise
 
     # specific functions, to be implement by the child classes
-    def getVdiInfo(self, Dict, generateSector=0):
+    def getVdiInfo(self, Dict, generateSector=0) -> bytes:
         return b""
 
-    def getSRInfoForSectors(self, sr_info, range):
+    def getSRInfoForSectors(self, sr_info, range) -> bytes:
         return b""
 
 
@@ -676,7 +679,8 @@ class LVMMetadataHandler(MetadataHandler):
         lvutil.ensurePathExists(path)
         MetadataHandler.__init__(self, path, write)
 
-    def spaceAvailableForVdis(self, count):
+    @override
+    def spaceAvailableForVdis(self, count) -> None:
         created = False
         try:
             # The easiest way to do this, is to create a dummy vdi and write it
@@ -707,7 +711,8 @@ class LVMMetadataHandler(MetadataHandler):
     # it also takes in a parameter to determine whether both the sector
     # or only one sector needs to be generated, and which one
     # generateSector - can be 1 or 2, defaults to 0 and generates both sectors
-    def getVdiInfo(self, Dict, generateSector=0):
+    @override
+    def getVdiInfo(self, Dict, generateSector=0) -> bytes:
         util.SMlog("Entering VDI info")
         try:
             vdi_info = b""
@@ -763,7 +768,8 @@ class LVMMetadataHandler(MetadataHandler):
                        (Dict, str(e)))
             raise
 
-    def getSRInfoForSectors(self, sr_info, range):
+    @override
+    def getSRInfoForSectors(self, sr_info, range) -> bytes:
         srinfo = b""
 
         try:
diff --git a/drivers/udevSR.py b/drivers/udevSR.py
index 4862ef8b..a8442764 100755
--- a/drivers/udevSR.py
+++ b/drivers/udevSR.py
@@ -18,6 +18,8 @@
 # udevSR: represents VDIs which are hotplugged into dom0 via udev e.g.
 #         USB CDROM/disk devices
 
+from sm_typing import override
+
 import SR
 import VDI
 import SRCommand
@@ -50,16 +52,19 @@ TYPE = 'udev'
 class udevSR(SR.SR):
     """udev-driven storage repository"""
 
-    def handles(type):
+    @override
+    @staticmethod
+    def handles(type) -> bool:
         if type == TYPE:
             return True
         return False
-    handles = staticmethod(handles)
 
-    def content_type(self, sr_uuid):
+    @override
+    def content_type(self, sr_uuid) -> str:
         return super(udevSR, self).content_type(sr_uuid)
 
-    def vdi(self, uuid):
+    @override
+    def vdi(self, uuid) -> VDI.VDI:
         util.SMlog("params = %s" % (self.srcmd.params.keys()))
 
         if 'vdi_location' in self.srcmd.params:
@@ -74,7 +79,8 @@ class udevSR(SR.SR):
         vdi_ref = vdi.get_by_uuid(uuid)
         return vdi.get_location(vdi_ref)
 
-    def load(self, sr_uuid):
+    @override
+    def load(self, sr_uuid) -> None:
         # First of all, check we've got the correct keys in dconf
         if 'location' not in self.dconf:
             raise xs_errors.XenError('ConfigLocationMissing')
@@ -82,7 +88,8 @@ class udevSR(SR.SR):
         # Cache the sm_config
         self.sm_config = self.session.xenapi.SR.get_sm_config(self.sr_ref)
 
-    def update(self, sr_uuid):
+    @override
+    def update(self, sr_uuid) -> None:
         # Return as much information as we have
         sr_root = self.dconf['location']
 
@@ -102,22 +109,27 @@ class udevSR(SR.SR):
 
         self._db_update()
 
-    def scan(self, sr_uuid):
+    @override
+    def scan(self, sr_uuid) -> None:
         self.update(sr_uuid)
 
         # base class scan does all the work:
-        return super(udevSR, self).scan(sr_uuid)
+        super(udevSR, self).scan(sr_uuid)
 
-    def create(self, sr_uuid, size):
+    @override
+    def create(self, sr_uuid, size) -> None:
         pass
 
-    def delete(self, sr_uuid):
+    @override
+    def delete(self, sr_uuid) -> None:
         pass
 
-    def attach(self, sr_uuid):
+    @override
+    def attach(self, sr_uuid) -> None:
         pass
 
-    def detach(self, sr_uuid):
+    @override
+    def detach(self, sr_uuid) -> None:
         pass
 
 
@@ -134,7 +146,8 @@ class udevVDI(VDI.VDI):
         self.location = location
         VDI.VDI.__init__(self, sr, None)
 
-    def load(self, location):
+    @override
+    def load(self, location) -> None:
         self.path = self.location
         self.size = 0
         self.utilisation = 0
@@ -149,7 +162,7 @@ class udevVDI(VDI.VDI):
             self.sm_config['hotplugged_at'] = iso8601
 
             self.path = os.path.realpath(self.path)
-	
+
             dev = os.path.basename(self.path)
             info = sysdevice.stat(dev)
             if "size" in info.keys():
@@ -176,7 +189,8 @@ class udevVDI(VDI.VDI):
         except OSError as e:
             self.deleted = True
 
-    def introduce(self, sr_uuid, vdi_uuid):
+    @override
+    def introduce(self, sr_uuid, vdi_uuid) -> str:
         self.uuid = vdi_uuid
         self.location = self.sr.srcmd.params['vdi_location']
         self._db_introduce()
@@ -184,7 +198,8 @@ class udevVDI(VDI.VDI):
         self.sr.update(sr_uuid)
         return super(udevVDI, self).get_params()
 
-    def update(self, sr_uuid, vdi_location):
+    @override
+    def update(self, sr_uuid, vdi_location) -> None:
         self.load(vdi_location)
         # _db_update requires self.uuid to be set
         self.uuid = self.sr.srcmd.params['vdi_uuid']
@@ -198,13 +213,15 @@ class udevVDI(VDI.VDI):
         #self.sr.session.xenapi.VDI.set_name_label(vdi, self.label)
         #self.sr.session.xenapi.VDI.set_name_description(vdi, self.description)
 
-    def attach(self, sr_uuid, vdi_uuid):
+    @override
+    def attach(self, sr_uuid, vdi_uuid) -> str:
         if self.deleted:
             raise xs_errors.XenError('VDIUnavailable')
 
         return super(udevVDI, self).attach(sr_uuid, vdi_uuid)
 
-    def detach(self, sr_uuid, vdi_uuid):
+    @override
+    def detach(self, sr_uuid, vdi_uuid) -> None:
         pass
 
 if __name__ == '__main__':
diff --git a/misc/fairlock/fairlock.py b/misc/fairlock/fairlock.py
index 391fbea3..1a3352e4 100644
--- a/misc/fairlock/fairlock.py
+++ b/misc/fairlock/fairlock.py
@@ -1,4 +1,4 @@
-from sm_typing import Any, Callable, Dict, Optional
+from sm_typing import Any, Callable, Dict, Optional, override
 
 import os
 import socket
@@ -15,10 +15,11 @@ class SingletonWithArgs(type):
     def __init__(cls, name, bases, dct):
         cls._init[cls] = dct.get('__init__', None)
 
-    def __call__(cls, *args, **kwargs):
+    @override
+    def __call__(cls, *args, **kwargs) -> Any:
         init = cls._init[cls]
         if init is not None:
-            key = (cls, frozenset(
+            key: Any = (cls, frozenset(
                     inspect.getcallargs(init, None, *args, **kwargs).items()))
         else:
             key = cls
diff --git a/sm_typing/__init__.py b/sm_typing/__init__.py
index c515056c..2042dea6 100644
--- a/sm_typing/__init__.py
+++ b/sm_typing/__init__.py
@@ -1,2 +1,14 @@
 import typing
 from typing import *
+
+if not hasattr(typing, 'override'):
+    def override(method): # type: ignore
+        try:
+            # Set internal attr `__override__` like described in PEP 698.
+            method.__override__ = True
+        except (AttributeError, TypeError):
+            pass
+        return method
+
+if not hasattr(typing, 'Never'):
+    Never = None # type: ignore
diff --git a/stubs/XenAPIPlugin.pyi b/stubs/XenAPIPlugin.pyi
index ca5f52ca..72bad09f 100644
--- a/stubs/XenAPIPlugin.pyi
+++ b/stubs/XenAPIPlugin.pyi
@@ -1,5 +1,5 @@
 class Failure(Exception):
     def __init__(self, code, params) -> None: ...
-    def __str__(self) -> str: ...
+    def __str__(self) -> str: ... # type: ignore
 
 def dispatch(fn_table) -> None: ...
diff --git a/tests/lvmlib.py b/tests/lvmlib.py
index c57b32e0..6ec8d2c7 100644
--- a/tests/lvmlib.py
+++ b/tests/lvmlib.py
@@ -1,3 +1,5 @@
+from sm_typing import Never, override
+
 import argparse
 import sys
 
@@ -7,10 +9,12 @@ class TestArgParse(argparse.ArgumentParser):
     to stderr during the tests
     """
 
-    def exit(self, status=0, msg=None):
+    @override
+    def exit(self, status=0, msg=None) -> Never:
         sys.exit(status)
 
-    def error(self, msg):
+    @override
+    def error(self, msg) -> Never:
         """error(msg : string)"""
         self.exit(2, "%s: error: %s\n" % (self.prog, msg))
 
diff --git a/tests/shared_iscsi_test_base.py b/tests/shared_iscsi_test_base.py
index a6555547..b224d30d 100644
--- a/tests/shared_iscsi_test_base.py
+++ b/tests/shared_iscsi_test_base.py
@@ -1,3 +1,5 @@
+from sm_typing import Dict, List, Tuple, override
+
 import unittest
 from unittest import mock
 
@@ -6,8 +8,11 @@ from SRCommand import SRCommand
 
 
 class ISCSITestCase(unittest.TestCase):
+    # Declared in subclasses.
+    TEST_CLASS: str
 
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         iscsilib_patcher = mock.patch(f'{self.TEST_CLASS}.iscsilib',
                                       autospec=True)
         self.mock_iscsilib = iscsilib_patcher.start()
@@ -15,8 +20,8 @@ class ISCSITestCase(unittest.TestCase):
         self.mock_iscsilib._checkTGT.side_effect = self._checkTGT
         self.mock_iscsilib.login.side_effect = self.iscsi_login
         self.mock_iscsilib.parse_IP_port = iscsilib.parse_IP_port
-        self.discovery_data = {}
-        self.sessions = []
+        self.discovery_data: Dict[str, Tuple[str, int, str]] = {}
+        self.sessions: List[str] = []
 
         sleep_patcher = mock.patch(f'{self.TEST_CLASS}.time.sleep',
                                    autospec=True)
diff --git a/tests/test_BaseISCSI.py b/tests/test_BaseISCSI.py
index cc489a46..7c4ed83f 100644
--- a/tests/test_BaseISCSI.py
+++ b/tests/test_BaseISCSI.py
@@ -2,6 +2,8 @@
 Unit tests for the Base ISCSI SR
 """
 
+from sm_typing import override
+
 from unittest import mock
 from uuid import uuid4
 
@@ -15,7 +17,8 @@ class TestBaseISCSI(ISCSITestCase):
 
     TEST_CLASS = 'BaseISCSI'
 
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         self.addCleanup(mock.patch.stopall)
 
         util_patcher = mock.patch('BaseISCSI.util', autospec=True)
diff --git a/tests/test_FileSR.py b/tests/test_FileSR.py
index a82d0e5b..109f6d30 100644
--- a/tests/test_FileSR.py
+++ b/tests/test_FileSR.py
@@ -1,3 +1,5 @@
+from sm_typing import Any, Optional, Set, override
+
 import errno
 import os
 import stat
@@ -18,7 +20,8 @@ import xs_errors
 
 
 class FakeFileVDI(FileSR.FileVDI):
-    def load(self, uuid):
+    @override
+    def load(self, uuid) -> None:
         self.vdi_type = vhdutil.VDI_TYPE_VHD
         self.hidden = False
         self.path = os.path.join(self.sr.path, '%s.%s' % (
@@ -27,7 +30,8 @@ class FakeFileVDI(FileSR.FileVDI):
 
 
 class TestFileVDI(unittest.TestCase):
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         startlog_patcher = mock.patch('FileSR.util.start_log_entry',
                                         autospec=True)
         self.mock_startlog = startlog_patcher.start()
@@ -50,7 +54,7 @@ class TestFileVDI(unittest.TestCase):
         fist_patcher = mock.patch('FileSR.util.FistPoint.is_active',
                                   autospec=True)
         self.mock_fist = fist_patcher.start()
-        self.active_fists = set()
+        self.active_fists: Set[Any] = set()
         def active_fists():
             return self.active_fists
 
@@ -419,15 +423,19 @@ class FakeSharedFileSR(FileSR.SharedFileSR):
     """
     Test SR class for SharedFileSR
     """
-    def load(self, sr_uuid):
+
+    @override
+    def load(self, sr_uuid) -> None:
         self.path = os.path.join(SR.MOUNT_BASE, sr_uuid)
-        self.lock = None
+        self.lock = None # type: ignore
 
-    def attach(self, sr_uuid):
+    @override
+    def attach(self, sr_uuid) -> None:
         self._check_writable()
         self._check_hardlinks()
 
-    def _read_hardlink_conf(self):
+    @override
+    def _read_hardlink_conf(self) -> Optional[bool]:
         return None
 
 class TestShareFileSR(unittest.TestCase):
@@ -437,7 +445,8 @@ class TestShareFileSR(unittest.TestCase):
     TEST_SR_REF = "test_sr_ref"
     ERROR_524 = "Unknown error 524"
 
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         util_patcher = mock.patch('FileSR.util', autospec=True)
         self.mock_util = util_patcher.start()
 
@@ -561,7 +570,8 @@ class TestShareFileSR(unittest.TestCase):
         self.assertEqual(1, len(test_sr.vdis))
 
 class TestFileSR(unittest.TestCase):
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         pread_patcher = mock.patch('FileSR.util.pread')
         self.mock_pread = pread_patcher.start()
 
diff --git a/tests/test_ISCSISR.py b/tests/test_ISCSISR.py
index e71ac268..9af3d4bc 100644
--- a/tests/test_ISCSISR.py
+++ b/tests/test_ISCSISR.py
@@ -1,3 +1,5 @@
+from sm_typing import override
+
 import unittest
 import BaseISCSI
 import unittest.mock as mock
@@ -8,17 +10,20 @@ import os
 class TestBase(unittest.TestCase):
     """ Provides errorcodes.xml, so exceptions are sensible """
 
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         self._xmldefs = xs_errors.XML_DEFS
         xs_errors.XML_DEFS = os.path.join(
             os.path.dirname(__file__), 'XE_SR_ERRORCODES.xml')
 
-    def tearDown(self):
+    @override
+    def tearDown(self) -> None:
         xs_errors.XML_DEFS = self._xmldefs
 
 
 class NonLoadingISCSISR(BaseISCSI.BaseISCSISR):
-    def load(self, sr_uuid):
+    @override
+    def load(self, sr_uuid) -> None:
         pass
 
 
@@ -82,10 +87,12 @@ class NonInitingMultiLUNISCSISR(BaseISCSI.BaseISCSISR):
             extra_adapter: None
         }
 
-    def _synchroniseAddrList(self, *args, **kwargs):
+    @override
+    def _synchroniseAddrList(self, *args, **kwargs) -> None:
         pass
 
-    def _init_adapters(self):
+    @override
+    def _init_adapters(self) -> None:
         pass
 
 
@@ -115,8 +122,8 @@ class TestVdiTypeSetting(TestBase):
 
 
 class TestMultiLUNISCSISR(unittest.TestCase):
-
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         self.node1 = {
             'ip': '127.0.0.1',
             'port': 3260,
diff --git a/tests/test_LVHDSR.py b/tests/test_LVHDSR.py
index 94a390d3..5dc5066c 100644
--- a/tests/test_LVHDSR.py
+++ b/tests/test_LVHDSR.py
@@ -1,3 +1,5 @@
+from sm_typing import override
+
 import os
 import unittest
 import unittest.mock as mock
@@ -34,11 +36,12 @@ class Stubs(object):
 
 
 class TestLVHDSR(unittest.TestCase, Stubs):
-
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         self.init_stubs()
 
-    def tearDown(self):
+    @override
+    def tearDown(self) -> None:
         self.remove_stubs()
 
     def create_LVHDSR(self, master=False, command='foo', sr_uuid=None):
@@ -249,8 +252,8 @@ class TestLVHDSR(unittest.TestCase, Stubs):
 
 
 class TestLVHDVDI(unittest.TestCase, Stubs):
-
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         self.init_stubs()
 
         lvhdutil_patcher = mock.patch('LVHDSR.lvhdutil', autospec=True)
@@ -287,7 +290,8 @@ class TestLVHDVDI(unittest.TestCase, Stubs):
 
         self.addCleanup(mock.patch.stopall)
 
-    def tearDown(self):
+    @override
+    def tearDown(self) -> None:
         self.remove_stubs()
 
     def create_LVHDSR(self):
diff --git a/tests/test_LVHDoHBASR.py b/tests/test_LVHDoHBASR.py
index 3bc7196b..da88e461 100644
--- a/tests/test_LVHDoHBASR.py
+++ b/tests/test_LVHDoHBASR.py
@@ -1,3 +1,5 @@
+from sm_typing import override
+
 import unittest.mock as mock
 import LVHDoHBASR
 import unittest
@@ -72,8 +74,8 @@ class TestLVHDoHBAVDI(unittest.TestCase):
 
 
 class TestLVHDoHBASR(unittest.TestCase):
-
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         self.host_ref = str(uuid4())
         self.session_ref = str(uuid4())
         self.sr_ref = str(uuid4())
diff --git a/tests/test_LVHDoISCSISR.py b/tests/test_LVHDoISCSISR.py
index 3b5e1c42..ec71f20d 100644
--- a/tests/test_LVHDoISCSISR.py
+++ b/tests/test_LVHDoISCSISR.py
@@ -1,3 +1,5 @@
+from sm_typing import Set, override
+
 import os
 import unittest
 import unittest.mock as mock
@@ -62,7 +64,8 @@ class TestLVHDoISCSISR_load(unittest.TestCase):
     Tests for 'LVHDoISCSISR.load()'
     """
 
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         patchers = [
             mock.patch(
                 'BaseISCSI.BaseISCSISR',
@@ -124,14 +127,15 @@ class TestLVHDoISCSISR(ISCSITestCase):
 
     TEST_CLASS = 'LVHDoISCSISR'
 
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         util_patcher = mock.patch('LVHDoISCSISR.util', autospec=True)
         self.mock_util = util_patcher.start()
         # self.mock_util.SMlog.side_effect = print
         self.mock_util.isVDICommand = util.isVDICommand
         self.mock_util.sessions_less_than_targets = util.sessions_less_than_targets
 
-        self.base_srs = set()
+        self.base_srs: Set[BaseISCSISR] = set()
         baseiscsi_patcher = mock.patch('LVHDoISCSISR.BaseISCSI.BaseISCSISR',
                                        autospec=True)
         patched_baseiscsi = baseiscsi_patcher.start()
diff --git a/tests/test_SMBSR.py b/tests/test_SMBSR.py
index 4cfd2733..42ce035e 100644
--- a/tests/test_SMBSR.py
+++ b/tests/test_SMBSR.py
@@ -1,3 +1,5 @@
+from sm_typing import Dict, override
+
 import unittest
 import unittest.mock as mock
 import uuid
@@ -25,14 +27,14 @@ class FakeSMBSR(SMBSR.SMBSR):
 
 
 class Test_SMBSR(unittest.TestCase):
-
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         self.addCleanup(mock.patch.stopall)
 
         pread_patcher = mock.patch('SMBSR.util.pread', autospec=True)
         self.mock_pread = pread_patcher.start()
         self.mock_pread.side_effect = self.pread
-        self.pread_results = {}
+        self.pread_results: Dict[str, str] = {}
 
         listdir_patcher = mock.patch('SMBSR.util.listdir', autospec=True)
         self.mock_list_dir = listdir_patcher.start()
diff --git a/tests/test_SR.py b/tests/test_SR.py
index b139f4c5..4e0de361 100644
--- a/tests/test_SR.py
+++ b/tests/test_SR.py
@@ -1,3 +1,5 @@
+from sm_typing import override
+
 import unittest
 import unittest.mock as mock
 import SR
@@ -18,10 +20,12 @@ class TestSR(unittest.TestCase):
         def verify(self):
             pass
 
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         pass
 
-    def tearDown(self):
+    @override
+    def tearDown(self) -> None:
         pass
 
     def create_SR(self, cmd, dconf, cmd_params=None):
diff --git a/tests/test_blktap2.py b/tests/test_blktap2.py
index d0e36daf..81311fb9 100644
--- a/tests/test_blktap2.py
+++ b/tests/test_blktap2.py
@@ -1,3 +1,5 @@
+from sm_typing import override
+
 import errno
 import json
 from io import StringIO
@@ -23,7 +25,8 @@ class TestTapdisk(unittest.TestCase):
     # hence no usual decorator mocks and the monkey patching.
     # https://bugs.python.org/issue23078
     #
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         subprocess_patcher = mock.patch("blktap2.subprocess")
         self.mock_subprocess = subprocess_patcher.start()
 
@@ -110,7 +113,8 @@ class TestTapdisk(unittest.TestCase):
 
 
 class TestVDI(unittest.TestCase):
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         self.addCleanup(mock.patch.stopall)
 
         lock_patcher = mock.patch('blktap2.Lock', autospec=True)
@@ -337,8 +341,8 @@ class TestVDI(unittest.TestCase):
 
 
 class TestTapCtl(unittest.TestCase):
-
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         subprocess_patcher = mock.patch("blktap2.subprocess")
         self.mock_subprocess = subprocess_patcher.start()
 
diff --git a/tests/test_cbt.py b/tests/test_cbt.py
index 9093f216..18bdc8a0 100644
--- a/tests/test_cbt.py
+++ b/tests/test_cbt.py
@@ -1,3 +1,5 @@
+from sm_typing import override
+
 import unittest.mock as mock
 import SR
 import testlib
@@ -15,7 +17,8 @@ import xmlrpc.client
 
 
 class TestVDI(VDI.VDI):
-    def load(self, vdi_uuid):
+    @override
+    def load(self, vdi_uuid) -> None:
         self.vdi_type = vhdutil.VDI_TYPE_VHD
         self._state_mock = mock.Mock()
         self.path = "/mock/sr_path/" + str(vdi_uuid)
@@ -25,46 +28,56 @@ class TestVDI(VDI.VDI):
     def state_mock(self):
         return self._state_mock
 
-    def _get_blocktracking_status(self, uuid=None):
+    @override
+    def _get_blocktracking_status(self, uuid=None) -> bool:
         return self.block_tracking_state
 
-    def _ensure_cbt_space(self):
+    @override
+    def _ensure_cbt_space(self) -> None:
         super(TestVDI, self)._ensure_cbt_space()
         self.state_mock._ensure_cbt_space()
 
-    def _get_cbt_logpath(self, uuid):
+    @override
+    def _get_cbt_logpath(self, uuid) -> str:
         super(TestVDI, self)._get_cbt_logpath(uuid)
         self.state_mock._get_cbt_logpath(uuid)
         return "/mock/sr_path/{0}.log".format(uuid)
 
-    def _create_cbt_log(self):
+    @override
+    def _create_cbt_log(self) -> str:
         logpath = super(TestVDI, self)._create_cbt_log()
         self.state_mock._create_cbt_log()
         self.block_tracking_state = True
         return logpath
 
-    def _delete_cbt_log(self):
+    @override
+    def _delete_cbt_log(self) -> None:
         self.state_mock._delete_cbt_log()
         self.block_tracking_state = False
 
-    def _rename(self, from_path, to_path):
+    @override
+    def _rename(self, from_path, to_path) -> None:
         self.state_mock._rename(from_path, to_path)
 
+    @override
     def _do_snapshot(self, sr_uuid, vdi_uuid, snapType,
-                     cloneOp=False, secondary=None, cbtlog=None):
-        self.state_mock._do_snapshot(sr_uuid, vdi_uuid, snapType, cloneOp,
-                                     secondary, cbtlog)
+                     cloneOp=False, secondary=None, cbtlog=None) -> str:
+        return self.state_mock._do_snapshot(
+            sr_uuid, vdi_uuid, snapType, cloneOp, secondary, cbtlog
+        )
 
-    def _activate_cbt_log(self, logname):
-        self.state_mock._activate_cbt_log(logname)
+    @override
+    def _activate_cbt_log(self, logname) -> bool:
+        return self.state_mock._activate_cbt_log(logname)
 
-    def _deactivate_cbt_log(self, logname):
+    @override
+    def _deactivate_cbt_log(self, logname) -> None:
         self.state_mock._deactivate_cbt_log(logname)
 
 
 class TestCBT(unittest.TestCase):
-
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         self.sr = mock.MagicMock()
         self.vdi_uuid = uuid.uuid4()
         self.sr_uuid = uuid.uuid4()
diff --git a/tests/test_cleanup.py b/tests/test_cleanup.py
index bd789515..d8c8055b 100644
--- a/tests/test_cleanup.py
+++ b/tests/test_cleanup.py
@@ -1,4 +1,4 @@
-from sm_typing import List
+from sm_typing import Dict, List, override
 
 import errno
 import unittest
@@ -54,7 +54,8 @@ def create_cleanup_sr(xapi, uuid=None):
 
 
 class TestSR(unittest.TestCase):
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         time_sleep_patcher = mock.patch('cleanup.time.sleep')
         self.mock_time_sleep = time_sleep_patcher.start()
 
@@ -1788,14 +1789,14 @@ class TestSR(unittest.TestCase):
 
 
 class TestLockGCActive(unittest.TestCase):
-
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         self.addCleanup(mock.patch.stopall)
 
         self.lock_patcher = mock.patch('cleanup.lock.Lock')
         patched_lock = self.lock_patcher.start()
         patched_lock.side_effect = self.create_lock
-        self.locks = {}
+        self.locks: Dict[str, TestLockGCActive.DummyLock] = {}
 
         self.sr_uuid = str(uuid4())
 
diff --git a/tests/test_fairlock.py b/tests/test_fairlock.py
index d0e1f61b..e003cc37 100644
--- a/tests/test_fairlock.py
+++ b/tests/test_fairlock.py
@@ -1,3 +1,5 @@
+from sm_typing import override
+
 import unittest
 import unittest.mock as mock
 
@@ -5,7 +7,8 @@ import socket
 from fairlock import Fairlock, FairlockServiceTimeout, FairlockDeadlock
 
 class TestFairlock(unittest.TestCase):
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         sock_patcher = mock.patch('fairlock.socket', autospec=True)
         self.mock_socket = sock_patcher.start()
         os_patcher = mock.patch('fairlock.os', autospec=True)
diff --git a/tests/test_fjournaler.py b/tests/test_fjournaler.py
index 115aaee9..67835875 100644
--- a/tests/test_fjournaler.py
+++ b/tests/test_fjournaler.py
@@ -1,3 +1,5 @@
+from sm_typing import Any, Dict, override
+
 from io import BytesIO as StringIO
 import os
 import unittest
@@ -32,9 +34,9 @@ class FakeFile(object):
 
 
 class TestFjournaler(unittest.TestCase):
-
-    def setUp(self):
-        self.files = {}
+    @override
+    def setUp(self) -> None:
+        self.files: Dict[str, Any] = {}
         self.open_handlers = {TEST_DIR_PATH: self.__fake_open}
 
         self.subject = fjournaler.Journaler(TEST_DIR_PATH)
diff --git a/tests/test_keymanagerutil.py b/tests/test_keymanagerutil.py
index d97bb172..70edbe5d 100644
--- a/tests/test_keymanagerutil.py
+++ b/tests/test_keymanagerutil.py
@@ -1,6 +1,9 @@
 """
 Test the "fake" keymanager for testing VHD encryption
 """
+
+from sm_typing import Dict, override
+
 import base64
 import copy
 import io
@@ -15,8 +18,8 @@ import util
 
 
 class TestKeymanagerutil(unittest.TestCase):
-
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         self.addCleanup(mock.patch.stopall)
 
         log_patcher = mock.patch('plugins.keymanagerutil.util.SMlog', autospec=True)
@@ -27,7 +30,7 @@ class TestKeymanagerutil(unittest.TestCase):
         self.mock_open = open_patcher.start()
         self.mock_open.side_effect = self.open
 
-        self.files = {}
+        self.files: Dict[str, io.StringIO] = {}
 
         isfile_patcher = mock.patch(
             'plugins.keymanagerutil.os.path.isfile', autospec=True)
diff --git a/tests/test_lock.py b/tests/test_lock.py
index f90d3bb6..bee447a0 100644
--- a/tests/test_lock.py
+++ b/tests/test_lock.py
@@ -1,3 +1,5 @@
+from sm_typing import override
+
 import fcntl
 import unittest
 import unittest.mock as mock
@@ -12,8 +14,8 @@ import lock
 
 
 class TestLock(unittest.TestCase):
-
-    def tearDown(self):
+    @override
+    def tearDown(self) -> None:
         lock.Lock.INSTANCES = {}
         lock.Lock.BASE_INSTANCES = {}
 
@@ -197,7 +199,8 @@ def create_lock_class_that_fails_to_create_file(number_of_failures):
     class LockThatFailsToCreateFile(lock.LockImplementation):
         _failures = number_of_failures
 
-        def _open_lockfile(self):
+        @override
+        def _open_lockfile(self) -> None:
             if self._failures > 0:
                 error = IOError('No such file')
                 error.errno = errno.ENOENT
diff --git a/tests/test_lock_queue.py b/tests/test_lock_queue.py
index edd733dc..e9622cff 100644
--- a/tests/test_lock_queue.py
+++ b/tests/test_lock_queue.py
@@ -1,3 +1,5 @@
+from sm_typing import override
+
 import builtins
 import copy
 import os
@@ -22,7 +24,8 @@ def mock_pickle_load_fn(*args):
 
 
 class Test_LockQueue(unittest.TestCase):
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         # Re-initialize queue to empty for each test
         global saved_queue
         saved_queue = []
diff --git a/tests/test_lvutil.py b/tests/test_lvutil.py
index 2df8300b..439c1fbe 100644
--- a/tests/test_lvutil.py
+++ b/tests/test_lvutil.py
@@ -1,3 +1,5 @@
+from sm_typing import override
+
 import unittest.mock as mock
 import os
 import syslog
@@ -25,7 +27,8 @@ def with_lvm_subsystem(func):
 
 
 class TestCreate(unittest.TestCase):
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         lock_patcher = mock.patch('lvutil.Fairlock', autospec=True)
         self.addCleanup(lock_patcher.stop)
         self.mock_lock = lock_patcher.start()
@@ -98,7 +101,8 @@ class TestCreate(unittest.TestCase):
 
 
 class TestRemove(unittest.TestCase):
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         lock_patcher = mock.patch('lvutil.Fairlock', autospec=True)
         self.addCleanup(lock_patcher.stop)
         self.mock_lock = lock_patcher.start()
@@ -123,8 +127,8 @@ class TestRemove(unittest.TestCase):
 
 
 class TestDeactivate(unittest.TestCase):
-
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         lock_patcher = mock.patch('lvutil.Fairlock', autospec=True)
         pathexists_patcher = mock.patch('lvutil.util.pathexists', autospec=True)
         lexists_patcher = mock.patch('lvutil.os.path.lexists', autospec=True)
@@ -208,7 +212,8 @@ class TestDeactivate(unittest.TestCase):
 
 
 class TestActivate(unittest.TestCase):
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         self.addCleanup(mock.patch.stopall)
 
         lock_patcher = mock.patch('lvutil.Fairlock', autospec=True)
diff --git a/tests/test_mpath_dmp.py b/tests/test_mpath_dmp.py
index 134b40e0..312b55da 100644
--- a/tests/test_mpath_dmp.py
+++ b/tests/test_mpath_dmp.py
@@ -1,6 +1,9 @@
 """
 Unit tests for mpath dmp
 """
+
+from sm_typing import override
+
 import errno
 import os
 import unittest
@@ -22,7 +25,8 @@ class TestMpathDmp(unittest.TestCase):
     Unit tests for mpath dmp
     """
 
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         time_patcher = mock.patch('mpath_dmp.time', autospec=True)
         self.mock_time = time_patcher.start()
 
diff --git a/tests/test_on_slave.py b/tests/test_on_slave.py
index 4b59f632..b55e24aa 100644
--- a/tests/test_on_slave.py
+++ b/tests/test_on_slave.py
@@ -1,3 +1,5 @@
+from sm_typing import override
+
 import errno
 import unittest
 import unittest.mock as mock
@@ -27,7 +29,8 @@ class Test_on_slave_is_open(unittest.TestCase):
         print('Asked to import {}'.format(args[0]))
         return self.mocks.get(args[0], self.real_import(*args, **kwargs))
 
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         self.addCleanup(mock.patch.stopall)
         self.mocks = {x: mock.MagicMock() for x in self.MOCK_IMPORTS}
 
@@ -132,7 +135,8 @@ class Test_on_slave_refresh_lun(unittest.TestCase):
     Tests for refresh_lun_size_by_SCSIid
     """
 
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         self.mock_session = mock.MagicMock()
 
     @mock.patch('on_slave.scsiutil')
@@ -164,7 +168,8 @@ class Test_on_slave_multi(unittest.TestCase):
 
     TMP_RENAME_PREFIX = "TEST_OLD_"
 
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         self.session = mock.MagicMock()
 
         lvmcache_patcher = mock.patch('on_slave.LVMCache', autospec=True)
diff --git a/tests/test_sr_health_check.py b/tests/test_sr_health_check.py
index c104e962..22e78378 100644
--- a/tests/test_sr_health_check.py
+++ b/tests/test_sr_health_check.py
@@ -1,3 +1,5 @@
+from sm_typing import override
+
 import unittest
 import unittest.mock as mock
 
@@ -10,8 +12,8 @@ SR_UUID = 'sr uuid'
 
 
 class TestSrHealthCheck(unittest.TestCase):
-
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         util_patcher = mock.patch('sr_health_check.util')
         self.mock_util = util_patcher.start()
         self.mock_session = mock.MagicMock()
diff --git a/tests/test_srmetadata.py b/tests/test_srmetadata.py
index 720f12ff..fbce6244 100644
--- a/tests/test_srmetadata.py
+++ b/tests/test_srmetadata.py
@@ -1,3 +1,5 @@
+from sm_typing import Generator, override
+
 import io
 import random
 import string
@@ -453,14 +455,17 @@ class LVMMetadataTestContext(testlib.TestContext):
         super().__init__()
         self._metadata_file_content = b'\x00' * 4 * 1024 * 1024
 
-    def start(self):
+    @override
+    def start(self) -> None:
         super().start()
         self.patch("util.gen_uuid", new=genuuid)
 
-    def generate_device_paths(self):
+    @override
+    def generate_device_paths(self) -> Generator[str, None, None]:
         yield self.METADATA_PATH
 
-    def fake_open(self, fname, mode='r'):
+    @override
+    def fake_open(self, fname, mode='r') -> io.TextIOBase:
         if fname != self.METADATA_PATH: # pragma: no cover
             return super().fake_open(fname, mode)
         else:
diff --git a/tests/test_storage_init.py b/tests/test_storage_init.py
index d91d9089..38e46570 100644
--- a/tests/test_storage_init.py
+++ b/tests/test_storage_init.py
@@ -1,3 +1,5 @@
+from sm_typing import DefaultDict, Dict, List, override
+
 import json
 import os
 import re
@@ -31,7 +33,8 @@ class TestStorageInit(unittest.TestCase):
     storage after installation.
     """
 
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         self.test_dir = tempfile.TemporaryDirectory()
 
         # There are tweaks we need to make the to storage-init:
@@ -103,11 +106,12 @@ class TestStorageInit(unittest.TestCase):
         self.copy_command("touch")
 
         self.script_exited = False
-        self.created_srs = defaultdict(list)
-        self.misc_xe_calls = []
-        self.unanticipated_xe_calls = []
+        self.created_srs: DefaultDict[str, List[Dict[str, str]]] = defaultdict(list)
+        self.misc_xe_calls: List[List[str]] = []
+        self.unanticipated_xe_calls: List[List[str]] = []
 
-    def tearDown(self):
+    @override
+    def tearDown(self) -> None:
         self.socket.close()
         self.test_dir.cleanup()
 
diff --git a/tests/test_util.py b/tests/test_util.py
index 965eec15..26912f1f 100644
--- a/tests/test_util.py
+++ b/tests/test_util.py
@@ -1,3 +1,5 @@
+from sm_typing import Any, Dict, List, Set, override
+
 import copy
 import errno
 import io
@@ -43,7 +45,8 @@ class TestUtil(unittest.TestCase):
     Tests for the util module methods
     """
 
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         # OS Patchers
         statvfs_patcher = mock.patch("util.os.statvfs", autospec=True)
         self.mock_statvfs = statvfs_patcher.start()
@@ -53,7 +56,7 @@ class TestUtil(unittest.TestCase):
         self.mock_mkdir = mkdir_patcher.start()
         unlink_patcher = mock.patch('util.os.unlink', autospec=True)
         self.mock_unlink = unlink_patcher.start()
-        self.dir_contents = {}
+        self.dir_contents: Dict[str, List[str]] = {}
         listdir_patcher = mock.patch('util.os.listdir', autospec=True)
         self.mock_listdir = listdir_patcher.start()
         self.mock_listdir.side_effect = self.list_dir
@@ -77,12 +80,12 @@ class TestUtil(unittest.TestCase):
         self.mock_session = mock.MagicMock()
         self.mock_xenapi.xapi_local.return_value = self.mock_session
 
-        self.processes = {}
+        self.processes: Dict[str, Any] = {}
         popen_patcher = mock.patch('util.subprocess.Popen', autospec=True)
         self.mock_popen = popen_patcher.start()
         self.mock_popen.side_effect = self.popen
 
-        self.mock_files = {}
+        self.mock_files: Dict[str, Any] = {}
 
         self.addCleanup(mock.patch.stopall)
 
@@ -714,7 +717,8 @@ class TestUtil(unittest.TestCase):
 
 
 class TestFistPoints(unittest.TestCase):
-    def setUp(self):
+    @override
+    def setUp(self) -> None:
         self.addCleanup(mock.patch.stopall)
         sleep_patcher = mock.patch('util.time.sleep', autospec=True)
         self.mock_sleep = sleep_patcher.start()
@@ -725,7 +729,7 @@ class TestFistPoints(unittest.TestCase):
         exists_patcher = mock.patch('util.os.path.exists', autospec=True)
         self.mock_exists = exists_patcher.start()
         self.mock_exists.side_effect = self.exists
-        self.existing_files = set()
+        self.existing_files: Set[str] = set()
 
         xenapi_patcher = mock.patch('util.XenAPI', autospec=True)
         patched_xenapi = xenapi_patcher.start()
diff --git a/tests/testlib.py b/tests/testlib.py
index 167bb172..066188f4 100644
--- a/tests/testlib.py
+++ b/tests/testlib.py
@@ -1,3 +1,5 @@
+from sm_typing import Any, Generator, override
+
 import re
 import unittest.mock as mock
 import os
@@ -49,12 +51,13 @@ class SCSIAdapter(object):
     def add_parameter(self, host_class, values):
         self.parameters.append((host_class, values))
 
-    def adapter_device_paths(self, host_id):
+    def adapter_device_paths(self, host_id) -> Generator[str, None, None]:
         yield '/sys/class/scsi_host/host%s' % host_id
 
 
 class AdapterWithNonBlockDevice(SCSIAdapter):
-    def adapter_device_paths(self, host_id):
+    @override
+    def adapter_device_paths(self, host_id) -> Generator[str, None, None]:
         for adapter_device_path in super(AdapterWithNonBlockDevice,
                                          self).adapter_device_paths(host_id):
             yield adapter_device_path
@@ -115,7 +118,7 @@ class TestContext(object):
         self.patchers.append(patcher)
         patcher.start()
 
-    def start(self):
+    def start(self) -> None:
         self.patch('builtins.open', new=self.fake_open)
         self.patch('fcntl.fcntl', new=self.fake_fcntl)
         self.patch('os.path.exists', new=self.fake_exists)
@@ -190,7 +193,7 @@ class TestContext(object):
             'x86_64'
         )
 
-    def fake_open(self, fname, mode='r'):
+    def fake_open(self, fname, mode='r') -> Any:
         if fname == '/etc/xensource-inventory':
             return io.StringIO(self.generate_inventory_contents())
 
@@ -264,7 +267,7 @@ class TestContext(object):
         for path, value in self._path_content.items():
             yield (path, value)
 
-    def generate_device_paths(self):
+    def generate_device_paths(self) -> Generator[str, None, None]:
         actual_disk_letter = 'a'
         for host_id, adapter in enumerate(self.scsi_adapters):
             for adapter_device_path in adapter.adapter_device_paths(host_id):
